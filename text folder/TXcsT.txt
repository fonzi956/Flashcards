
Diagnostic Quiz
2

1. Which of the choices below refers to the definition of an abstract data type in OOP, describing the type of data contained, as well as any processes that act on that data?
object
method
class correct
procedure
function
I have no idea.
Explanation
A class in OOP is the definition of an abstract data type. An object is an instance of the class.
Domain 2, Group 4, Competency C, OOP Concepts

2. Which of the choices below refers to a legacy programming language that was developed to serve the needs of business oriented applications?
Java
Python
C++
ForTran
COBOL correct
I have no idea.
Explanation
COBOL, short for Common Business Oriented Language, was developed under the leadership of Grace Hopper, to provide a better programming environment than ForTran for business oriented applications.
Domain 2, Group 6, Competency E, Languages

3. A sort algorithm finds the best place in an already sorted portion of the list for the next unsorted item. Which sort algorithm listed below best fits this description?
selection sort
insertion sort correct
merge sort
quick sort
I have no idea.
Explanation
Although the selection sort also appears to be a close fit, the selection sort finds the best value for the next place, where the insertion sort finds the best place for the next value.
Domain 3, Group 9, Competency B, Insertion Sort

4. Which choice below refers to a type of programming language that uses words and commands easy for humans to understand and organize, but must be translated into a language easy for the computer to understand and execute?
Low Level
High Level correct
Object Oriented
Assembly
Machine Language
I have no idea.
Explanation
High level languages are easy for humans, but impossible for machines. Low level languages are very difficult for humans, but easy for machines.
Domain 2, Group 6, Competency C, Language Levels


5. Which choice below refers to the type of parameter where changes inside of the called method DO NOT affect the original data?
Actual parameter
Formal parameter
Reference parameter
Value parameter correct
I have no idea.
Explanation
A parameter passed by value sends a copy of the actual parameter to the formal parameter, where any changes made in the method by the formal parameter have no effect on the state of the actual parameter.
Domain 3, Group 7, Competency H, Parameters

6. What is output by the pseudocode segment shown below?
boolean p ← true
boolean q ← false
print p OR q
true correct
false
p XOR q
I have no idea.
Explanation
The OR logical operator is true only when either or both the operands are true.
Domain 3, Group 8, Competency B, OR Operator

7. Forgetting to end a string with a required double quote character is an example of a ______________ error.
Lexical
Syntax correct
Runtime
Logic
I have no idea.
Explanation
Any punctuation type error is referred to as a syntax error.
Domain 2, Group 5, Competency K, Debugging/Errors


8. Which choice below represents the hexadecimal (base 16) equivalent of the binary value 10110111?
B7 correct
117
183
267
I have no idea.
Explanation
The binary value 10110111 expands to 128 + 32 + 16 + 4 + 2 + 1, which has a sum of 183 in base 10, which converts to B7 in hexadecimal.
Domain 3, Group 7, Competency A, Number Base Concepts

9. Which loop style listed below will ALWAYS act at least once?
do while correct
for
All will act at least once
while
I have no idea.
Explanation
Since the do while is a posttest loop, the action of the loop takes place BEFORE the while condition is checked, and therefore will always act at least once. The for and while check the condition BEFORE the action takes place. If the condition is false from the start, no action will take place in these two loop structures.
Domain 3, Group 8, Competency C, Loops


10. Which of the following is NOT a true statement about the binary search process?
The precondition is that the list must be sorted.
The target value must be contained within the list. correct
The process checks the middle item for a match, and then looks to the right or to the left if it doesn't match, repeating this process until a match is found, or not.
The average case scenario Big O running time is O(log N).
I have no idea.
Explanation
The only requirement for a binary search is that the list being searched is in ascending sorted order.
Domain 3, Group 9, Competency A, Binary Search

11. What is output by the following pseudocode segment?
int x = 5
  int y = 6
  int z = -2
  if(x > y OR y < z)
    print "Lions "
  else
  if(x > z AND z < y)
    print "Tigers "
  else
  if(x == y XOR y >= z)
    print "Bears "
  else
    print "Oh my!"

Lions
Tigers correct
Bears
Oh my!
Tigers Bears
I have no idea.
Explanation
The first if is false since x is NOT greater than y and y is NOT less than z. The second if is true since x is indeed greater than z and z is indeed less than y, resulting in the output statement "Tigers". The third if is also true since x is equal to y but y is NOT greater than or equal to z, satisfying the opposite conditions required by XOR to be true, but since the second if already was true, the third if is never visited, and therefore "Bears " is not output.
Domain 3, Group 8, Competency C, Conditionals


12. What is output by the pseudocode segment shown below?

print 16 % 5
1 correct
3
11
21
I have no idea.
Explanation
The % operator represents the modulus operation, which takes the remainder after division. After dividing 16 by 5, the remainder is 1.
Domain 3, Group 8, Competency A, Modulus Operator

13. Which statement listed below is NOT true about two dimensional arrays?

Values are accessed using an indexing process, where the first index represents the column, and the second represents the row. correct
The number of columns in each row can be different.
Values for each row are stored in contiguous memory.
All elements contained in the array must be of the same data type.
I have no idea.
Explanation
In most modern languages, two-dimensional arrays are accessed in "row major" order, with the row indicated first, and then the column.
Domain 3, Group 7, Competency J, 2D Arrays


14. Which data structure below is characterized by the term "FIFO"?
Stack
Array
Tree
Linked List
Queue correct
Graph
I have no idea.
Explanation
A queue pushes items to the back of the list, and peeks or pops elements from the front of the list, resulting in a First In, First Out, or FIFO sequence.
Domain 3, Group 7, Competency M, Queues

15. After the integer elements 5, 3, 7, 1, 2, 4 are rightly inserted into an ascending order binary search tree, what is the resulting inorder traversal?

1 2 5 3 4 7
5 3 1 2 4 7
1 2 3 4 5 7 correct
5 3 1 2 7 4
I have no idea.
Explanation
The nature of the binary search tree is that all of the elements are in relative order, and when an inorder traversal is performed, the result is just that...the elements in ascending order. The resulting tree has 5 as the root, 3 and 7 at the next level, 1 and 4 as children of 3, and 2 as the right child of 1.
Domain 3, Group 7, Competency M, Binary Search Tree Traversal

16. Which of the following defines the principle of "fair use"?

A legal principle that defines the limitations on the exclusive rights of copyright holders. correct
A government license that gives the holder exclusive rights to a process, design or new invention for a designated period of time.
Any name, symbol, figure, letter, word, or mark adopted and used by a manufacturer or merchant in order to designate his or her goods and to distinguish them from those manufactured or sold by others.
The exclusive legal right to reproduce, publish, sell, or distribute the matter and form of something.
I have no idea.
Explanation
Choice B describes a patent, C defines a trademark, and D a copyright.
Domain 1, Group 1, Competency L, Ethical Acquisition/Fair Use

17. Which of the following choices controls the transfer of web pages in a network?

SMTP
HTTP correct
HTML
POP
I have no idea.
Explanation
SMTP controls the transfer of email messages. HTTP controls the transfer of web pages. HTML controls how web pages look in a browser. POP controls how email messages are stored.
Domain 1, Group 1, Competency C, Networking

18. In the spreadsheet shown below, cell A1 (cA,r1) contains the value 4 that is to be used in a formula copied down and across a grid of several rows (2 through 5) and several columns (B through E).

The top row cells B1 through E1 contain several different values, as do the left column cells A2 through A5.

The formula in each cell is to add together three values: the value at the top row of that column, the value at the left column of that row, and the value in cell A1, resulting in the grid you see below.

For example, the value in cell B2(9) is the sum of the values in cells A1(4), B1(2), and A2(3). The value in cell E5(16) is the sum of A1(4), E1(3), and A5(9).

What is the right formula for cell B2 that will rightly copy down and across to achieve the values shown below?

   cA cB cC cD cE
r1  4  2  6  8  3
r2  3  9 13 15 10
r3  7 13 17 19 14
r4  2  8 12 14  9
r5  9 15 19 21 16
=A1+B1+A2
=$A1+B$1+$A2 correct
=$A$1+B$1+$A2
=A$1$+B1$+A$2
I have no idea.
Explanation
The $ symbol indicates an absolute reference, and when placed BEFORE a row or column will keep that row or column static when a cell is copied down or across. To keep a complete cell static, a $ must be placed before both the row and column value.
Domain 1, Group 2, Competency A, General Productivity Software, Spreadsheets/Absolute Reference

19. Which choice below represents the type of diagram used to represent the structure of objects in OOP?
UML diagram
Flowchart
Backus Naur notation
Syntax diagram
I have no idea.
Explanation
UML, or Unified Modeling Language, is a graphical way to show the structure of objects, showing the data included, as well as processes that act on the data.
Domain 2, Group 4, Competency D, UML Diagrams

20. For a list of 1000 elements, using a process that is considered to have an O(log N) running time in all situations, what value below represents the approximate number of steps it will take for the algorithm to complete its task?
1
10 correct
100
1000
I have no idea.
Explanation
The nature of an O(log N) process is that the maximum number of steps required to complete the task is the log value, base 2, of the size of the data set. In this case, 10 is the log value, base 2, of 1024, which is the closest exact power of 2 just beyond 1000. This means that it will take no more than 10 steps to process this list of 1000 elements using an O(log N) process.
Domain 3, Group 9, Competency C, Big O Analysis

END OF QUIZ


Software System Life Cycle (SSLC)
    The five standard stages of development for a software development project include analysis, design, implementation (coding), testing and maintenance. These steps are not always performed only once, end-to-end, but are cyclical in nature, and the approach to executing the stages is referred to as the development methodology.
Analysis
    This is the initial stage of the SSLC, where general questions are asked and answered about the needs and goals of the software project.
Design
    This is the next stage of the SSLC, where decisions from the analysis stage are taken to the drawing board and an appropriate design for the project is determined. This stage uses one or more approaches, e.g., top-down, bottom-up, or object oriented design.
Implementation (Coding)
    During this stage, developers write and document the code to implement the project, based on the design.
Testing
    Sample data is produced based on the analysis and design of the project, and then tests using the data are run against the code to ensure that the software performs as expected.
Maintenance
    After the software project is in service, periodic adjustments are made based on the observed performance of the software package over time, as well as in response to changing conditions.


    Top-Down Design
        A top-down approach is the process of breaking down a project into smaller and smaller pieces until each piece performs one simple task.  In a top-down approach, an overview of the project is formulated, and then broken down into more specific, lower-level tasks. It is synonymous with step-wise refinement, which is the incremental process of designing an application or procedure by looking at the requirements and devising an initial solution. Then the solution is inspected for patterns that can be abstracted and iterated until the solution meets the objectives of performance, clarity and quality.
    Bottom-up Design
        A design methodology that involves using existing programming libraries and APIs to design a system or application, saving time and effort by using predefined and tested modules to help implement the overall solution.
    Object Oriented Design
        A design methodology that uses interacting objects using the big ideas of Abstraction, Inheritance, and Polymorphism.

    Comparing Design Strategies
    There are three basic design strategies for software design: Top Down, Bottom Up, and Object Oriented. Let's review the features of each.


Strategy    Top Down (or Stepwise Refinement)

Features
        Breaks down large projects into steps that are easily managed
        Final low-level tasks are easy to implement

Strategy    Bottom Up

Features
        Uses predefined and tested modules to help implement the solution
        Saves time and effort, not needing to "reinvent the wheel" for task solutions that already exist

Strategy    Object Oriented Design

Features
        Is data-centered
        Bundles actions and processes with data into a neat package


Flowchart
A visual organizer system in programming that indicates the flow of a program, using process blocks, decision diamonds and arrows.

Unified Modeling Language (UML)
A general-purpose modeling language in the field of software engineering, used to visualize an Object Oriented Design system.




Software Design Terminology Practice
problem

The process of breaking down large modules of a project into smaller, more manageable modules, a key part of the top down design process.
Bottom-up
Stepwise refinement correct
UML
Flowchart


problem

A diagram used to represent the overall structure of an object-oriented class design.
Top-down
Bottom-up
Stepwise refinement
UML correct
Flowchart


problem

A visual organizer developed to graphically show objects and their contents.
UML/Unified Modeling Language correct
Flowchart
Pseudocode
Syntax Diagram


problem

The stage in the software system life cycle that writes the program using a suitable programming language.
Analysis
Design
Implementation (Coding) correct
Testing
Maintenance

problem

Which of the following best describes the purpose of creating a flowchart as part of the design of a computer program?
To test and maintain the efficiency of the overall program
To ensure that all methods are appropriately linked
To graphically display the steps needed to solve the programming problem correct
To determine the necessary number of global and local variables

problem

Design strategy of using pre-existing modules to put together a project.
Bottom-up correct
Top-down/Stepwise
Object-oriented
Cyclical

problem

The stage in the software system life cycle that manages the software project after it has been rolled out and put into use.
Analysis
Design
Implementation (Coding)
Testing
Maintenance correct



Software Development Models


Waterfall
    The Waterfall model was commonly used for years in standard industry production. This model is sequential in nature, with progress flowing steadily down (like a waterfall) through the phases of idea, analysis, design, development and test. The disadvantage of this methodology is that it is rigid and does not easily allow for modifications.
Incremental
    The Incremental model defines the system software development process in small steps, completing all of the SSLC phases for each subset of the application, and then repeating the cycle for each portion until the project is complete. This is an improvement over the waterfall model because it provides more opportunity to make adjustments as needed with less cost involved in making changes along the way.
Agile Methodologies (SCRUM, XP, Kanban)
    Agile refers generally to a set of four simple principals outlined in the Agile Manifesto.  There are several prescriptions for Agile methodologies including SCRUM, XP, and Kanban.   Agile approach's are both incremental and iterative.  They emphasizes continuous delivery of working software that is coded, tested and fixed over short intervals that are typically one to three weeks in duration.  Below is a graphical representation of the SCRUM methodology.  A subset of system requirements are selected from the backlog and implemented and delivered in each iteration.
Spiral
    The Spiral model is a risk-driven process model generator for software projects. Based on the unique risk patterns of a given project, the spiral model guides a team to adopt elements of one or more process models, such as incremental, waterfall, or evolutionary prototyping. Before any changes are made to the original plan, a risk assessment is performed, helping to decide the nature and degree of the recommended change.


    Comparing the Development Models

    Here are the pros and cons of the software development models.
    Model                       	Pros	                                        Cons


    Waterfall Model
                                  Offers a clear, straightforward process
                                  Stages can be easily tracked and managed
                                  It's easy to see progress
                                  Easy to document



                                                                                Assumes requirements are clear and unchanging
                                                                                Does not build in iteration
                                                                                Does not build testing and review into each step, therefore changes can be costly


    Incremental Model


                                  Introduces more flexibility to change
                                  Builds in customer testing and evaluation
                                  Easier to manage risk



                                                                                Requires good planning and design to work effectively

    SCRUM Agile Model


                                  Very flexible
                                  Builds in rapid iteration and feedback
                                  Can reduce total number of bugs in final product



                                                                                Prone to "feature creep" and over-budget
                                                                                Documentation can suffer


    Spiral Model


                                  Very flexible
                                  Excellent at managing risky projects
                                  Uses the best of other models
                                  Uses prototyping extensively



                                                                                Can be difficult to stop the process of iteration
                                                                                Complex to manage
                                                                                Documentation is difficult
                                                                                Is costly


Style Conventions


Spacing and Indentation

Some programming languages, like C++ and Java, do not require the use of format spacing and indentation when writing code, but some do, such as Python. However, consistent and effective format spacing and indenting allows other developers to better see and understand your code. Companies typically define standards that all developers should follow. This saves time and money during the implementation, testing and maintenance phases of the software project.
Descriptive Identifiers

Identifiers such as variable, method and class names should accurately describe the data or action. This will make your code easier for others to read and understand. It will also save time and money during the implementation, testing and maintenance phases of the software project.
Case-Specific Identifiers

Identifiers such as variable, method and class names typically use specific upper and lower case letters to indicate the identifier type. This makes the code easier to read and understand.

Identifiers that need more than one word to describe them typically use the CamelCase style, with an initial capital for each of the words. Examples include CollegeStudent for the name of a class that represents a college student and getName for a method that retrieves the name of that student.

Case also typically indicates the identifier type. For example, since CollegeStudent mentioned above is a class, the first letter is capitalized.  Since firstName and getFirstName are a variable and method name, respectively, the first letter of each identifier is lower-cased.

A constant is a memory location that does not change value during the execution of a program, once the value has been assigned. Names of constants are typically spelled with all capital letters, for example, PI. If the identifier contains more than one word, they can be separated by an underscore, for example, OVERTIME_RATE.
Comments for Documentation

Comments are simple English sentences or phrases embedded into a program, but hidden from the compiler. For example, comments in the C and Java use // symbols for single line comments and  /* and */ for multi-line comments. Comments also increase the readability of your code, especially for difficult or unintuitive sections of code.
Pre- and Post-Condition Comments

Preconditions and postconditions are special kinds of documentation written for a process.

The precondition describes what must be true in order for the process to perform its task. For example, the precondition for a binary search algorithm requires an ascending ordered list as the input collection to be searched.

The postcondition describes what will be true when the process is complete. For example, a binary search would return the position of the found value in the provided array, or a negative value of some kind if the target was not found.



Robust Program Creation
Terms to Know

Robust
    Robust means to be able to withstand or overcome adverse conditions. A program is considered to be robust if it responds gracefully (no crashes, logical next step and effective messaging), regardless of bad input, lost network connection or other unexpected event. Robust programs require more time in design and development, but will save time and money during the maintenance phase. Strategies for robust code development include unit testing, input protection, data validation and exception handling.
Unit Testing
    A program is made up of many parts, each of which performs a crucial task.  Unit testing is the process of testing each individual process to ensure it is working in all possible conditions, so that when it is incorporated into the larger process, its function is flawless.
Input Protection and Data Validation
    These two ideas go hand in hand in the development of robust software. Protecting against bad data entering a software process includes some way of testing a piece of data to make sure it is in the proper form, such as making sure that someone's name is actually a string of characters, and not a numeric value, or that someone's age is indeed a valid number, and not a word or phrase.
Exception
    An error in programming that is "thrown" when something bad happens in a program, usually during runtime.  In Java, there is a whole family of Exceptions, like IndexOutOfBoundsException or FileNotFoundException. Generally there are two types: checked and unchecked, checked meaning they are checked during compile time, and unchecked when they are thrown during runtime.
Exception Handling
    An exception is an error, plain and simple, that might occur during the execution of a program. A program developer must consider all possible ways that something might break a program, and then protect against that possibility. A robust program is one where all possible "bad" scenarios have been considered and "handled". Most general purpose programs have processes that provide for this "exception handling", and Java is no different. Below is a code sample that uses the try catch block, a Java language feature that "handles exceptions" in a way that helps a program to be robust, able to handle situations that might cause a program crash.

String name;
try {
 f = new Scanner(new File("nameFile.txt"));
 name = f.nextLine();
}
catch(Exception e) {
 name="John Smith";
}


Software Development Terminology Practice
problem


A formal comment block that describes what a process needs in order to be effective.
Try-catch Block
Style Conventions
Precondition correct
Postcondition


problem

A development process currently in use by many software companies that involves the use of sprints on a monthly or weekly basis throughout the span of the project.
Incremental
Spiral
Waterfall
Agile correct


problem

The practice of using capital letters and lowercase letters to enhance the readability of programmer created multi-word identifiers for variables, method names, and class names.
CamelCase correct
Style Conventions
Constant Name
Class Name


problem

Development process that achieves production in small steps, where design, implementation, and testing occur during each step.
Incremental correct
Spiral
Waterfall
Agile


problem

This module in some programming languages typically starts with an uppercase letter.
Constant
Class correct
Method
Precondition
Postcondition


problem

A system of using rules to control various aspects of the implementation process of a program that enhances readability and functionality, such as indenting, spacing, naming identifiers, use of comments, and documentation.
Style conventions correct
CamelCase
Try catch block
Pseudocode


problem

A software system is to be developed for which the requirements are well understood and the risk of failure is minimal. To meet these requirements, which of the following software development models would be most appropriate to use?
Agile
Waterfall correct
Hexagonal Sprinting
Spiral


problem

Development process that combines features of other development models into a cyclical process, including several phases, one of which is risk analysis.
Agile
Spiral correct
Waterfall
Incremental


problem


Traditional development process, that includes the idea phase, analysis, design, development, testing, through to the final product, where any changes in the original design come at significant cost.
Incremental
Spiral
Waterfall correct
Agile


problem

This technique is used in some programming languages to provide input protection in order to make the program more robust.
Style conventions
CamelCase
Try catch block correct
Pseudocode







Introduction to Object-Oriented Programming

Object-Oriented Programming
    Object-Oriented Programming (OOP) is a programming language model using objects that contain data as the main focus, with actions and processes directly associated with the data.
Imperative (Procedural) Programming
    Imperative, or Procedural, programming is a paradigm in which a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal. Most of the mainstream programming languages, such as C++, Java, and Python, support procedural programming.
Functional Programming

    Functional programming, as opposed to Imperative programming, is a pure functional approach to problem solving. Functional programming is a form of declarative programming. Languages that support this style of programming include Scheme, Haskell, LISP, Racket, and F#.
Object
    This is an instance of a Class created during program execution that encapsulates data and related actions or processes, often called methods.
Class
    This is the definition of an Object, describing the type of data owned by the object, as well as methods that act on that data.
Encapsulation
    Encapsulation is one of the three central principles (along with Inheritance and Polymorphism) of Object Oriented Programming. Encapsulation incorporates related data items and processes into a class definition, including instance variables, constructors, accessor and modifier (mutator) methods.
Abstraction/Information Hiding
    Abstraction, or "Information Hiding," is a term associated with Encapsulation. Through the process of Abstraction, a programmer hides all but the relevant data about and interaction with an object, in order to reduce complexity and increase efficiency, especially when improvements or modifications need to be made from time to time.


Inheritance and Composition
OOP Inheritance and Composition
Inheritance
    Inheritance is one of the three pillars of OOP (Object Oriented Programming), along with Composition and Encapsulation. Inheritance allows classes to be defined based on previously defined and developed classes, receiving all of the characteristics of the parent class, and then expanding on those features.
“Is-a” Relationship
    The concept of inheritance, in which one class is derived from another class, can be described as an "is-a" relationship. For example, when a Student class inherits from a Person class, the Student "is a" Person.
Child Class
    A class that inherits the characteristics of a parent class.
Class
    The definition of an object, describing the type of data owned by the object, as well as methods that act on that data.
Composition
    Composition is the process of combining simpler objects into more complex objects. For example, a Car class might include a BodyType object, an Engine object, and a TransmissionType object.
“Has-a” Relationship
    The concept of Encapsulation, in which one class is composed of multiple, simpler classes, can be described by a "has-a" relationship. For example, when a Car object includes Body and Engine objects, the Car "has-a" Body and the Car "has-an" Engine.


Polymorphism
    This term literally means in Greek, "many forms", and is a key aspect of object-oriented programming, where methods can be redefined (overloaded or overridden) as needed and desired.
Over Methods
    The polymorphic feature of object-oriented programming where constructors and methods are named the same but operate on different input parameters in order to perform the same task.

Overriding Methods
    The polymorphic feature of object-oriented programming where methods inherited from parent classes, such as the toString Java method from the Object class, are redefined and customized to better fit the purpose of the current class.

Polymorphic Objects
    This aspect of polymorphism refers to how a parent object can reference any of its child objects, or any descendant several levels of inheritance down the way.



Object-Oriented Programming Terminology Practice
problem


A term in OOP related to encapsulation, sometimes called "information hiding", that indicates the concept where a programmer hides all but the relevant data and processes about an object in order to reduce complexity and increase efficiency.
Encapsulation
Polymorphism
Inheritance
Abstraction correct
Composition


problem

Which object-oriented programming concept is described by the following: A parent class J has child classes K and L, and can reference objects of either class.
Encapsulation
Polymorphism correct
Inheritance
Composition


problem

One of the three pillars of object oriented programming that allows for classes to be defined based on previously defined and developed classes, receiving all of the characteristics of the pre-defined class, and then expanding on those features, easily identified as an "is a" relationship.
Encapsulation
Abstraction
Inheritance correct
Composition


problem

Which object-oriented programming concept is described by the following: A certain class GraduateStudent is partially made up of predefined classes Student and CollegeStudent.
Encapsulation
Polymorphism
Inheritance
Composition correct


problem

Which object-oriented programming concept is described by the following: Class Car has several methods, all named openDoor, but which work in different ways.
Encapsulation
Polymorphism correct
Inheritance
Composition


problem


A programming entity that encapsulates data and related methods into one package.
function
class
object correct
method
procedure


problem

Which object-oriented programming concept is described by the following: Class Cupcake inherited a method from class Dessert and redefined it.
Encapsulation
Polymorphism correct
Inheritance
Composition


problem

Which object-oriented programming concept is described by the following: A process in class H is defined in several different ways, but achieves the same result.
Encapsulation
Polymorphism correct
Inheritance
Composition


problem

In object-oriented programming, this is the process of combining simpler data types into more complex data types; easily identified as a "has a" relationship.
Encapsulation
Abstraction
Inheritance
Composition correct


problem

Which object-oriented programming concept is described by the following: Class Jaguar is defined based on all the characteristics of class LuxuryCar.
Encapsulation
Polymorphism
Inheritance correct
Composition












Computer Architecture

The teaching standards ask you to know several terms related to advanced computer science topics, and mention Computer Architecture as one of those topics. Below is a general definition of it, followed by two examples of the more common instruction sets found in today's computers.  A general knowledge of this topic, provided by these definitions, is sufficient to meet the requirements of the standard.

Instruction Set Architecture (ISA)
    The part of the computer architecture related to programming, including the native data types, instructions, registers, addressing modes, memory architecture, interrupt and exception handling, and external I/O.
Complex Instruction Set Computing (CISC)
    A micro-processor architecture wherein the machine instruction set is designated as complex.  This style processor was primarily used by the Intel family of processors, including the Pentium family.
Reduced Instruction Set Computing (RISC)
    A micro-processor architecture that has few instructions. This was used by the MacIntosh family of chips, manufactured by Apple Computer.

Comparing Computer Architecture

Computer architecture relates to the way the circuit boards and processors of a computer are designed and defined. The most significant differences occur within the main processor, the CPU.

Instruction Set Architecture	and Description

CISC
	Processor contains numerous instruction sets to enable code efficiency

RISC
	Processor contains fewer instruction sets, limiting itself to those that are frequently used, to enable processor efficiency


OS
It is important that a computer science teacher has a basic knowledge of operating systems in general, regardless of which one he or she uses on a regular basis. Below are several descriptions of some more commonly used OS systems.  Below that is an interactive feature that further explores a timeline of several common OS packages.

Operating System
    An operating system (OS) is software that manages computer hardware and software resources and provides common services for computer programs, like DOS, Windows, UNIX, Linux, and MAC OS.
DOS (Disk Operating System)
    DOS was the first widely-installed operating system for personal computers. It is an acronym for several computer operating systems that are operated by using the command line. MS-DOS dominated the IBM PC compatible market between 1981 and 1995 until Windows came along and emerged as the dominant OS.
Windows OS
    Windows 1.0 was released on November 20, 1985, as the first version of the Microsoft Windows line, the first of many since then, culminating with the current version, Windows 10.
Unix (trademarked as UNIX)
    Unix is a family of multitasking, multiuser computer operating systems that derive from the original AT&T. Unix, developed in the 1970s at the Bell Labs research center by Ken Thompson, Dennis Ritchie, and others. (https://en.wikipedia.org/wiki/Unix)
Linux
    Linux is a UNIX-like computer operating system assembled under the model of free and open-source software development and distribution. The defining component of Linux is the Linux kernel, an operating system kernel first released on 5 October 1991 by Linus Torvalds. Due to the fact that is open source software, many versions of Linux have evolved over the years, including Ubuntu, Gentoo, PacMan, and Red Hat. (https://en.wikipedia.org/wiki/Linux)
Mac OS
    Mac OS is a series of graphical user interface based operating systems developed by Apple Inc. for their Macintosh computer systems, the latest version of which is OS X 10.11, referred to as El Capitan. (https://en.wikipedia.org/wiki/Mac_OS#OS_X)


AI
Artificial Intelligence

The teaching standards ask you to know several terms related to advanced computer science topics, and mention Artificial Intelligence as one of those topics.  Below is a general definition, as well as several examples you might find of AI in your everyday world. It is enough to be aware of the existence of these examples to show your understanding of the impact computer software has on the world around you.

Artificial Intelligence (AI)
    Logic processes performed by computer software packages using extremely sophisticated logic and large database systems.
    Examples include:

                smartphone software that tries to guess the word you are trying to text
                video games
                computers that play chess, or any other games
                computer-aided medical diagnostic software
                self-parking or self-driving smart cars
                online software that tailors shopping lists to your taste based on the history of your searches




Advanced CS Concept Terminology Practice
problem

A field of study which studies how to create computers and computer software that are capable of seemingly intuitive human behavior.
Architecture
Artificial Intelligence correct
ISA - Instruction Set Architecture
RISC - Reduced Instruction Set Computer


problem

An acronym for several computer operating systems that were operated by using the command line, the primary predecessor to the Windows GUI based OS.
UNIX
Linux
Windows
DOS correct


problem

An ISA that simplifies the processor by efficiently implementing only the instructions that are frequently used in programs.
CISC - Complex Instruction Set Computer
Artificial Intelligence
Architecture
RISC - Reduced Instruction Set Computer correct


problem

The part of the computer architecture related to programming, including the native data types, instructions, registers, addressing modes, memory architecture, interrupt and exception handling, and external I/O.
ISA - Instruction Set Architecture correct
Artificial Intelligence
RISC - Reduced Instruction Set Computer
CISC - Complex Instruction Set Computer


problem

An ISA that has many specialized instructions, some of which may only be rarely used in practical programs.
CISC - Complex Instruction Set Computer correct
Artificial Intelligence
Architecture
RISC - Reduced Instruction Set Computer


problem

A set of rules and methods that describe the functionality, organization and implementation of computer systems, often in terms of the type of processor being used.
Architecture correct
Artificial Intelligence
Operating System
UNIX


problem

Software that manages computer hardware and software resources and provides common services for computer programs
Operating System correct
Artificial Intelligence
Architecture
CISC - Complex Instruction Set Computer


problem

A computer operating system assembled under the model of free and open-source software.
UNIX
Linux correct
Windows
DOS


problem

A family of multitasking, multiuser computer operating systems that use a command-line interface.
UNIX correct
Linux
Windows
DOS


problem


An operating system developed by Microsoft that uses a graphical user interface instead of typed command line operations.
Macintosh
Linux
Windows correct
DOS
















Programming Language Concepts
Assembler
    A computer program which translates assembly language to an object file or machine language format.
Assembly Language
    A low-level programming language (difficult for humans, easy for machines) that uses mnemonic opcodes, such as mov, sto, and load, to interact directly with a computer's CPU and registers, used by expert programmers to produce highly efficient and fast programs.
BASIC (Beginner's All-purpose Symbolic Instruction Code)
    A family of general-purpose, high-level programming languages whose design philosophy emphasizes ease of use.
Bytecode
    A universally portable software file compiled from source code that is then translated into machine language by an interpreter. Java works this way, where a .java file is compiled into a .class file, which contains bytecode, and then is translated by whatever device executes that file, using the Java Virtual Machine (JVM) bytecode interpreter.
C
    A general, all-purpose programming language developed by Dennis Ritchie in the late 60s and early 70s at the AT&T Bell Labs, which became one of the most widely used programming languages of all time.
C++
    A programming language also developed at AT&T Bell Labs in the late 70s by Bjarne Stroustrup, derived from C, with added object oriented features.
COBOL
    An acronym for common business-oriented language, a compiled English-like computer programming language designed for business use.
Code
    A term that refers to the source code, or set of instructions found in a computer program.
Code Block
    A code block is a section of code in a computer program which is grouped together. Blocks consist of one or more declarations and statements.
Compiler
    A compiler is a computer program (or set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language, often having a binary form known as object code). The most common reason for converting a source code is to create an executable program.
Compiling
    The process of transforming source code from a high-level programming language into object code, most typically machine language or bytecode in Java.
Executable Code
    The code that is a result of the compile process translated from source code.
Functional Programming Language
    A programming language paradigm that focuses on the function, often math based, where recursion is used for iteration processes. Languages of this type include LISP, Scheme, Haskell, and Scala.
FORTRAN
    One of the original high level languages, short for Formula Translation, created by John Backus to make programming easier for math and science applications.
High Level Language
    A programming language using words and commands easy for humans to understand and organize, but which must be translated into a low-level language like machine language or object code for the computer to understand and execute.
Interpreting
    The translation process in some programming languages which executes a program one line at a time, instead of compiling the entire program into one executable file.
Java
    Java is a general-purpose computer programming language that is concurrent, class-based, object-oriented, and is designed to run on any platform through the use of the Java Virtual Machine (JVM).
Low Level Language
    A language easily understood and executed by a computer, like machine language, assembly, or bytecode.
Machine Language
    A low-level binary language, consisting of only 0s and 1s, easily understood and executed by the computer, most often the result of a translation process from a high level language using a compiler or interpreter.
Object Oriented Programming Language
    A programming language paradigm that focuses on the data, where processes belong to the data and are encapsulated into objects based on class definitions using abstraction, inheritance, and polymorphism as key features of design.
Pascal
    A procedural programming language devised and published by Niklaus Wirth in 1970, primarily intended to teach good structured programming habits.
Procedural Programming Language
    A programming language paradigm that focuses on the procedure, which contains step by step instructions for the computer, primarily using loops for iteration.  Languages that fit this category include Fortran, COBOL, Pascal, and C.
Programming Language
    A programming language is a formal constructed language designed to communicate instructions to a computer.
Python
    From python.com: "Python is an interpreted, object-oriented, high-level programming language with dynamic semantics". Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.
Visual Basic
    An event-driven programming language and integrated development environment (IDE) from Microsoft, first released in 1991, to be relatively easy to learn and used to create GUI based programs.
XML Extensible Markup Language (XML)
    XML is a markup language that defines a set of rules for encoding documents in a format which is both human-readable and machine-readable.

Programming Language Features

There are hundreds and hundreds of programming languages in the world. We discuss a very small subset of languages that matter for our purposes.
Language and their	Features
FORTRAN


    Used primarily in science and engineering
    Developed in the 1950s by John Backus
    Still has active users

COBOL


    Developed specifically for business use
    Developed in the late 1950s and early 60s by a team led by Grace Hopper
    Language has evolved some but is also still in active use

BASIC


    Built to be easier to use
    Has evolved into Microsoft's Visual Basic
    Excellent for beginners

Pascal


    Designed as a teaching language
    Also enjoyed some use in the real world
    Is considered a dying language

C++


    Evolved from the C language
    Added object-oriented features
    Very common language

Java


    Currently the most widely used general purpose language
    Built around the concept of "write once, run anywhere"
    Compiled into bytecode, which is then interpreted by each machine using the JVM (Java Virtual Machine)
    Evolved from C and other languages
    Current language of the AP Computer Science A test

Python


    Popular back-end language of the web
    Also popular as a teaching language
    Emphasizes readability and simplicity
    Invented by a Googler



Notation Systems

Throughout the evolution of programming languages, various efforts have been made to provide structure and readability to the programming process, and below are three examples --Backus Naur Notation, Syntax Diagrams, and Pseudocode -- mentioned in the standards that fit this idea, along with some related terms.
Terms to Know

Backus Naur Notation

    A notation technique for context-free grammars, often used to describe the syntax of languages used in computing, developed and first introduced by John Backus and Peter Naur as a formal notation to describe the syntax of a given language. It is sufficient to recognize examples of BNF

Pseudocode
    An informal high-level description of the operating principle of a computer program or other algorithm. There are many examples of pseudocode similar to the one shown below.  The important thing to remember is that pseudocode is non-executable, meant only as a way to easily and clearly express the purpose of a section of code

Syntax Diagram
    A diagram system, sometimes referred to as a railroad diagram, which is another way to represent a context-free grammar, developed as a graphic alternative to the Backus Naur form mentioned above.

Code
    A term that refers to the source code, or set of instructions found in a computer program.
Code Block
    A code block is a section of code in a computer program which is grouped together. Blocks consist of one or more declarations and statements
Programming Language
    A programming language is a formal constructed language designed to communicate instructions to a computer.
Syntax
    The rules in a scripted language that control punctuation, spelling, and grammar, such as ending a statement with a semicolon, requiring matching braces or parentheses, and so on.



Programming Language Terminology Practice
problem

A general-purpose computer programming language that is class-based and object-oriented, where source code programs are compiled into bytecode files, which are then interpreted by each machine based on its own architecture.
Fortran
Pascal
C++
Java correct
Python
COBOL


problem

A programming language using words and commands easy for humans to understand and organize, but which must be translated into machine language or object code for the computer to understand and execute
Low-level language
High-level language correct
Object-oriented language
Functional language


problem

The language directly understood and executed by a computer, consisting of pure 0s and 1s.
Machine language correct
Assembly language
COBOL language
Pascal language


problem

A widely used general-purpose, high-level programming language, with a design philosophy that emphasizes code readability.
Fortran
Pascal
C++
Java
Python correct
COBOL


problem


Sometimes referred to as railroad diagrams, these are graphical ways to represent a context-free grammar.
Backus-Naur
Syntax diagram correct
High Level
Low Level


problem

One of the original high level languages created by John Backus to make programming easier for math and science applications.
Fortran correct
Pascal
C++
Java
Python
COBOL


problem

A notation technique for context-free grammars, often used to describe the syntax of languages used in computing.
Backus-Naur correct
Syntax diagram
High Level
Low Level


problem


A compiled, English-like computer programming language designed for business use, designed under the leadership of Commodore Grace Hopper.
Fortran
Pascal
C++
Java
Python
COBOL correct


problem

A low-level programming language (difficult for humans, easy for machines) that uses mnemonic opcodes, such as mov, sto, and load, to interact directly with a computer's CPU and registers, used by expert programmers to produce highly efficient and fast programs.
Architecture
Artificial Intelligence
Machine Language
Assembly Language correct
Pseudocode


problem

A language easily understood and executed by a computer, like machine language, assembly, or bytecode.
Backus-Naur
Syntax diagram
High Level
Low Level correct














Data Types

There are three general types of data and several more specific types that are found in most programming languages. The pseudocode data types that will be used in practice examples and on the certification test are listed in bold.

Numbers
Real Numbers/Decimals

Ex: 1.2, 4.35, -3.09, -2.00

float

double

Text
Characters (letters, digits, symbols, spaces, contained within single quotes)

Ex: 'a', '4', '!'

char

True/False
Boolean

Ex: true, false

boolean

Integers (Positive and Negative Whole Numbers)

Ex: 4, 54, 0, -39, 92, -78

int

short


Strings (rows of characters, contained within double quotes)

Ex: "45", "Hello World",  "Howdy!"

String


Terms to Know

Descriptions of the standard data types for any programming language are listed below. It is important to know the nature of each one.

Integer (int or short)
    A negative or non-negative whole number.
Floating-point number (float or double)
    A real number that includes a fractional part, like 3.14, 4.0, or -0.5.
Character (char)
    A single symbol, letter, digit, or whitespace contained within a pair of single quotes like 'A', 'b', '5', '#', or '  '.
String (String)
    A row of characters combined together to make a word, sentence, or other text based values, contained within a pair of double quotes, like "Rise to vote sir!", "$123.56", or "George Washington".
Boolean (boolean or bool)
    True or False. This data type is named after George Boole, a 19th century English mathematician, who helped develop and formalize Boolean Algebra as a new branch of mathematics.

Data Types - Storage and Limits

Beyond knowing what type of data can be stored in a program, it is important to know how much room is needed to store different types of data, as well as any limitations or restrictions are involved. Below is a detailed discussion of some of these limits.  A comprehensive lesson on all issues discussed below as they relate specifically to the Java language can be found at http://oncslessons.net//Lessons_2015/O(N)CS_LESSON_2A_DataTypesAndVariables.pdf

INTEGER DATA TYPES

In Java there is a whole family of data types that can contain integers.  They include int, short, long, and byte.

The byte data type uses 8 bits of storage, and can contain values ranging from -128 to 127. (Note that a bit is used to designate a single state of a computer value or signal, often notated as 0 or 1, false or true, off or on, etc.)

The short data type uses 16 bits of storage, and ranges in value from -32768 to 32767.

The int data type uses 32 bits of storage, and ranges in value from -2147483648 to 2147483647.

The long data type uses 64 bits of storage, and ranges in value from -9223372036854775808 to 9223372036854775807.

The char data type stores characters, but can be considered a "cousin" of the integer value, in that it actually stores integer values that represent characters. It uses 16 bits of storage and contains only non-negative values in the range 0-65535. The three most significant values that students should know are the values 65, 97, and 48.  The uppercase letter 'A' is represented by 65, 'a' by 97, and the digit '0' is actually the value 48.  These values are all determined by the ASCII system, and extended into the UniCode system.

WRAPAROUND ISSUES

There is a phenomenon that occurs when using integer data types called wraparound.  This occurs when a integer type variable contains the maximum or minimum value, and then attempts to step one value beyond the limit.  For example, if a byte variable called num contains the maximum value of 127 (see above), and the statement num <- num + 1 is attempted, the new value in the variable is NOT 128, but rather -128.  It wraps around to the other end of the range.  Likewise, if num contained -128, and the statement num <- num - 1 is attempted, the new value will NOT be -129, but instead 127.

Here is a sample code snippet that shows this more clearly. Examine it carefully until you understand what is going on.
byte num  ← 127
print (num)                                                         Output: 127
num  ← num + 1
print (num)                                                         Output: -128
num  ← -128
print (num)                                                         Output: -128
num  ← num - 1
print (num)                                                         Output: 127

The same thing happens for all integer data types...short, int, and long.

FLOATING POINT DATA TYPES
The float data type uses 32 bits of storage, and stores floating point values. The limits for the float data type are best expressed in scientific notation, and range from 1.41 X 10 ^ -45 to 3.4 X 10 ^ 38.
The double data type uses 64 bits of storage, also storing floating point values. The limits for the double data type are best expressed in scientific notation, and range from 4.90 X 10 ^ -324 to 1.8 X 10 ^ 308.
A more significant limitation issue with these two data types deals with their storage precision capabilities.
The float data types begins to lose precision beyond 7 places after the decimal point.
The double data types begins to lose precision beyond 15 places after the decimal point.
Here is code example that illustrates this issue. A value of PI, precise to 25 places, is assigned to both a float and a double variable. Look closely to see how the output for the float variable begins to deteriorate in precision after 7 places, and likewise after 15 places for the double variable.
float fpi ← 3.1415926535897932384626433
print (fpi)                Output: 3.1415927410125732000000000
double dpi ← 3.1415926535897932384626433
print (dpi)                Output: 3.1415926535897930000000000


Data Types Practice
problem


Identify the data type for this value:
"" (no space between quotes)
boolean
char
float
int
string correct


problem


Identify the data type for this value:
-999.99
boolean
char
float correct
int
string


problem


Identify the data type for this value:
-45
boolean
char
float
int correct
string


problem


Identify the data type for this value:
45
boolean
char
float
int correct
string


problem


Identify the data type for this value:
" " (single blank space)
boolean
char
float
int
string correct


problem


Identify the data type for this value:
0 (the value zero)
boolean
char
float
int correct
string


problem


Identify the data type for this value:
3.14
boolean
char
float correct
int
string


problem


Identify the data type for this value:
0.0
boolean
char
float correct
int
string


problem


Identify the data type for this value:
's'
boolean
char correct
float
int
string


problem


Identify the data type for this value:
' ' (single blank space)
boolean
char correct
float
int
string




Variables: Rules and Conventions

A variable in programming is a location in memory containing a value of some type.  It can be changed during program execution, as opposed to a constant, also a memory location containing a value, but which once assigned, cannot be changed.

A variable or constant is first declared, which is simply a request to the system to allocate memory, and then instantiated or assigned a value.  For example, int x ← 5 is an example of declaring an integer variable, and immediately assigning to it a value. A declaration starts with the type of data it is to contain, followed by an identifier (created name) that will serve as an access label.

Note: In the pseudocode examples for this course and for the test, the  ← symbol represents the assignment operator, which places, or "assigns", the value or expression to the right of it into the memory location designated to the left of it.  In some languages, like Java, C++, and Python, the = sign is used as the assignment operator.

Here are some other examples:

string name ← "Joe" ("Joe" is assigned to the memory location name)

float priceOfItem ← 9.95          (9.95 is assigned to priceOfItem)

boolean flag ← true

char init ← 'B'

There are rules about creating names for variables, constants, method names, class names, or anything created to represent an aspect of a program.  In general, these names are referred to as identifiers.

The rules for creating valid identifiers are fairly common among all programming languages, and generally include the following guidelines:

        Must contain only alphanumeric characters (A...Z, a...z, 0...9 ), and/or the underscore character (_)
        Must begin with an alpha character (A...Z, a...z) or the underscore character.
        May not contain any symbols other than the underscore character.
        May not contain any spaces.
        May not be a reserved word from the programming language.

Here are some examples of valid identifiers:

        name
        age
        num1
        wagePerHour
        _DateOfBirth
        PI
        STARTING_DATE

Here are some examples of INVALID identifiers, with the reason each is invalid shown in parentheses:

        1num (starts with a number)
        first name (contains a space)
        wage$per-Hour (contains invalid symbols)
        int (reserved word)

There are also conventions, or "agreements" about how to create identifiers, that are not crucial to the compiler, but are helpful to the humans reading the code. Some software development firms insist that certain conventions be followed so that software development and modification efforts are streamlined, saving time and money.

    For example, some identifiers, by convention, start with an upper case letter, such as class names in some object oriented languages.
    Another convention is for procedures, functions and methods to start with a lower case letter.
    For multiple word identifiers that cannot contain spaces by rule, a process called Camel Case is used, where the initial letter of each word is capitalized to help better see the multi-word identifier.
    Constants, by convention, are completely uppercased, and are easily recognized as such when someone is reading through the code.  For multi-word constants, and underscore is used for separation instead of using Camel Case style.

Finally, it is a good idea to create identifier names and phrases that are meaningful to their purpose, which serves as internal documentation within the code itself, helping the code reader to better understand the purpose of the code.  For example, firstName is immediately recognizable as an identifier intended to contain someone's first name.

Another good idea is to abbreviate, to a certain extent, identifiers which tend to get too long. This avoids the cumbersome task of having to type those long identifiers during coding. However, too much abbreviation, especially the use of one or two character identifiers, should be avoided for any identifiers with significant meaning, and restricted to variables used for utility purposes, such as loop control or array indexing.

The Assignment Operator

The ← symbol is the assignment operator that will be used in all pseudocode examples for this course. It assigns the value on the right to the value on the left.

For example:

    int x ← 5
    string name ← “Joe”

In some languages, including C++, Java, and Python, the = sign is used as the assignment operator.

Right to Left

It is very important to understand that an assignment statement is a right to left operation. This simply means that the right side of an assignment statement is always taken care of first by the compiler.

Use the interactive below to explore the parts of an assignment statement.

An assignment operation is NEVER a left to right action: 7 + 9 = num3 is NOT allowed!! The memory location must be listed on the left of the assignment operator, and the value or expression to be assigned located on the right.

If this assignment reversal is detected, the compiler will throw a “fit” and report an error statement!

The left side of an assignment statement must ALWAYS be a variable or constant.

Try It icon
Try It

Use the demo below to try out the assignment operator.

Learn Icon
Want to Learn More?

There are several important distinctions that you will want to keep in mind regarding the assignment operator.
Equals Everywhere!

There are several operators that contain an equal sign, but remember that they do very different things. Use this table to compare them.
Operator	Usage
←, = 	Used to assign values to variables and constants
== 	Used to check for equality between two expressions
!= 	Used to check if two expressions are NOT equal to each other

== vs =

The most common mistake among novice programmers is to use the = to check for equality. In some languages (Java, for instance), the compiler will catch this for you and not allow it (it will throw an error), but in others it won't (C and C++).
There are other Assignment Operators

In some languages you can also perform an arithmetic operation at the same time that you assign a value to a variable, referred to as a shortcut operator.
Operator	Usage	Examples
+= 	Add (or concatenate) the new value to the previous value and then assign that to the variable 	int x = 5, x += 5 x is now 10
-= 	Subtract the new value from the previous value and assign that to the variable 	int x = 5, x -= 3 x is now 2
*= 	Multiply the new value by the previous value and assign that to the variable 	int x = 5, x *= 4 x is now 20
/= 	Divide the previous value by the new value and assign that to the variable (Note: this is integer division where the fractional part is truncated) int x = 5, x /= 2 x is now 2



Variable Identifier Practice
problem


Choose the statement that best classifies the identifier creation guideline shown.
Class names start with an upper case letter
Convention correct
Good idea
Rule


problem


Choose the statement that best classifies the identifier creation guideline shown.
Method names start with a lower case letter
Convention correct
Good idea
Rule


problem


Choose the statement below that best classifies the following identifier example.
floated
Valid correct
Invalid - does not start with a letter or underscore
Invalid - contains invalid symbols
Invalid identifier - contains spaces
Invalid identifier - programming language reserved word


problem


Choose the statement below that best classifies the following identifier example.
float
Valid
Invalid - does not start with a letter or underscore
Invalid - contains invalid symbols
Invalid identifier - contains spaces
Invalid identifier - programming language reserved word correct


problem


Choose the statement below that best classifies the following identifier example.
him and her
Valid
Invalid - does not start with a letter or underscore
Invalid - contains invalid symbols
Invalid identifier - contains spaces correct
Invalid identifier - programming language reserved word


problem


Choose the statement that best classifies the identifier creation guideline shown.
Identifiers should be meaningful
Convention
Good idea correct
Rule


problem


Choose the statement below that best classifies the following identifier example.
4Gone
Valid
Invalid - does not start with a letter or underscore correct
Invalid - contains invalid symbols
Invalid identifier - contains spaces
Invalid identifier - programming language reserved word


problem


Choose the statement that best classifies the identifier creation guideline shown.
No spaces or invalid symbols.
Convention
Good idea
Rule correct


problem


Choose the statement that best classifies the identifier creation guideline shown.
Variable names should be abbreviated
Convention
Good idea correct
Rule


problem


Choose the statement that best classifies the identifier creation guideline shown.
Variables start with a letter or the underscore character
Convention
Good idea
Rule correct




Primitives vs. Objects

So far in this section, we've talked about various data types. These data types can be split into two larger categories, primitives and objects.
Primitives

A primitive value or variable is basic in form; raw, if you will.  Data types such as the integer, character, floating point number, and boolean value all are considered to be primitives. This is because they occupy memory that is consistently the same size. For example, an integer value in Java always occupies 32 bits of memory, a double 64 bits, and a character 16 bits.  All three are primitives.  All primitives are stored and accessed directly in their memory.  The memory address of a variable that stores a primitive actually contains that primitive value. It is contained right there at that address in RAM.

For the scope of this course, the primitive data types used are: boolean, char, double, float, int and short.
Objects

Objects are not as consistent in how much memory they occupy, and because of that, the object itself cannot be stored or accessed directly, as a primitive can.  For example, a String variable could contain a single word, containing four characters, or a whole sentence with fifty characters, or be completely empty!  A more complex object could be defined in a class, and might be composed of several instance variables, methods, or even other objects!  As a result, objects instead are accessed by reference through the use of pointers. The memory address of a variable that indicates an object does not itself contain the object, but instead contains the memory address of that object. It is a pointer that says to the program, “it’s over there if you want to use it”.

Object variables that use references, or pointers, include Strings, one dimensional and two dimensional arrays.
Using Primitives vs Objects

Fortunately, there is no apparent difference, at the surface level at least, in how to use either of these two types of variables in a program.  You simply state the variable in a command or expression, and the compiler takes care of how to access them.

For example:

int x ← 10

boolean flag  ← false

String name ← “John”

int [] list ← {1,2,3}

print x

print flag

print name

print list[2]

However, at deeper levels of complexity, as in passing parameters, or in defining more complex abstract data structures, such as linked lists, binary trees, these differences will come into play, and the difference between how to use them is important to know.


Number base look at notebook

Number Base Counting Practice


For all text entry answers, simply enter the number or use a comma and a space between multiple value answers, like this: 1 or 1, 2, 3.
What is the next value in this base 8 sequence? 5, 6, 7
10
correct


What is the next value in this base 16 sequence? 7, 8, 9
A
correct

What is the next value in this base 2 sequence? 1000, 1001, 1010
1011
correct


What are the next three values in this base 10 sequence? 16, 17, 18
19, 20, 21
correct



Number Base Conversion Practice

For all answers below, simply enter your solution in the text box like this: 4D or 12.
What is the base 8 value equivalent to 76 base 10? 114


What is the base 10 value equivalent to 76 base 8? 62


What is the base 8 value equivalent to 90F base 16? 4417


What is the base 2 value equivalent to 704 base 8? 111000100


What is the base 16 value equivalent to 456 base 8? 12E


What is the base 2 value equivalent to 39 base 10? 100111


What is the base 2 value equivalent to F4 base 16? 11110100


What is the base 10 value equivalent to A25 base 16? 2597


What is the base 10 value equivalent to 1110011 base 2? 115


What is the base 16 value equivalent to 92 base 10? 5C


What is the base 8 value equivalent to 110011 base 2? 63


What is the base 16 value equivalent to 101011011 base 2? 15B










Extra Software Design Practice
problem

The stage in the software system life cycle that takes the most amount of time.
Analysis
Design
Implementation (Coding)
Testing
Maintenance correct


problem

A concept that indicates how various processes within an entity may be duplicated, accomplishing the same thing, but in different ways, or at different levels.
Encapsulation
OOP
Abstraction
Polymorphism correct
Composition
Inheritance


problem

The stage in the software system life cycle that checks the program for reliability, validity, and effectiveness.
Analysis
Design
Implementation (Coding)
Testing correct
Maintenance


problem

A concept that indicates how data and methods that act on the data are all incorporated into a single entity.
Encapsulation correct
OOP
Abstraction
Polymorphism
Composition
Inheritance


problem

The concept in programming where certain features of an object can take many forms.
Abstraction
Polymorphism correct
Encapsulation
Inheritance


problem

The general approach of having a goal in mind and then dividing the goal into sub-goals and tasks, sometimes also referred to as step-wise refinement.
Top down correct
Bottom up
UML
Flowchart


problem


Using the flowchart shown below, what will be the result if the score is 183, and the next decision is "Yes"?
flowchart describing a simple program
PASS
Take Exam correct
FAIL


problem

The term describing programs that are virtually unbreakable and able to handle any and all situations.
Strong
Robust correct
Agile
Abstracted


problem

A programming paradigm that uses objects and classes.
Encapsulation
OOP correct
Abstraction
Polymorphism
Composition
Inheritance


problem

The concept in programming where an object is made up of other objects.
Encapsulation
Abstraction
Inheritance
Composition correct


problem

The concept in programming where a feature is used without knowledge of the inner workings of it.
Abstraction correct
Encapsulation
Polymorphism
Composition


problem

The stage in the software system life cycle that determines the overall needs of the project.
Analysis correct
Design
Implementation (Coding)
Testing
Maintenance


problem

Project design strategy of using interacting objects.
Bottom-Up
Top-Down/Step-Wise
Object Oriented correct
Cyclical


problem


The concept where all of the characteristics and processes of a feature are included within that feature's definition.
Encapsulation correct
Abstraction
Inheritance
Composition


problem

The concept where an object uses characteristics of another object, and then expands on them.
Genetics
Encapsulation
Abstraction
Inheritance correct


problem

A diagram that uses geometric shapes connected by arrows to indicate the step-by-step process of a project.
Top down
Bottom up
Stepwise refinement
UML
Flowchart correct


problem

The most appropriate way to use a library of program code is to access the:
methods or functions by way of the interface. correct
implementation details of the methods or functions.
methods or functions by way of the source code.
documentation of the methods or functions.


problem

A concept that indicates how an entity contains processes that work, but how they function internally is hidden from the user of that entity.
Encapsulation
OOP
Abstraction correct
Polymorphism
Composition
Inheritance


problem


Which of the following best describes the purpose of generating a unified modeling language diagram as part of the design of a computer program?
To test and maintain the efficiency of the overall program
To present the steps needed to solve the programming problem
To describe the classes and methods to be used in a program correct
To determine the necessary number of global and local variables





Extra Software Development Practice
problem

The idea that a program is so well designed, implemented, refined, and tested, that it can handle any data or processing situation without fail.
Object oriented
Robust correct
Procedural
Cyclical


problem

This element in some programming languages by convention contains all capital letters.
Constant correct
Class
Method
Precondition
Postcondition


problem


A formal comment block that describes what type of input a process expects to receive.
Constant
Class
Method
Precondition correct
Postcondition


problem


A formal comment block that describes what type of result a process expects to provide.
Try-catch Block
Style Conventions
Precondition
Postcondition correct


problem

This module in some programming languages typically starts with a lowercase letter.
Constant
Class
Method correct
Precondition
Postcondition


problem


The idea that the program development process within the software system life cycle can take several iterations, and is rarely just a "straight down the hill" process from start to finish.
Object oriented
Robust
Procedural
Cyclical correct






Extra Programming Terminology Practice
problem

Small, fast memory on a motherboard which works directly with the CPU
Bit
Data
Cache correct
Stack


problem

The process of encoding messages or information in such a way that only authorized parties can read it.
Encryption correct
Abstraction
Linking
Parsing








Extra Object-Oriented Concept Practice
problem

An object of class A contains instances of previously defined classes B and C.
Encapsulation
Polymorphism
Inheritance
Abstraction
Composition correct


problem

Which object-oriented programming concept is described by the following: Class M owns a data item defined by class N.
Encapsulation
Abstraction
Inheritance
Composition correct


problem

Class D contains several instances of data, and owns methods that work with that data.
Encapsulation correct
Polymorphism
Inheritance
Abstraction
Composition

Correct
problem

One of the three primary aspects of object oriented programming that incorporates related data items and methods into a class definition, including instance variables, constructors, accessor and modifer methods.
Encapsulation correct
Integrity
Classes
Polymorphism


problem


The relationship between one entity and another where entity A "is a" type of entity B.
Encapsulation
OOP
Abstraction
Polymorphism
Composition
Inheritance correct

Correct
problem

An object of class A is a descendant of class B.
Encapsulation
Polymorphism
Inheritance correct
Abstraction
Composition


problem

In object-oriented programming, a term that is also referred to as information hiding, associated with encapsulation, where a programmer hides all but the relevant data and processes about an object in order to reduce complexity and increase efficiency
Encapsulation
Abstraction correct
Inheritance
Polymorphism


problem

A parent class X has child classes Y and Z, and can reference objects of either class.
Encapsulation
Polymorphism - overloading
Inheritance
Abstraction
Composition
Polymorphism - overriding
Polymorphism - polymorphic object correct

Correct
problem

The definition of an object in OOP, describing the type of data owned by the object, as well as methods that act on that data.
function
class correct
object
method
procedure

Correct
problem

A concept within the design of an entity where it is receives all of the characteristics and processes of a previously defined entity, and then possibly adds more of its own, or modifies the ones received.
Encapsulation
OOP
Abstraction
Polymorphism
Composition
Inheritance correct

Correct
problem

Which object-oriented programming concept is described by the following: The parent class of O is class P.
Encapsulation
Abstraction
Inheritance correct
Polymorphism


problem


Which object-oriented programming concept is described by the following? Certain aspects of a class definition are hidden from the user.
Encapsulation
Abstraction correct
Inheritance
Composition


problem


The relationship between one entity and another where entity A "has a" type of entity B as one of its characteristics.
Encapsulation
OOP
Abstraction
Polymorphism
Composition correct
Inheritance

Correct
problem

A concept within the design of an entity where it is partially made up of other, predefined entities.
Encapsulation
OOP
Abstraction
Polymorphism
Composition correct
Inheritance

Correct
problem

A certain method of class A, which is a descendant of class B, is redefined in a more special way.
Encapsulation
Polymorphism correct
Inheritance
Abstraction
Composition


problem

A key element of object-oriented programming, where methods can be overloaded or overridden as needed and desired.
Encapsulation
Abstraction
Inheritance
Polymorphism correct


problem

A programming entity that encapsulates data and related methods into one package.
function
class
object correct
method
procedure

















Programming Fundamentals
Sequential Processing

Sequential Processing is one of three kinds of control structures we'll cover in the course. A control structure is a block of programming that chooses which way to go, given certain parameters. Understanding different control structures, and the building blocks that make them, are essential parts of understanding computer science.

After you're introduced to the concept of control structures, we'll also discuss the different types of errors you may encounter.
Operators

Operators are the basic building blocks of programming statements. You'll use operators to do everything from assigning values, calculating math, creating strings, and more.

We'll introduce you to the various kinds of operators and get in some practice with predicting the output of a programming statement that uses those operators.
Methods and Parameters

Methods are the building blocks of a fully functioning program. These blocks of code allow us to encapsulate various processes so that they are reusable and can be used from anywhere in the program.

We'll cover the types and parts of a method and delve into important concepts concerning parameters, the aspect of a method that defines the information the method receives and processes.

Conditional Processing

Conditional processing is the second type of control structure and it builds off of the sequential process. Sometimes you might want your program to do one thing OR another, based on some condition. Conditional processing lets you build this in to your program.

We'll discuss the tools of conditional programming, including if statements, if/else statements, and switch case statements.




What is Sequential Processing?

In sequential processing, program statements execute in order, one after another.

Put another way, in sequential processing, the next step can't begin until the previous step has completed.

CODE

void sequence()
  int x ← 5
  string name ← "Joe"
  Print name
  x ← x + 10
  name ← "Sally"
  Print name + x
end sequence

Console

Joe
Sally15



Debugging Strategies
Bug/Error
    A bug is an error, flaw, failure, or fault in a computer program or system that causes it to produce an unexpected result.  This can be a program situation that indicates a flaw in the source code, either syntax-based (punctuation or grammar), run-time (occurs during execution, such as file not found, or division by zero), or logic based where the program runs but does not produce the desired results.
Lexical Error
    An error in programming that is characterized by the misspelling of a word, capitalization errors, or reserved words listed out of order.
Syntax Errors
    An error associated with punctuation, indentation, or mismanagement of braces and parentheses in a computer program.
Run-time Errors
    An error that occurs during the execution of a program, such as missing files or faulty input.
Logic Error
    An error that causes the program to run not rightly, but does not prevent the program from running.

The Four Types of Errors

Bugs happen. No matter how careful you are and no matter how experienced you are as a programmer, sooner or later you will make a mistake in your code.

They can affect your program in various ways, but, generally, when a mistake occurs, the program throws (or shows to you somehow through an error message) what's called an error or an exception. For many kinds of errors, the IDE you use (the Integrated Development Environment) will give you much of the information you need to fix it.

The four types of errors come in two basic flavors:

    Errors that occur during compile-time
    Errors that occur during run-time

Let's take each of these, in turn.
Compile-time Errors

For many programming languages, including C++, Java, and Python, the first step producing any program is to compile it. This process translates the code that you wrote in a high-level (human-readable) language into a lower-level (machine readable) language. As can happen in any translation, sometimes mistakes happen.

The two types of errors that happen at compile-time are:

    Lexical errors
    Syntax errors

Lexical Errors

Lexical errors happen when an essential command is mistyped or commands are put in the wrong order. To fix this type of error, you would simply retype or reorder the commands that were wrong.

Here is an interesting example of a lexical error:

Go reach about, then your mile exit take the right a destination to.

The words, spelling and punctuation are all correct, but the order of the words makes for a very confusing sentence.

The right order makes for a much better sentence.

Go about a mile, then take the right exit to reach your destination.
Syntax Errors

A syntax error happens when you don't follow the punctuation or indentation rules that the programming language you are using requires. Another instance of a syntax error is when an open or closed brace, bracket, or parentheses is missing its partner, an important feature for some languages that helps manage blocks of code.

All programming languages have some kind of syntax, their own rules of punctuation. If you violate these, even by accident, the language doesn't understand what you're trying to do, and will not compile.

Take this example in a sentence in English:

    I like cooking my family and pets.

Seem strange? Psychotic? Well that's because, when it's written this way, you can't understand what the writer is trying to tell you.

Change it to:

    I like cooking, my family, and pets.

and you have an everyday, humdrum (but easy to understand sentence).

Syntax errors in a programming language are like not having the commas in the right place in this sentence. It's hard to understand what you mean.
Run-Time Errors

A run-time error happens when it encounters an event that causes the program to crash, like a faulty input value (entering a string when a number is expected), or when a file the program attempts to access is not there. There are ways in many programming languages to handle these possible events, and the better the program is designed to handle these possible situations, the more "robust" it is, and the less likely it is to crash. For example, in Java, the try catch block is an excellent way to "handle exceptions" that may occur during the execution of a program.

Logic Errors

Logic errors happen when a program runs fine, but doesn’t do the right thing. For example, say you wrote some code that is meant to print out all of the letters of the alphabet but it only gets from A to N. This clearly a logic error.

What if the program is supposed to calculate a paycheck, but forgets to include the time-and-a-half feature for hours over 40 in a week? This is a logic error.  The program doesn't crash, but just calculates the wrong value.

Quite often, much of the debugging process is spent chasing down logic errors, and quite often, these are the most difficult to find, and sometimes to fix.

A good way to prevent logic errors is to have a well thought out plan and design in mind BEFORE trying to code a solution.
Lexical Error Image Interactive

Click on the Prev and Next buttons below to cycle through different examples of Lexical Errors.

    Lexical Error 1: Class Name Misspelled
    Lexical Error #1

    Class name misspelled. In Java, the class name declared must match the file name.

    Lexical Error #2

The keywords void and static were reversed when this method was built. Note the error message that is thrown: invalid method declaration; return type required. All error messages may not be completely obvious.


    Lexical Error #3

Some special words, such as String and System, must be capitalized in order to be recognized appropriately in Java. Note that the error messages ("cannot find symbol class string" and "package system does not exist") are different, even though both are the result of the same kind of mistake.


prev next

Syntax Error Image Interactive

Click on the Prev and Next buttons below to cycle through different examples of Syntax Errors.

    A semicolon is missing at the end of a command statement
    Syntax Error #1

    In Java (and many other languages) certain types of lines or statements in a program have to end with certain punctuation. In this case, the command line must end with a semicolon. Note that the error message in this case lets you know what is missing and points to the line where it belongs.

    Syntax Error #2

    A common thing to leave off is the closing mate to an opening bracket or parenthesis. In this case, the closing bracket for the interior pair of brackets is missing. Note how the error message in this case ("reached end of file while parsing") is not obvious.






Debugging and Error Practice
problem

Arranging commands in a programming statement not in the required order is a ______________ error.
Syntax
Runtime
Lexical correct
Logic


problem

In some languages, forgetting to end a statement with a semicolon is a ______________ error.
Runtime
Logic
Lexical
Syntax correct


problem

Errors that occur during the execution of a program happen in ___________ _________.
Compile time
Run time correct


problem

Lexical errors occur during ___________ _________.
Run time
Compile time correct


problem

Syntax errors occur during ___________ _________.
Compile time correct
Run time


problem


Leaving out a required closing brace, bracket, or parentheses is a ______________ error.
Runtime
Syntax correct
Lexical
Logic


problem

Misspelling a reserved word in a programming statement is a ______________ error.
Lexical correct
Syntax
Logic
Runtime


problem


What type of error will this cause?
String name = "Joe
Compile Error
Logic Error
Syntax Error correct
Run-time Error


problem

Logic errors occur during ___________ _________.
Compile time
Run time correct


problem


The Java code segment below has been saved in a file called "JollyMessage.java". What type of error, if any, will occur?

    public class Jollymessage  {
    	public static void main(String[] args) {
    		System.out.println("Ho Ho Ho!");
    	}
    }
Lexical Error correct
Logic Error
Syntax Error
Run-time Error
No error will occur







Operators Used in Programming
Unary Operator
    A type of operator that modifies one operand.
Integer Division
    A division process that results in a whole number answer, discarding or truncating any fractional remainder.
Integer Modulus
    A division process that results in a whole number answer representing the remainder of the division process, discarding the actual answer. Indicated by the % sign.
Concatenation
    The process of joining two strings of characters into a larger string of characters, an operation indicated by the plus (+) sign.
Relational Operators
    Binary operators that compare two operands, resulting in a true or false value.
Logical Operators
    Binary operators that compare the results of two boolean expressions. The result is either true or false.
Shortcut Operators
    Two commonly used shortcut unary operators are ++ and --,and are used before or after a variable.  For example, X++, ++X, X--, and --X are the four ways to use these operators. X++ is equivalent to the expression X ← X + 1, as is ++X. X-- and --X are both equivalent to the expression X ← X - 1. All of these shortcut operators are quicker to code, easier to recognize than the traditional, longer expression, and are quite often used in loops that only require step sizes of 1.

Arithmetic Operators

Arithmetic operators help you to perform basic mathematical operations.

Arithmetic operators are examples of binary operators, meaning that they need two input elements to work.

Operator	Description	Notes
* 	Multiplication
/ 	Division
% 	Modulus, finds the remainder 	The result of 5 % 2 is the value 1
+ 	Addition (also works for String concatenation)
- 	Subtraction

Notice that the + operator works for numerical addition AND string concatenation (combining two or more strings into one). This makes the + operator an overloaded operator, an operator that can perform more than one function.
Relational Operators

Relational operators compare two values to each other. When using these operators, the result will either be true or false.
Operator	Description
< 	Less than
> 	Greater than
<= 	Less than or equal to
>= 	Greater than or equal to
== 	Equal to
!=, <>, ≠ 	NOT equal to

Logical Operators

Logical operators allow a program to make a decision based on multiple conditions. Each operand is considered a condition that can be evaluated to a true or false value.
Operator	Description
&&, AND 	true AND true is true.  Any AND combination involving false is false.
||, OR 	false OR false is false. Any OR combination involving true is true.
^, XOR

XOR with opposite values is true. XOR with same values is false.
!, NOT 	NOT. This reverses the state of the operand. NOT false is true. NOT true is false.

Operations with Different Data Types

Previously, you covered the various kinds of data types ( integers, doubles, characters, strings, and boolean). As we mentioned, some operators (like the + operator) perform different functions, depending on the data type. With that in mind, you need to be aware of a couple of things:

    String concatenation: When used with strings and characters, the + operator doesn't try to add them like numbers; instead it concatenates them ("connects", or "joins" them into one string).

    Example: "Hello" + "World" becomes "HelloWorld"

    "Hello" + " " + "World" becomes "Hello World"
    Operating with integers vs. Operating with decimals:
        In general, when you perform an operation when either operand is a floating point number (commonly known as a decimal value), then the result will be a floating point number, even if it is a decimal such as 30.0.

Internally, a floating point value is stored to the maximum precision allowed by the particular data type. The only time precision or place value is an issue is when displaying the value. The certification test will most likely NOT ask you to answer any questions that relate to precision of floating point numbers.

Examples

10.0/4 result: 2.5

10/4.0 result: 2.5

10.0/4.0 result: 2.5

    When two  integers are divided, the result is truncated to be an integer, where any fractional part (remainder) of an answer is discarded without rounding up or down.

Ex: 10/4 result: 2
Operator Precedence in JAVA

This table shows a more complex list of operators specific to the language Java. This goes beyond what the pseudocode list covers, but is important to be aware of if you proceed on into that Java language.

The table shown in the video represents the extent to which you will see operators in the pseudocode.

Just as you learned in math, there is an order of operations in programming. Some operations are evaluated before others.

In general, it is helpful to remember that the order of operations, PEMDAS, still applies, followed by relational and then logical operators. Assignments happen last.

Use the table below to review the Java order of operations in more detail. The bolded operators are the only ones you need to know for the certification test.
Precedence	Java Operators
1. Postfix 	epr++ ,  expr--
2. Prefix and Unary

++expr , --expr , +expr , -expr , ~ , !,

+(positive), -(negative)
3. Multiplicative 	*,  / ,  %
4. Additive 	+ -
5. Shift 	<< , >> , >>>
6. Relational 	< , > , <= , >= , instanceof
7. Equality 	==, !=
8. Bitwise AND 	&
9. Bitwise XOR 	^
10. Bitwise OR 	|
11. Logical AND 	&&
12. Logical OR 	||
13. Ternary 	?, :
14. Assignment 	= , += , -= , *= , %= , &= , ^= , |= , <<= , >>= , >>>=



Operator Practice

Now it's time to practice with operators. Figure out the result of the variable after the operation has been completed.
problem


What is output by the pseudocode segment shown?
int x ← 10
int y ← 10
print x < y
false correct
true


problem


What is output by the pseudocode segment shown?
boolean p ← true
boolean q ← true
print NOT p XOR q
false
true correct


problem


Which combination below will make this expression false?
p XOR q
boolean p ← true, boolean q ← true
boolean p ← true, boolean q ← false
boolean p ← false, boolean q ← false
boolean p ← false, boolean q ← true
More than one of these correct


problem


What is the value of the variable after this operation?
string x ← "Fizz"
  x ← x + "Buzz"

Error
"FizzBuzz" correct
"Fizz + Buzz"
"Fizz Buzz"


problem


Consider the following pseudocode segment with integer variables, where the initial variable assignments at the beginning of the segment are missing.
// missing precondition
x ← x + 1
y ← y + x
// postcondition:
// y == 2 * x
Which of the following would be a valid precondition for the code segment above?
y == x - 1
y == x
y == x + 1 correct
y == x + 2


problem


Which combination below will make this expression false?
p OR q
boolean p ← true, boolean q ← false
boolean p ← true, boolean q ← true
More than one of these
boolean p ← false, boolean q ← true
boolean p ← false, boolean q ← false correct


problem


What is the result after this operation?
8 % 5

3 correct
1
2
1.6


problem


What is the value of the variable after this operation?
int x ← 5
  x ← x + 5

10 correct
"5+5"
5
15


problem


What is output by the pseudocode segment shown?
boolean p ← true
boolean q ← true
print p OR q
false
true correct


problem


Which symbol below will rightly fill the blank to make the output false?
int num1 ← 45
int num2 ← 45
println num1 ___ num2

I. <   II.   >   III.   ≤   IV.   ≥   V.   ==   VI.   ≠
III, IV, V
II, IV, VI
V
II, VI
I, II, VI correct






Procedures, Functions, Methods
Procedure
    A programming module that performs a task of some sort, like outputting the contents of a data structure, or performing a sort on an array.
Function
    A function in programming is most often a procedure or method that performs a calculation and returns a value of some sort.
Method
    A process in Java that can be either a procedure (void method) that performs an action , or a function (return method) that returns a calculated value.

What is a Method?

So far you've seen some basic building blocks of programming: data types, several operators, and the idea of sequential control in a program. These can all be used to build a block of code that performs a useful task. In some languages, including Java, these larger blocks of code are called methods.

A method is simply a process that includes a collection of data processing commands that you create in a program.
Two Words, One Family

While all methods perform a useful task, there are two ways that they can go about performing a task.

Some methods do stuff, often receiving data (as input parameters) and acting on that data, like outputting a list of names or numbers. These types of methods are called procedures (or void methods, in Java).

Other methods receive data and return (send back) a calculated value based on that data, like calculating and returning the average of a list of values. These types of methods are called functions (or return methods, in Java).
Example

In pseudocode, a void method (procedure) might look like this:
procedure showList ( int [] list )
for(int x ← 0 ; x<list.length; x ← x + 1)
print list[x]
end procedure

This procedure receives an array of integers as a parameter, and then outputs the contents of the array.

You could see the method above also written like this.  Notice the only difference is in the heading and the closing line.  The process is still the same.  This is just a different style of writing the same block of code. Different languages do this in slightly different ways.
void showList ( int [] list )
for(int x ← 0 ; x<list.length; x ← x + 1)
print list[x]
end showList

A return method (function) might look like this:
int calcVals ( int x, int y )
x ← y + 1
y ← x + 2
return x + y

end calcVals

This function receives two integer values, does some math, and then returns the result.





https://courses.edx.org/courses/course-v1:UTAustinX+UT.WTCS.14.01x+2T2017/courseware/f404e997bdf243d9a26958c3a9ffd6ee/ea8ff7920f6d4e6f9136523df07d1211/?child=first
Parts of a Method

Identify the parts of the method.
problem


Click on the part that represents the body in the method declared below.

correct

Explanation

The body of the method is the section that contains the commands and instructions.


problem


Click on the part that represents the method name in the method declared below.

correct

Explanation

The method name follows the word void or the return type, and is used to identify the process being defined.


problem


Click on the part that represents the return type in the method declared below.

correct

Explanation

The return type of the method indicates the type of result expected from the method. This method will return an integer value.


problem


Click on the part that represents the method name in the method declared below.

correct

Explanation

The method name follows the word void or the return type, and is used to identify the process being defined.


problem


Click next to the line that represents the header of the method declared below.

correct

Explanation

The header of the method is where the return type, name, and parameter list of a method are declared.


problem


Click on the part that represents the parameter list in the method declared below.

correct

Explanation

The parameter list follows the name of the method, and are the variables in parentheses that receive the information to be processed in the body of the method.


problem


Click on the part that represents the parameter list in the method declared below.

correct

Explanation

The parameter list follows the name of the method, and are the variables in parentheses that receive the information to be processed in the body of the method.


problem


Click next to the line that represents the header of the method declared below.

correct

Explanation

The header of the method is where the return type, name, and parameter list of a method are declared.



Actual and Formal Parameters
Parameter
    A variable located inside the parentheses of a method call or method header.
Parameter List
    All of the parameters within the parentheses of a method call or method header.
Actual Parameter
    Value, expression or variable used as a parameter in a method call.
Formal Parameter
    Temporary local variable listed in a method header that receives a value from a method or procedure call, only in scope during the execution of the method. Once the method completes its task, the formal parameter ceases to exist.

What is a Parameter?

As you identified the parts of a method in a previous exercises, you saw that one of the parts was called a parameter. Parameters are variables located inside the parentheses of a method call or method header.

Parameters classified as formal or actual.
Actual Parameters

Actual parameters are the literal values, expressions or variables in the parentheses of method calls, which send or pass that information to the method being called, like a quarterback passing a ball to a receiver.

The actual parameter is located in the method call
Formal Parameters

Formal parameters are the variables in the parentheses of the method header that receive the value from the method call, like a receiver in football catches the ball from the quarterback.

The formal parameter is located in the method header

problem


Which portion in the method declaration and call below represents the actual parameter?
int f ( int n, int k )
	if ( k  % 2 == 0 || n % 2 == 0)
		return 1
	else
		return k * n
	end if
end f
f (21 , 90 )

int f
(int n, int k)
(21, 90) correct
return k * n

Explanation

Remember that the actual paramater is located in the method call. The method call is:
f (21 , 90 )

Therefore, the actual parameters are 21 and 90.

Which portion in the method declaration and call below represents the formal parameter?
int f ( int n, int k )
	if ( k  % 2 == 0 || n % 2 == 0)
		return 1
	else
		return k * n
	end if
end f
f (21 , 90 )

int f
(int n, int k) correct
(21, 90)
return k * n

Explanation

Remember that the formal paramater is located in the method header. The method header is this:
int f ( int n, int k )

Therefore, the formal parameters are int n and int k







Passing by Value, Passing by Reference
Parameter Passing
    The process in the source code of a program whereby data is passed from one section of the program to another, using actual parameters in method calls that send information to formal parameters in method headers.
Passing by Value
    When a parameter is passed by value, any changes made by the formal parameter do NOT affect the value of the actual parameter.
Passing by Reference
    When a parameter is passed by reference, the memory location of the object referenced by the actual parameter is passed to the formal parameter, so that any changes made to that object by the formal parameter immediately affect the actual parameter, since both formal and actual parameters are referencing, or "pointing to", the same object in memory.

Passing Parameters

Parameters are passed to methods. To pass a parameter value means to make a value that exists in one place of a program available to another place in that program. This concept is crucial to all programming paradigms, including Object-Oriented Programming.

There are two ways a parameter value can be passed within a program:

    By Value, or
    By Reference

Passing by Value

Passing a parameter by value means that a copy of the value from the actual parameter is provided to the formal parameter, kind of like sending a fax or email attachment. And just like someone writing on a copy you faxed to them won't change your original document, passing by value means that any changes made inside the method involving the formal parameter DO NOT affect the value of the actual parameter.

Passing a parameter by value is like sending a document via fax

Here is a pseudocode program that demonstrates passing by value.

---------------------method definition---------------------

void f (pass-by-value int y)

print y

y ← y + 5

print y

end f

---------------------program execution starts here---------------------

int a ← 6

print a

f(a)

print a

---------------------program execution ends here---------------------
problem


What is the output of this program?
6 6 6 6
6 6 11 11
6 6 5 6
6 6 11 6 correct

Explanation
Because the parameter in method f was passed by value, the changes that happened inside of the method had no effect on the original variable. The original value of a was 6, printed before the method call to f. Once inside method f, the passed value of 6 is printed, changed to 11, printed, and the method is done. Control returns to main, where the unchanged value of a, or 6, is printed a final time.


Passing by Reference

A reference in programming is when an object variable references, or “points to” an object in memory. The object variable does not contain the object, but instead contains the memory location of that object, and it is the memory location that is passed by reference, not a copy of the object itself, as in passing by value. So, instead of faxing a copy (as you did in passing by value), passing by reference is like sending someone a link to a Google doc, or some other cloud-based artifact. You aren't sending them a copy of the document. Instead, you are sending them the address, link, or memory location that points to the document.

Passing a parameter by reference is like sending someone a link to a Google Doc

Here is a pseudocode program that demonstrates passing by reference.

---------------------method definition---------------------

void f (pass-by-reference int y)

print y

y ← y + 5

print y

end f

---------------------program execution starts here---------------------

int a ← 6

print a

f(a)

print a

---------------------program execution ends here---------------------
problem


What is the output of this program?
6 6 6 6
6 6 11 11 correct
6 6 5 6
6 6 11 6

Explanation

Because the parameter in method f was passed by reference, the change that happened inside of the method also affected the original variable. The original value of a was 6, printed before the method call to f. Once inside method f, the passed value of 6 is printed, changed to 11, printed, and the method is done. Control returns to main, where the changed value of a, or 11, is printed a final time.







Procedures, Functions, Methods Terminology Practice
problem


A value, variable, or expression in the parameter list of a method call.
Actual parameter correct
Formal parameter
Value parameter
Reference parameter

Explanation:
Actual parameters are in method calls. Formal parameters are in method headers.


problem


A variable in the parameter list of a method header.
Actual parameter
Formal parameter correct
Value parameter
Reference parameter

Explanation:
Actual parameters are in method calls. Formal parameters are in method headers.


problem

The type of parameter where changes by the method DO NOT affect the original data.
Actual parameter
Formal parameter
Value parameter correct
Reference parameter

Explanation:
A parameter passed by value sends a copy to the method, where any changes made inside the method DO NOT affect the original actual parameter.


problem


A block of code that performs an action without returning a value
procedure correct
return method
function
method call


problem


The first line of a procedure, function, or method
header correct
definition/body
call
parameter list


problem


In the pseudocode example shown, "Suzy" is an example of a(an) ______________ parameter
void sayHello(string name)
  print("Hello "+name+"!")
void main
  sayHello("Suzy")
Actual correct
Formal

Explanation:
Variables in method calls are called actual parameters.


problem


The block of code that makes up the process performed by a procedure, function, or method.
header
definition/body correct
call
parameter list


problem


A programming block of code that performs a task without returning a value.
Procedure, void method correct
Function or return method
Header
Definition
Call

Explanation:
Procedures (void methods) perform tasks without returning values. Fuctions (return methods) return some kind of value based on a calculation of some sort.


problem

A block of statements that performs the task of a procedure, function, or method.
Procedure, void method
Function, return method
Header
Definition correct
Call

Explanation:
A procedure, function, or method consists of a header, which contains the return type or the word void, the name of the process, and any formal parameters. The body of the process is referred to as the definition of it.





Black Box Programming

Do you own a car?  Probably.  Do you know how to drive it?  Hope so. But do you know how it works inside? Perhaps some of you do, but most of us do not.  In a way, a car is a “black box”, something that is abstract, that has easy to operate external controls, called the interface, and that produces results in reaction to the controls, as in moving on down the road, getting you where you need to be.

Below are several resources that discuss the idea of a black box.  All of them have something in common to the car example above.  Read through each one to gain a better understanding of this “black box” notion.
What is a Black Box?

Text and Image from Wikipedia

In science, computing, and engineering, a black box is a device, system or object which can be viewed in terms of its inputs and outputs (or transfer characteristics), without any knowledge of its internal workings. Its implementation is "opaque" (black). Almost anything might be referred to as a black box: a transistor, an algorithm, or the human brain.

Blackbox3D-withGraphs.png
Object-Oriented Programming, Abstraction, and Black Boxes

Text from University of Maryland

When you study object-oriented programming, or even procedural programming, you are taught the idea of abstraction. For example, when you learn about OOP, you are told that the user should only see the public methods. Data members and the code to implement the public methods should be hidden away. The public methods represent the objects interface. They tell the user of the object what are valid methods they can call. If the designer of the class is good, they have given you a description of what each method does abstractly. That is, they haven't told you how it's implemented, only its behavior.

You can think of an object as a black box. You feed in inputs (through arguments) and get back an output (through the return value). Similarly, in procedural languages (like C), you pass in arguments to a function, and you get a return value as a result. The actual implementation is hidden away. Why think about circuits as black boxes? For the same reason you think about functions as black boxes. It lets you focus on the important aspects of the function, but hides away detail.

For example, you may have learned how methods such as scanf() or cin work. This was explained at a high-level. However, do you really know the implementation? You probably don't. And, what's more, you don't have to! The implementation is complex, and it may be difficult to remember all the details. Of course, some people look at the implementation when the description of what a function or object does is not clear. But if the description is clear, you don't have to care.
Subroutines and Black Boxes

Text from Hobart and William Smith Colleges

A subroutine consists of instructions for performing some task, chunked together and given a name. "Chunking" allows you to deal with a potentially very complicated task as a single concept. Instead of worrying about the many, many steps that the computer might have to go though to perform that task, you just need to remember the name of the subroutine. Whenever you want your program to perform the task, you just call the subroutine. Subroutines are a major tool for dealing with complexity.

A subroutine is sometimes said to be a "black box" because you can't see what's "inside" it (or, to be more precise, you usually don't want to see inside it, because then you would have to deal with all the complexity that the subroutine is meant to hide). Of course, a black box that has no way of interacting with the rest of the world would be pretty useless. A black box needs some kind of interface with the rest of the world, which allows some interaction between what's inside the box and what's outside. A physical black box might have buttons on the outside that you can push, dials that you can set, and slots that can be used for passing information back and forth.

Since we are trying to hide complexity, not create it, we have the first rule of black boxes: The interface of a black box should be fairly straightforward, well-defined, and easy to understand. Are there any examples of black boxes in the real world? Yes; in fact, you are surrounded by them. Your television, your car, your mobile phone, your refrigerator.... You can turn your television on and off, change channels, and set the volume by using elements of the television's interface -- dials, remote control, don't forget to plug in the power -- without understanding anything about how the thing actually works. The same goes for a mobile phone, although the interface in that case is a lot more complicated.
Black Box Testing

Text and Image from Software Testing Fundamentals

Black Box Testing, also known as Behavioral Testing, is a software testing method in which the internal structure/ design/ implementation of the item being tested is not known to the tester. These tests can be functional or non-functional, though usually functional.

black box testing image

This method is named so because the software program, in the eyes of the tester, is like a black box; inside which one cannot see. This method attempts to find errors in the following categories:

    Missing functions
    Interface errors
    Errors in data structures or external database access
    Behavior or performance errors
    Initialization and termination errors






Method and Parameter Practice
problem


What is output by the code segment shown below?
void doStuff (pass-by-reference int x, pass-by-reference y)
	print(x + ":" + y + ":")
	x ← x + 5
	y ← y + 3
	print(x+":"+y+":")
end doStuff
//client code
int a ← 2
print(a + "-")
doStuff(a, a)
print(a + "-")

2-2:2:7:5:2-
2-2:2:7:10:2-
2-2:2:10:10:10- correct
2-2:2:7:10:10-

Explanation:
The sequence is:
The variable a gets 2, and is printed (2-).
a is then passed twice to the doStuff method, first by reference to x, and then by reference to y.
x and y are both printed (2:2:), and x is incremented to 7, which immediately changes a in main to 7 since it was passed by reference. This action also immediately affects y.
y is then incremented to 10, which again automatically changes a to 10 since it was passed by reference.
Now all three variables, x, y, and a are referencing the value 10, and x and y are printed (10:10:)
The doStuff method is done, and then a is printed (10-).


problem


What is output by the code segment shown below:
void calc ( int x, int y)
    print x * y
end calc
//client code
int a ← 6
int b ← 6
calc (a, b)

6 * 6
x + y
36 correct
There is no output due to an error.

Explanation

The void method calc prints out the product of the two formal parameters, x(6) and y(6), which is 36.


problem


What is output by the code segment shown below?
void doStuff (passed-by-value int x)
	print(x)
	x←x+5
	print(x)
end doStuff
//client code
int a ← 2
print(a)
doStuff(a)
print(a)

2277
2272 correct
2777
7722

Explanation:
The sequence is:
a gets 2, and is printed (2)
a is passed by value to doStuff as x, and printed (2)
x is incremented by 5, then printed (7)
control returns to main, where a remains unchanged (since it was passed by value), and is printed (2)


problem


What is output by the code segment shown below?
void calc (pass-by-reference int w, pass-by-reference int x,
		pass-by-value int y, pass-by-value int z)
  w ← w + 5
  x ← x / 3
  y ← y % 2
  z ← z * 4
  print z + " "
end calc
//client code
int a ← 16
int b ← 12
calc ( a, a, b, b )
print b

12 48
12 12
48 12 correct
48 48

Explanation
A copy of the value b(12) is passed to the value parameter z, which is multiplied by 4, and then output (48). When the method is done, the original unchanged value of b (12) is printed.


problem


What is output by the code segment shown below?
procedure calc ( int x, int y)
    x ← x + 5
    y ← y + 2
    print x + y
end calc
//client code
a ← 4
b ← 7
calc (a, b)

9 + 9
18 correct
11 correct
4 + 7

Explanation
The variables a(4) and b(7) are passed to calc, received by x and y, which are then incremented by 5 and 2 respectively to become 9 and 9, whose sum(18) is then output.


problem


What is output by the code segment shown below?
procedure sum ( int x, int y)
    print x + y
end sum
//client code
sum ( 5, 6 )

x + y
5 + 6
11 correct
There is no output due to an error.

Explanation

The void method sum prints out the sum of the two formal parameters, x and y. In the method call, 5 and 6 are passed in as the actual parameters. Therefore, the method will print the value 11.


problem


What is output by the code segment shown below?
void calc (pass-by-reference int w, pass-by-reference int x,
  	  pass-by-value int y, pass-by-value int z)
  w ← w + 5
  x ← x / 3
  y ← y % 2
  z ← z * 4
  print x + " "
end calc
//client code
int a ← 16
int b ← 12
print a + " "
calc ( a, a, b, b )
print a

16 7 16
16 5 5
16 7 7 correct
16 5 16

Explanation
The value of a(16) is printed first, sent twice as actual parameters to calc, received by BOTH formal, reference parameters w and x. The change made by w adds 5 to 16, making it 21. This change also affects a and x, since both are referencing the same value. When x divides 21 by 3, the value 7 is now referenced by all three variables a, w, and x. The value output by x is 7, and the final value output by a is also 7.


problem


What is output by the code segment shown below?
int f ( int x, int y)
  return x * y
end
//client code
print f (5, 4)

5, 4
5 * 4
20 correct
1

Explanation

Method f is called with the two actual parameters 5 and 4. Inside of the method, those passed values are received by the formal parameters x and y, respectively. The method returns the result of x(5) multiplied by y(4). So the final return value of the method is 20.


problem


What is output by the code segment shown below?
procedure calc (int x, int y)
    print x - y
end calc
//client code
calc(5, 6)

1
5 - 6
-1 correct
There is no output due to an error.

Explanation

The procedure calc prints out the difference of the two formal parameters, x(5) and y(6), which is -1.








Math and String Method Libraries

Most modern programming languages have vast libraries of previously defined, developed and tested processes that are very helpful to software developers.  These libraries are extremely useful, allowing development to occur without having to build everything from scratch.  When programmers need to use a tool, they will first check the libraries to see if that tool has already been developed, and if so, happily use it and move on to the next task.

Common to most of these libraries are basic math and String related processes, or methods.

For example, a Math library might contain already defined constant values of PI and E, the two famous transcendental and irrational values on which much of higher level math is based. Others might include functions to find square or cube roots, powers, absolute values, logarithms, or trig based functions like sine, cosine, and tangent. This beats the heck out of looking up values from a trig table in the back of calculus book, or using a slide rule.  We old timers remember those days, right?

Other math methods might include round, which would follow the normal rounding rules in math, or a ceiling or floor function, which returns the closest whole number, either up for ceiling, or down for floor, to a particular floating point value. For example round(4.5) would return 5.0, ceiling(4.2) would return 5.0, and floor (4.8) would return 4.0.

String functions most commonly include a length method, one that counts and returns a value equal to how many characters are in the string.  Other methods might include one like charAt, which in Java will return the character that is “at” a particular index position in the given string, or indexOf, which would give the first occurring position of a character in the given string.  Another useful method in Java is the substring function, which allows you to take a “bite” of a string, given the beginning and ending positions.

These are just a few of the more common methods of functions you might find in a Math or String library.  The trick is to know they are there, and how to use them.

For more information on the Java library of Math and String functions, feel free to view the O(N)CS Lessons on the Math class and String class.













Conditional Processing
What is Conditional Processing?

Previously, you learned that sequential processing is when program statements execute one after another. If a previous statement fails for some reason, the next statement cannot run.

Of course, programs don't JUST run in straight lines. Sometimes, a program can do one thing or another, based on a decision that is made involving data values or program situations. This type of control structure is called a conditional.

Conditional programming branches off into paths.

Conditional processing graphic showing a program branching off into different paths

Notice that conditional programs still run sequentially, until they reach a decision point. Then they take either one path or another and continue sequentially.



If and If Else Statements
Conditional Statement
    A statement in programming that makes a decision using if or if-else situations by evaluating a boolean condition.
If Statement
    Statements in programming that check to see if a Boolean expression is true, and executes a "then" statement if so, otherwise does nothing. These are often called "one-way" conditional statements.
If/Else Statement
    Statements in programming that check to see if a Boolean expression is true, and executes a "then" statement if so, otherwise executes an "else" statement if the condition is false. These are often called "two-way" conditional statements.




The If Statement

The if statement is the most basic way of introducing conditional processing into your program. The if statement simply states that if a certain condition is true, the program should perform the actions specified.

In pseudocode, an if statement might look like this:

if ( n ≥ 4 )

n ← n - 3

end if

Of course, you may also see an if statement embedded inside of a method.

void f1 ( int n )

int k ← 0

if ( k < n )

print k

end if

end f1

problem


Consider the method f1 defined above. What would the output of the method be for the following method call?
f1(27)

"k"
Nothing
0 correct
27

Explanation

The void method f1 takes in the variable n as a formal parameter and initializes the variable k to 0. The if statement reads: if k is less that n, print k.

The method call passes in the actual parameter 27, which is received by the formal parameter n. Is 0(k) less than 27(n)? Yes. So the method prints the value of k, which is 0.



Now consider if the method f1 looked like this:

void f1 ( int n )

int k ← 30

if ( k < n )

print k

end if

end f1

And the method call looked like this:

f1(27)

What would happen then? Would the program break?

Not at all! If the condition specified by the if statement is false (e.g. 30 is NOT less than 27), the program simply ignores the if statement and continues sequentially processing statements in the rest of the program.




If/Else Statements

The if statement on its own is a powerful tool to create conditional pathways in your program. The if statement can be expanded to include two or more situations using the else command to create even more paths. Using an if/else statement allows you to define something else that the program should do when the if condition is false.

For example, we can expand the void method from before to include an else statement:

void f1 ( int n )

int k ← 0

if ( k < n )

print k

else

print n

end if

end f1
problem


Consider the method f1 defined above with the new else statement. What would the output of the method be for the following method call?
f1(27)

"k"
Nothing
0 correct
27

Explanation

The void method f1 takes in the variable n as a formal parameter and initializes the variable k to 0. The if statement reads: if k is less that n, print k. Otherwise (the else statement), print n.

The method call passes in the actual parameter 27, received by n. Is 0(k) less than 27(n)? Yes. So the output is for the method to print the value of k, which is 0.



So what would happen if we altered our method as we did before:

void f1 ( int n )

int k ← 30

if ( k < n )

print k

else

print n

end if

end f1

And the method call looked like this:

f1(27)

In this case, we have an else statement. So, when k is not less than n, the method has instructions to print the value of n. So the output here would be : 27.

If statements can be chained together, one after another using this pattern in order to continue to account for various possibilities. For example:

void f1 ( int n )

int k ← 30

if ( k < n )

print k

else if (k > n)

print n

else if (k == n)

print "Equal"

end if

end f1

Can you understand what this new method does?
problem


Consider the method f1 defined above. What would the output of the method be after the following method call?
f1(30)

30
Nothing
"Equal" correct
0

Explanation

The void method f1 takes in the variable n as a formal parameter and initializes the variable k to 30. The if statement reads: if k is less that n, print k. Otherwise, if k is greater than n (the first else if statement), print n. Otherwise (the second else if statement), if k and n are equal, pring "Equal."

The method call passes in the actual parameter 30. Is 30(k) less than 30(n)? No. So the method skips over the rest of this statement. The next statement asks if 30(k) is greater than 30(n). The answer is no again, so the method skips over the rest of this statment. The next statement asks if 30(k) is equal to 30(n). The answer is yes. So the method will print "Equal."






Short Circuit Evaluation checking the first expression if false result so skipping the first part this is for AND or &&
For OR or || having TRUE in the first part, which means there is no need to look at the second part: TRUE OR TRUE is TRUE and TRUE or FALSE is TURE





If/Else Statement Practice
problem


What is the output of this code segment?
int num1 ← 35, num2 ← 17
int num3 ← num1 % num2
int num4 ← num2 % num1
if(num3 < num4)
	print num3
else
	print num4
end if
1 correct
0
17
18
35

Explanation:
The variable num3 is assigned the mod value of 35 and 17, which is 1 (35 divided by 17 is 2, remainder 1), and num4 is assigned the mod value of 17 and 35, which is 17 (17 divided by 35 is 0, remainder 17). Since 1 is LESS THAN 17, the if expression is true, and num3 is output, which has the value 1.


problem


What is output by the pseudocode segment shown?
int num1 ← 14, num2 ← 35
int num3 ← num1 % num2
int num4 ← num2 % num1
if(num3 < num4)
	print num3
else
	print num4
end if
0
35
14
7 correct

Explanation:
The variable num3 is assigned the mod value of 14 and 35, which is 14 (14 divided by 35 is zero, remainder 14), and num4 is assigned the mod value of 35 and 14, which is 7 (35 divided by 14 is 2, remainder 7). Since 14 is NOT LESS THAN 7, the if expression is false, and num4 is output, which has the value 7.


problem

Which of the following is NOT a relational operator that can be used in an if or if else statement?
= =
<
← correct
≠
≥

Explanation:
The ← is the assignment operator in pseudocode.


problem


Consider the following method:
int sumOrDiff (int x, int y)
    if ( x ≥ y )
      return x + y
    else
      return y - x
    end if
end sumOrDiff

What is returned by the method call below?
int a ← 9
int b ← 5
sumOrDiff(a,b)

9 5
5 9
14 correct
4

Explanation
The values 9 and 5 are passed by the actual parameters a and b to the formal parameters x and y, first compared to see if x is greater than y, evaluating to true, and outputting the sum of 9 and 5, which is 14. The else portion of the method is skipped.


problem


Consider the following method:
void hiLoMiddle( int num )
    if ( num > 60 )
      print "High"
    else
    if ( num > 0 AND num < 40 )
      print "Low"
    else
	print "Middle"
    end if else chain
end hiLoMiddle

What is returned by the method call below?
hiLoMiddle(75)

Nothing is printed
Low
High correct
Middle

Explanation
The value 75 is sent as an actual parameter to the method hiLoMiddle, where it is received by the formal parameter num. It is then compared in an if statement to see if it is greater than 60, which it is, resulting in the word "High" being output. All of the rest of the if else chain is ignored, and then method finishes.


problem


Consider the following method:
procedure sum (int x, int y)
    if ( x ≥ y )
      print x + y
    else
      print y - x
    end if
end sum

What is printed by the method call below?
sum(8,10)

18
8 + 10
2 correct
10 - 8

Explanation

The values 8 and 10 are received by the formal parameters x and y, and then the sum is printed if x is greater than y, which is false in this case, so the else portion of the conditional is executed, resulting in the value 2 (10 - 8) being printed.


problem


Consider the following method:
procedure sum (int x, int y)
    if ( x ≥ y )
      print x + y
    end if
end sum

What is returned by the method call below?
sum(7,6)

7
7 + 6
13 correct
Nothing

Explanation
The values 7 and 6 are received by the formal parameters x and y, and then the sum is printed if x is greater than y, which is true in this case, resulting in the value 13 being printed.


problem


Consider the following method:
void f ( int num )
  	int x ← 30
    if ( num > x OR num == x )
      print "Large"
    else
      print "Small"
    end if
end f

What is returned by the method call below?
f(30)

LargeSmall
Small
Large correct
Nothing is printed

Explanation

The void method f takes in the formal parameter num (remember that parameters can be named whatever you want). The method is called with the actual parameter 30, which will become num.

Inside the method, an integer variable x is initialized to the value x. Next is an if/else statement with the condition: if num is greater than x OR num is equal to x. In this case, num(30) IS equal to x. Because of the logical OR operator, only one statement has to be true. So, in this case, the program will continue with the if statement. The method will print the string "Large."

Note that, because the condtion in the if statement is true, the program will SKIP the else statement. All if-type statements only do one thing OR another, never both.


problem


Consider the following method:
String greetTheDay( int time )
  String greeting
    if ( time < 10 )
      greeting ← "Good morning"
    else if ( time < 20 )
      greeting ← "Good day"
    else
      greeting ← "Good evening"
    end if
  return greeting
end greetTheDay

What is output by the method call below?
print greetTheDay(14)

Nothing is printed
Good morning
Good day correct
Good evening

Explanation
The void method greetTheDay takes in the formal parameter time (remember that parameters can be named whatever you want). The method is called with the actual parameter 14, which will become time. Inside the method, the string variable greeting is declared. Next, there's an if statement with the condition: if time is less than 10. In this case, time(14) is NOT less than 10, so the method will then look at the next statement, an else if statement with the condition: if time is less than 20. The variable time IS less than 20, so the greeting variable will be assigned the string "Good day", skipping the final else statement (because condition of the else if statement was met), the method will return "Good day", which is then printed.


problem


Consider the following method:
procedure f ( int num )
  	int x ← 30
    if ( num > x )
      print "Large"
    else if ( num < x )
      print "Small"
  	else
  	  print "Equal"
    end if
end f

What is output by the method call below?
f(30)

LargeSmallEqual
Small
Equal correct
Large

Explanation

The void method f takes in the formal parameter num (remember that parameters can be named whatever you want). The method is called with the actual parameter 30, which will become num.

Inside the method, an integer variable x is initialized to the value 30. Next is an if statement with the condition: if num is greater than x. In this case, num(30) IS NOT greater than x. So the rest of this if statement will be skipped.

The program will next encounter an else if statement with the condition: if num is less than x. Num is NOT less than x, so the rest of this statement will be skipped.

Since neither of the previous conditions were met, the program will run the final else code block. That means that the method will print "Equal."






Multi-Way Conditional Statements
Switch Statements
    A conditional control structure in programming that functions as a multi-step if else statement, where several cases are stated and examined during execution to seek a match, and then a command is executed when a match is found.
Break
    A programming term that ends the process in a control structure, such as a loop or switch case statement.

Using If Else Chain Statements

Sometimes a program situation will have more than two conditions, requiring more than the if/else statement can handle.  There are two ways to handle this:

Use a chain of if else statements, or use a switch case statement.

Consider this example that takes in input from a question that asks a person's favorite color. In if statements, the code might look like this:

string favColor

print "What is your favorite color?"

input favColor

if (favColor == "Blue")

print "A cool color."

else if (favColor == "Red")

print "A really warm color."

else if (favColor == "Green")

print "The color of grass (in some places)."

else if (favColor == "Vermillion")

print "Similar to red, but orangey-er."

else if (favColor == "Yellow")

print "The color of the sun, among other things."

else if (favColor == "Chartreuse")

print "Is anything actually chartreuse? Think about it."

else

print "I don't know that color."

If you read this series of statements carefully, of course you will be able to understand the program. However, in some cases, using a switch case statement can make this code easier to read.
The Switch Case Statement

The switch case statement is another type of conditional control structure that allows you to provide a multi-case decision structure.  It is best to use a switch when an if-else chain becomes long and complicated.

The benefit to using the switch statement is readability for you and any other developer who may be working on the program.

It is important to note that switch statements only work with data that is discrete, which includes integers, characters, and in some languages, strings.  A data type that is NOT discrete is like a floating point value, where there is NOT a unique value before and after any particular value.  In most languages, floating point numbers cannot be used in switch statements.

Consider the switch statement below, in contrast with the if/else if statements defined above.

string favColor

print "What is your favorite color?"

input favColor

switch ( favColor )

case "Blue": print "A cool color."; break;

case "Red": print "A really warm color."; break;

case "Green": print "The color of grass (in most places)."; break;

case "Vermillion": print "Similar to red, but orangey-er."; break;

case "Yellow": print "The color of the sun, among other things."; break;

case "Chartreuse": print "Is anything actually chartreuse? Think about it."; break;

default: print "I don't know that color.";

This code snippet does exactly the same thing as the chain of if statements: it would take in some input on a person's favorite color and print out a statement, depending on what the input was. Can you understand how it works?
problem

Given the switch case statement above, what would be the output if the variable favColor was changed to "Vermillion"?
"A really warm color."
"I don't know that color."
"Similar to red, but orangey-er." correct
"A really cool color."

Explanation

The switch case statement would take in the variable favColor, which was assigned the value "Vermillion." Using this variable, the statement would search for a match. This statement did define a case for vermillion, so the output would be "Similar to red, but orangey-er."


problem

Now consider the switch case statement again. What would be the output if favColor became "Marigold"?
"A really warm color."
"I don't know that color." correct
"Similar to red, but orangey-er."
"A really cool color."

Explanation

The switch case statement would take in the variable favColor, which was assigned the value "Marigold." Using this variable, the statement would search for a match. This statement doesn't have a defined case for "Marigold," so it would use the default case and print out "I don't know that color."


The Break Keyword

Did you notice the word break at the end of each line in the switch case statement? This is a special keyword that tells a program to exit the switch statement.

If we remove the break from the end of one or more of the lines, once a match is found, and the program "jumps the fence", it would continue to print until it reached a break or the end of the switch case statement. For example:

string favColor

switch ( favColor )

case "Blue": print "A cool color."

case "Red": print "A really warm color."

case "Green": print "The color of grass (in most places)."

case "Vermillion": print "Similar to red, but orangey-er."

case "Yellow": print "The color of the sun, among other things."

case&nbsp;"Chartreuse": print "Is anything actually chartreuse? Think about it."

default: print "I don't know that color."

If favColor was assigned the value "blue," this switch case statement would actually print ALL of the lines because all of the breaks have been removed, with an output result of:

"A cool color."
"A really warm color."
"The color of grass (in most places)."
"Similar to red, but orangey-er."
"The color of the sun, among other things."
"Is anything actually chartreuse? Think about it."
"I don't know that color."

The break keyword is essential to forming a switch statement that works the way it should.







Switch Statement Practice
problem


Consider the following pseudocode segment:
void whichDay (int day)
  switch ( day )
    case 0: print "Sunday"; break;
    case 1: print "Monday"; break;
    case 2: print "Tuesday"; break;
    case 3: print "Wednesday"; break;
    case 4: print "Thursday"; break;
    case 5: print "Friday"; break;
    case 6: print "Saturday"; break;
  end switch
end whichDay
//client code
whichDay(2)


What is printed?
WednesdayThursdayFridaySaturday
Sunday
Tuesday correct
Saturday

Explanation

The value 2 is sent to the whichDay method, received by the formal parameter day, and then sent into the switch statement. It is first compared to 0 and 1, with no matches, but reaches the 2 which does match. Control then "jumps the fence" and executes the statement, which outputs "Tuesday", and then stops because of the break.


problem


What is output by the following pseudocode segment?
void coffeeType(string coffee)
  switch (coffee)
    case "Americano": print "Part espresso, part water."; break;
    case "Cappucino": print "Part espresso, part milk, part milk foam."; break;
    case "Latte": print "Part normal coffee, part milk."; break;
    case "Mocha": print "Part espresso, part milk, shaved cacao topping."; break;
  end switch
end coffeeType
//client code
coffeeType("Carajillo")
"Part normal coffee, part milk."
"Part espresso, part milk, shaved cacao topping."
Nothing is output correct
"No Carajillo defined."

Explanation

The void method coffeeType takes in a formal parameter which is a string that we call coffee. The method call is passed the actual parameter "Carajillo." Back inside of the method, the switch statement takes in the coffee variable and looks for a matching case. There is no case for "Carajillo". Notice that this switch statement does not define a default case, so there is NO output.


problem


The switch statement below should calculate a week's pay based on number of years experience. For 1 year of experience, the hourly wage is $7, for 2 years $8 an hour, 3 years $10, 4 years $12, and 5 years $15 per hour. The number of hours will vary between 1 and 40 hours. Which choice will be used to rightly calculate the totalWeekPay so that the output shown is $200?
int years ← 3
int hours ← 20
int totalWeekPay = 0;
switch(years)
	case 1: ___________________________________
	case 2: ___________________________________
	case 3: ___________________________________
	case 4: ___________________________________
	case 5: ___________________________________
end switch
//client code
print "$"+totalWeekPay
case 1: totalWeekPay = hours*7;break;
case 2: totalWeekPay = hours*8;break;
case 3: totalWeekPay = hours*10;break; correct
case 3: totalWeekPay = hours*12;break;
case 4: totalWeekPay = hours*15;break;

Explanation:
For 3 years of experience, a pay level of $10 an hour for 20 hours of pay results in a total pay amount of $200.


problem


What is output by the following pseudocode segment?
void grading (char grade)
  switch (grade)
    case 'A': print "An excellent grade. Well done!"; break;
    case 'B': print "A very good grade!"; break;
    case 'C': print "Very average."; break;
    case 'D':
    case 'E':
    case 'F': print "Not too good. You can do better!"; break;
    default: "This isn't a grade!"; break;
  end switch
end grading
//client code
grading('G')
"Poorly done. You can do better!"
"An very good grade!"
"This isn't a grade!" correct
"Very average."

Explanation

The void method grading takes in a formal parameter which is a character that we call grade. The method call is passed the actual parameter 'G'. Back inside of the method, the switch statement takes in the grade variable and looks for a matching case. There is no case defined for 'G', so the statement will print out "This isn't a grade!"

Notice that this switch statement is constructed so that there is one output for the cases 'D', 'E', and 'F'.


problem


What is output by the pseudocode segment shown below?
void whichDay (int day)
  switch ( day )
    case 0: print "Sunday"; break;
    case 1: print "Monday"; break;
    case 2: print "Tuesday"; break;
    case 3: print "Wednesday";
    case 4: print "Thursday";
    case 5: print "Friday";
    case 6: print "Saturday";
  end switch
end whichDay
//client code
whichDay(3)
WednesdayThursdayFridaySaturday correct
Sunday
Tuesday
Saturday

Explanation

The value 3 is sent to the whichDay method, received by the formal parameter day, and then sent into the switch statement. It is first compared to 0, 1, and 2 with no matches, but reaches the 3 which does match. Control then "jumps the fence" and executes the statement, which outputs "Wednesday". Since there is no break after this print statement, control continues to fall through the remaining statements, outputting the rest of the days, "ThursdayFridaySaturday".


problem


What is output by the following pseudocode segment?
void fruits(string fruit)
  switch (fruit)
    case "Oranges": print "Oranges are $0.59 a pound."; break;
    case "Apples": print "Apples are $0.32 a pound."; break;
    case "Bananas": print "Bananas are $0.48 a pound."; break;
    case "Cherries": print "Cherries are $3.00 a pound."; break;
    case "Mangoes":
    case "Papayas": print "Mangoes and papayas are $2.79 a pound."; break;
    default: "Sorry we're out of " + fruit; break;
  end switch
end fruits
//client code
fruits("Mangoes")
"Oranges are $0.59 a pound."
"Bananas are $0.48 a pound."
"Mangoes and papayas are $2.79 a pound." correct
"Sorry, we're out of Mangoes"

Explanation

The void method fruits takes in a formal parameter which is a string that we call fruit. The method call is passed the actual parameter "Mangoes." Back inside of the method, the switch statement takes in the fruit variable and looks for a matching case. There is a case defined for both "Mangoes" and "Papayas." So, the method will print "Mangoes and papayas are $2.79 a pound."


problem

Which of these reserved words is NOT used to control a switch statement?
case
switch
default
continue correct
break

Explanation:
The term continue is used in some languages to interrupt the remaining action of a loop, but is not used in switch statements.


problem


What is output by the following pseudocode segment?
procedure riddleHint( int hint )
  switch ( hint )
    case 1: print "I eat, I live."; break;
    case 2: print "I breathe, I live."; break;
    case 3: print "I drink, I die."; break;
    default: print "No hints for you.";
  end switch
end riddleHint
//client code
riddleHint(4)
"I breathe, I live."
"I drink, I die."
"No hints for you." correct
"I eat, I live."

Explanation

The void method riddleHint takes in a formal parameter which is an integer that we call hint. The method call is passed the actual parameter 4. Back inside of the method, the switch statement takes in the hint variable and looks for a matching case. There is a no matching case for 4, so the statement will use the default case. So the method will print: "No hints for you."

Spoiler: the answer to the riddle is fire. Highlight this line with your cursor to see the answer.


problem


In the switch statement shown below, what is the output when the letter 'a' is input?
char let
input let
switch(let)
	case 'a':
	case 'A': print "dog";  break;
	case 'b':
	case 'B': print "cat";
	case 'c':
	case 'C': print "pig";break;
	case 'd':
	case 'D': print "horse";
	case 'e':
	case 'E': print "cow";   break;
end switch
dog correct
nothing
dogcatpig
dogcatpighorsecow

Explanation:
The input letter 'a' matches the first case, which has no result when you "jump the fence", but falls to the next result, which outputs the word "dog", and then stops because of the break.


problem


What is output by the following pseudocode segment?
procedure isVowel( char letter )
  switch ( letter )
    case 'A':
    case 'E':
    case 'I':
    case 'O':
    case 'U': print letter + " is a vowel."; break;
    case 'Y': print letter + " is sometimes used as a vowel."; break;
    default: print letter + " is a consonant.";
  end switch
end isVowel
//client code
isVowel('Q')
"Q is a vowel."
"Q is sometimes used as a vowel."
"Q is a consonant." correct
Nothing is output

Explanation

The void method isVowel takes in a formal parameter which is a character called letter. The method call is passed the actual parameter 'Q'. Back inside of the method, the switch statement takes in the letter variable and looks for a matching case. There is a no matching case for 'Q', so the statement will use the default case.

The default case uses string concatenation to construct the string "Q is a consonant.", which is then printed.




If and Switch Statement Practice
problem


What is output by the pseudocode segment shown below?
void fizzBuzz ( int num )
    string output = "default"
    if ( num % 3 == 0 )
      output  ← "Fizz"
    else if ( num % 5 == 0)
      output ← "Buzz"
    end if
  print output
end fizzBuzz
//client code
fizzBuzz(35)

"Fizz"
"default"
"Buzz" correct
"FizzBuzz"

Explanation

The void method fizzBuzz takes in the formal parameter num, which is an integer. The method is called with the actual parameter 35, which will become num.

Inside the method, is an if statement with the condition: if the remainder of num divided by 3 is 0 (num % 3). In this case, the remainder of 35 divided by 3 is NOT 0, but 2 instead, so the rest of this if statement will be skipped.

The program will next encounter an else if statement with the condition: if the remainder of num divided by 5 is 0 (num % 5). 35 divided by 5 DOES have a remainder of 0, so the method will first assign the string "Buzz" to the variable output. Then the method will print "Buzz."


problem


What is output by the pseudocode segment shown below?
procedure f ( int num )
  	int x ← 30
    if ( num > x )
      print "Large"
    else if ( num < x )
      print "Small"
  	else
  	  print "Equal"
    end if
end f
//client code
f(35)

"LargeSmallEqual"
"Small"
"Equal"
"Large" correct

Explanation

The procedure f takes in the formal parameter num (remember that parameters can be named whatever you want). The method is called with the actual parameter 35, which will become num.

Inside the procedure, an integer variable x is initialized to the value 30. Next is an if statement with the condition: if num is greater than x. In this case, num(35) IS greater than x. That means that the method will output "Large." and the rest of the statements will be skipped.


problem


Consider the following method:
void fruits( string fruit )
  switch ( fruit )
    case "Oranges": print "Oranges are $0.59 a pound." break
    case "Apples": print "Apples are $0.32 a pound." break
    case "Bananas": print "Bananas are $0.48 a pound." break
    case "Cherries": print "Cherries are $3.00 a pound." break
    case "Mangoes":
    case "Papayas": print "Mangoes and papayas are $2.79 a pound." break
    default: "Sorry we're out of " + fruit break
  end switch
end fruits

What is returned by the following method call?
fruits("Papayas")
"Oranges are $0.59 a pound."
"Bananas are $0.48 a pound."
"Mangoes and papayas are $2.79 a pound." correct
"Sorry, we're out of Mangoes"

Explanation

The void method fruits takes in a formal parameter which is a string that we call fruit. The method call is passed the actual parameter "Mangoes." Back inside of the method, the switch statement takes in the fruit variable and looks for a matching case. There is a case defined for both "Mangoes" and "Papayas." So, the method will print "Mangoes and papayas are $2.79 a pound."


problem


What is output by the pseudocode segment shown below?
procedure morseCode ( char letter )
  switch ( letter )
    case 'A': print ".-"; break;
    case 'B': print "-..."; break;
    case 'C': print "-.-."; break;
    case 'D': print "-.."; break;
    case 'E': print "."; break;
    case 'F': print "..-."; break;
    case 'G': print "--."; break;
  end switch
end morseCode
//client code
morseCode("B")
"..-."
"--."
"-..." correct
"."

Explanation

The void method morseCode takes in a formal parameter which is a character that we call letter. The method call is passed the actual parameter 'B'. Back inside of the method, the switch statement takes in the letter variable and looks for a matching case. There is a case defined for 'B', which will print "-...".


problem


What is output by the pseudocode segment shown below?
void grading ( char grade )
  switch ( grade )
    case 'A': print "An excellent grade. Well done!"; break;
    case 'B': print "An very good grade!"; break;
    case 'C': print "Very average."; break;
    case 'D':
    case 'F': print "Poorly done. You can do better!"; break;
    default: "This isn't a grade!"; break;
  end switch
end grading
//client code
grading('E')
"Poorly done. You can do better!"
"An very good grade!"
"This isn't a grade!" correct
"Very average."

Explanation

The void method grading takes in a formal parameter which is a character that we call grade. The method call is passed the actual parameter 'E'. Back inside of the method, the switch statement takes in the grade variable and looks for a matching case. There is no case defined for 'E', so the statement will print out "This isn't a grade!"

Notice that this switch statement is constructed so that there is one output for several different cases.


problem


What is output by the pseudocode segment shown below?
procedure daysOfChristmas ( int day )
  switch ( day )
    case 12: print "Twelve drummers drumming."; break;
    case 11: print "Eleven pipers piping."; break;
    case 10: print "Ten lords a-leaping."; break;
    case 9: print "Nine ladies dancing."; break;
    case 8: print "Eight maids a-milking."; break;
    case 7: print "Seven swans a-swimming."; break;
    case 6: print "Six geese a-laying."; break;
    case 5: print "FIVE GOLDEN RINGS!!!"; break;
    case 4: print "Four calling birds."; break;
    case 3: print "Three french hens."; break;
    case 2: print "Two turtle dove."; break;
    case 1: print "A partridge in a pear tree."; break;
  end switch
end daysOfChristmas
//client code
daysOfChristmas(7)
"FIVE GOLDEN RINGS!!!"
"A partridge in a pear tree."
"Seven swans a swimming." correct
"Twelve drummers drumming."

Explanation

The void method daysOfChristmas takes in a formal parameter which is a integer that we call day. The method call is passed the actual parameter 7. Back inside of the method, the switch statement takes in the day variable and looks for a matching case and finds a match, outputting the sentence, "Seven swans a swimming.".


problem


What is output by the pseudocode segment shown below?
procedure health ( int hitPoints )
    if ( hitPoints > 50)
      print "You're in great health. Keep going!"
    else if ( hitPoints < 50 AND hitPoints > 25)
      print "You're wounded but alive!"
  	else if ( hitPoints < 25)
  	  print "You're dying. Drink a health potion!"
    end if
end health
//client code
health(32)

"You're in great health. Keep going!"
Nothing is printed.
"You're wounded but alive!" correct
"You're dying. Drink a health potion!"

Explanation

The procedure health takes in the formal parameter hitPoints, which is an integer. The method is called with the actual parameter 32, which will become hitPoints.

Inside the method is an if statement with the condition: if hitPoints is greater than 50. In this case, hitPoints IS NOT greater than 50, so the rest of this if statement will be skipped.

The program will next encounter an else if statement with the condition: if hitPoints is less than 50 AND greater than 25. The value of hitPoints falls within this range, so the method will print "You're wounded but alive!"

Remember that once an if statement condition is true, the program will ignore the rest of the statement, and none of the other statements will be printed.


problem


What is output by the pseudocode segment shown below?
procedure trafficLight (string light)
  switch (light)
    case "green": print "You can go."; break;
    case "yellow": print "You should slow down. Seriously. Not speed up."; break;
    case "red": print "You need to stop."; break;
    default: print "Are you even in traffic?";
  end switch
end trafficLight
//client code
trafficLight("purple")
"You need to stop."
"You can go."
"Are you even in traffic?" correct
"You should slow down. Seriously. Not speed up."

Explanation

The void method trafficLight takes in a formal parameter which is a string that we call light. The method call is passed the actual parameter "purple". Back inside of the method, the switch statement takes in the light variable and looks for a matching case. There is no case defined for "purple", so the switch statement will use the default case, and "Are you even in traffic? is printed."


problem


What is output by the pseudocode segment shown below?
procedure mailCheck (string mailJudge)
    if ( mailJudge == "junk" )
      print "Throw it away. "
    else if ( mailJudge == "possible junk")
      print "Set it aside. "
  	else
  	  print "Read it. "
    end if
end mailCheck
//client code
mailCheck("Concert tickets")

"Throw it away. Set it aside. Read it. "
There is no output.
"Read it. " correct
"Throw it away. "

Explanation

The procedure mailCheck takes in the formal parameter mailJudge, which is a string. The method is called with the actual parameter "Concert tickets", which will become mailJudge.

Inside the method, is an if statement with the condition: if mailJudge is equal to "junk." In this case, mailJudge("Concert tickets") IS NOT equal to "junk." So the rest of this if statement will be skipped.

The program will next encounter an else if statement with the condition: if mailJudge is equal to "possible junk." mailJudge is NOT equal to "possible junk," so the rest of this statement will be skipped.

Since neither of the previous conditions were met, the program will run the else code block. That means that the method will print "Read it."


problem


What is output by the pseudocode segment shown below?
int sumOrDiff (int x, int y)
    if ( x ≥ y )
      return x + y
    else
      return y - x
    end if
end sumOrDiff
//client code
int a ← 6
int b ← 11
print sumOrDiff(a,b)

6
17
5 correct
-5

Explanation

The return method sumOrDiff takes in formal parameters x and y. The method is called with the actual parameters a(6), which will become x, and b(11), which will become y.

Inside the method is an if/else statement with the condition: if x is greater than or equal to y. In this case, x(6) IS NOT greater than y(11) so the program will skip the if statement and go to the else statement. The method will return the difference between y and x, which is 5.

Note that all if-type statements only do one thing OR another, never both.









Operator Optional Practice
problem


Which symbol(s) below will rightly fill the blank to make the expression true?
int num1 ← 44
int num2 ← 44
println  num1 ___ num2

I.  <  II.  >  III.  ≤  IV.  ≥  V.  ==  VI.  ≠
I, III, V
III, IV, V correct
I, II, VI
I, II, III, IV, VI
II, IV, VI

Explanation:
Since the value 44 is EQUAL TO 44, three operators will work for this statement: ≤, ≥, and ==.


problem


What is output by the pseudocode segment shown?
boolean p ← true
boolean q ← true
print p XOR q
false correct
true

Explanation:
Since XOR requires opposite values to evaluate true (true and false, or false and true), the value of this expression is false since the values are the same.


problem


What is the value of the variable after this operation?
int x ← 5
  x ← x * 5

5
25 correct
15
10


problem


What is output by the pseudocode segment shown?
boolean p ← true
boolean q ← true
print NOT p XOR NOT q
false correct
true

Explanation:
The NOT operator has precedence over the XOR operator, and since the NOT operator is applied to both p and q, which are initially both true, they are now both false, and since XOR is false when operands are the same, this expression is false.


problem


What is output by the pseudocode segment shown?
boolean p ← true
boolean q ← true
print p AND q
false
true correct


problem


What is output by the pseudocode segment shown?
int x ← 10
int y ← 10
print x > y
true
false correct


problem


What is output by the pseudocode segment shown?
int x ← 10
int y ← 10
print x ≠ y
true
false correct


problem


What is output by the pseudocode segment shown?
int x ← 6
int y ← 10
print x ≤ y
false
true correct


problem


Which symbol(s) below will rightly fill the blank to make the expression false?
int num1 ← 45
int num2 ← 44
print num2 ___ num1

I.  <  II.  >  III.  ≤  IV.  ≥  V.  ==  VI.  ≠
I, III
III, IV, V
II, IV, V correct
I, III, VI
II, VI

Explanation:
Since the value 44 is LESS THAN 45, three operators will make this statement false: <, ≤, and !=.


problem


What is the value of this boolean expression?
true OR false

Error; this doesn't make sense
true correct
false


problem


Which combination below will make this expression true?
p AND q
boolean p ← false, boolean q ← false
boolean p ← true, boolean q ← true correct
boolean p ← true, boolean q ← false
More than one of these
boolean p ← false, boolean q ← true


problem


What is the value of the variable after this operation?
float x ← 14.5/7

2
2.07
2.1
2.07142857142857 correct


problem


Which symbol(s) below will rightly fill the blank to make the output true?
int num1 ← 45
int num2 ← 34
print (num1 ___ num2)
I.  <  II.  >  III.  ≤  IV.  ≥  V.  ==  VI.  ≠
III, IV, V
II, IV
II, VI
II, IV, VI correct
I, III, V


problem


Which combination below will make this expression true?
p OR q
boolean p ← true, boolean q ← false
More than one of these correct
boolean p ← true, boolean q ← true
boolean p ← false, boolean q ← true
boolean p ← false, boolean q ← false


problem


What is output by the pseudocode segment shown?
int x ← 6
int y ← 10
print x > y
true
false correct


problem


What is output by the pseudocode segment shown?
int x ← 6
int y ← 10
print x ≥ y
false correct
true


problem


Which combination below will make this expression true?
p XOR q
boolean p ← false, boolean q ← false
boolean p ← true, boolean q ← true
boolean p ← false, boolean q ← true
More than one of these correct
boolean p ← true, boolean q ← false

Explanation:
Since XOR can only be true when the values of the two operands are opposite, the choices that make this true are:
boolean p ← false, boolean q ← true
boolean p ← true, boolean q ← false


problem


What is the value of this expression?
(8 > 5) AND (11 < 21)

false
Error; this doesn't make sense
true correct


problem


What is output by the pseudocode segment shown?
int x ← 6
int y ← 10
print x < y
false
true correct


problem


What is output by the pseudocode segment shown?
int x ← 10
int y ← 10
print x ≥ y
true correct
false




Procedures, Functions, Methods Concept Optional Practice
problem

The first line of a procedure, function, or method.
Call
Definition
Void method
Return method
Header correct


problem


A method that acts like a function
procedure
void method
return method correct
method call


problem


A method that acts like a procedure
function
void method correct
return method
method call


problem


A block of code that returns a value based on a calculation of some kind
procedure
void method
function correct
method call


problem


The parameter in the definition header - the receiver
formal parameter correct
method call
actual parameter
functional parameter






Method Output Optional Practice
problem


What is the complete output of the pseudocode example shown here?
int doStuff (pass-by-value int x)
	print(x)
	x←x+5
	print(x)
	return x
end doStuff
void main
	int a ← 2
	print(a)
	a ← doStuff(a)
	print(a)
end main
2277 correct
2272
2777
7722

Explanation:
The sequence is:
a gets 2, and is printed (2)
a is assigned the result of the doStuff method, and is passed by value as x, and printed (2)
x is incremented by 5, then printed (7)
control returns to main, where a was reassigned the return value of doStuff, and is printed (7)


problem


Consider the following method:
void esperanto ( string name )
  print "Saluton! Mi estas " + name
end f

What is output by the call below?
esperanto ("Thorin")

"Saluton! Mi estas " + Thorin
There is no output due to an error.
"Saluton! Mi estas Thorin" correct
"Saluton! Mi estas "


problem


What is output by the pseudocode segment shown below?
void product (pass-by-reference int x, pass-by-reference int y)
    y ← x * y
end product
//client code
int a ← 6
int b ← 6
product (a, b)
print a + " " + b
36 36
6 6
6 36 correct
36 6

Explanation

The void method product takes in the two formal parameters, x and y, and then assigns the product of x * y back to the variable y. In the method call, a (which has been initialized to 6) and b (which has also been initialized to 6) are passed in as the actual parameters. Because the formal parameter y has been passed in by reference, what happens to it also affects the variable b, since they are both pointing to the same data. Since x was not changed, neither was the variable a changed, which remains 6, but b would become 36.








If/Else Optional Practice
problem


Consider the following method:
void applyBrakes( boolean isMoving )
  	int currentSpeed ← 5
    if ( isMoving == true )
      currentSpeed ← currentSpeed - 1
    else
      print "The bicycle has already stopped!"
    end if
end applyBrakes

What happens in the method call below?
applyBrakes(true)

Nothing happens.
"The bicycle has already stopped!" is printed.
The currentSpeed variable is decremented to 4. correct
An error is thrown


problem


Consider the code snippet:
if ( n ≥ 4 )
    n ← n - 3
    print n
end if

What is returned if n is initialized to 3 (n ← 3)?
3
2
Nothing correct
0


problem


Consider the code snippet:
if ( n ≥ 4 )
    n ← n - 3
    print n
end if

What is returned if n is initialized to 5 (n ← 5)?
5
2 correct
Nothing
0







Switch Statement Optional Practice
problem


Consider the following method:
procedure mondaysChild( string day )
  switch ( day )
    case "Monday": print "Monday's child is fair of face"; break;
    case "Tuesday": print "Tuesday's child is full of grace"; break;
    case "Wednesday": print "Wednesday's child is full of woe"; break;
    case "Thursday": print "Thursday's child has far to go"; break;
    case "Friday": print "Friday's child is loving and giving"; break;
    case "Saturday": print "Saturday's child works hard for a living"; break;
    case "Sunday": print "The child who is born on the Sabbath day
			 is fair and wise and good in every way"; break;
  end switch
end mondaysChild

What is output by the following method call?
mondaysChild("Wednesday")
Nothing
"The child who is born on the Sabbath day is fair and wise and good in every way"
"Wednesday's child is full of woe" correct
There is no output due to an error.


problem


In the switch statement shown below, what is the output when the letter 'B' is input?
char let
print "Enter a letter..."
input let
switch(let)
	case 'a':
	case 'A': print "dog;  break;
	case 'b':
	case 'B': print "cat";
	case 'c':
	case 'C': print "pig";break;
	case 'd':
	case 'D': print "horse";
	case 'e':
	case 'E': print "cow";   break;
end switch
cat
catpig correct
dogcatpighorsecow
nothing


problem


Consider the following method:
void theZoo( string animal )
  switch ( animal )
    case "Gorilla":
    case "Ostrich":
    case "Manatee":
    case "Dolphins": print "These animals will be great in the zoo."; break;
    case "T-rex": print "Do birds count? They totally have dinosaur DNA!"; break;
    default: "No " + animal + " here. Try some other zoo."; break;
  end switch
end theZoo

What is returned by the following method call?
theZoo("Velociraptor")
Nothing
"These animals will be great in the zoo."
"No Velociraptor here. Try some other zoo." correct
"Do birds count? They totally have dinosaur DNA!"


problem


What is output by the pseudocode segment shown below?
void whichDay (int day)
  switch ( day )
    case 0:
    case 6: print "This is a weekend."; break;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5: print "This is a weekday."; break;
    default: "This isn't a day of the week!";
  end switch
end whichDay
  //client code
whichDay(3)

"This is a weekend."
Nothing
"This is a weekday." correct
"This isn't a day of the week!"


















Iterative Processing

Iterative Processing is the last of three control structures we'll cover in the course. So far, we've looked at sequential processing and conditional branching.

Iterative processing, the third control structure allows you to execute a block of code over and over, as many times as you need.

After introducing you to the structure, we'll cover several different types of loops, the way in which you implement iterative processing.
Loops

We'll talk about the four standard parts of any loop:

    Start
    Check
    Action
    Step

We'll cover three kinds of loops:

    for Loops
    while Loops
    do while Loops

Each of these loops has a slightly different structure, with different advantages for use in programming situations. We'll cover each separately and give you plenty of practice in using each style.
Recursion

Recursion is another form of iteration, and happens when a process calls itself over and over, until it reaches a base case condition. This type of structure can be very useful in a number of situations, especially when a loop cannot do the job, or can only do it with great difficulty.

Recursion can be a little difficult to understand at first, so give yourself plenty of time to think through and practice how it works.






Iterative Processing
What is Iterative Processing?

In iterative processing, program statements execute normally, until you reach a block of code that you would like to repeat over and over again. Using a loop control structure allows you to write code once and use it over and over, giving you different output. Loops contain a start, a check, an action, and a step. As long as the check is true, the action is repeated. Once the loop check evaluates to false, the looping action stops, and the program continues on to the next statement after the loop.

Iterative Processing
    The process in programming that uses loop based or recursive based control structures to repeat certain processes.
Loop
    A process in programming that repeats a process a certain number of times.
Four Parts of a Loop

        Start - every loop must start once.
        Check - the condition that is checked with each iteration, either before or after the action, to determine if the loop is to continue or stop.
        Action - the task that is repeated, which can be anything, even another loop.
        Step - a crucial part of the process, often controlled by a variable, either increasing or decreasing in value with each iteration of the loop, moving towards the condition which will become false and stop the looping process.

For Loop
    A loop structure in various programming languages where the start, check, and step are designated in parentheses immediately after the for, such as for(int x ← 1; x < 10; x ← x + 1).
While Loop
    A pretest loop in programming that checks a boolean condition before performing the action of the loop, and continues iterating while the condition is true.
Do While Loop
    This is a post test loop in programming where the action of the loop precedes the "check if true" expression, which decides whether or not the loop should continue.



PreTest vs PostTest

Remember that a pretest loop has the check at the beginning of a loop while a posttest loop puts the check at the end.

Examples of pretest loops are the for and the while loops.

The do while loop is an example of a posttest loop.

It is possible for a pretest loop to never run BUT a posttest loop will always run at least once.

Loop	                     Structure	                                            Pretest	                        Posttest
For Loop 	                 for (start;condition;step)
                            <block of action statements>
                              end for 	                                          Yes 	                          No

While Loop 	               while (condition)
                            <block of action statements>
                              end while 	                                        Yes 	                          No

Do While Loop 	           do {
                            <block of action statements>
                            } while (condition) 	                               No 	                            Yes









For Loop Practice
problem


Consider this snippet of code:
int x ← 18
for (int y ← 1; y ≤ 6; y ← y + 1)
  if (x > 9)
  	/*Missing If Body*/
  end if
end for

If the value of x at the end of this statement is 9, which of the following statements should replace /*Missing If Body*/?
x ← x - 2
x ← x - 4
x ← x - 3 correct
x ← x - 5

Explanation

The initial value of x is 18. The index variable y in the for statement increments by 1 from 1 to 6. The question for us is, what would the inside of the if statement need to look like such that, at the end of the code snippet, x is equal to 9.

A good technique in this case is to plug the numbers in to each option and see the results. In this case, the right answer is x ← x - 3. The steps would look like this:

    In the first iteration (y ← 1), x would be 18. Subtract 3 from x and x is now 15.
    In the second iteration (y ← 2), x would be 15. Subtract 3 from x and x is now 12.
    In the third iteration (y ← 3), x would be 12. Subtract 3 from x and x is now 9.

At this point, though the loop will continue to execute 3 more times (until y is equal to 7), x will remain at the value 9 because the if statement body will not execute because x is no longer greater than 9.


problem


Consider this snippet of code:
int tenthPower(num)
  int result ← 1
  for (int i ← 1; i ≤ 10; i ← i + 1)
    /*Missing For Body*/
  end for
  return result
end tenthPower
If the value of result at the end of the method call tenthPower(2) is 1024, which of the following statements should replace /*Missing For Body*/?
result ← result * i
result ← result - i
result ← result * num correct
result ← result / num

Explanation
The return method tenthPower is defined using the variable called result initialized to 1. The for loop with index variable i increments by 1 from 1 to 10. The question is this. What would the inside of the for loop need to look like such that the result variable is equal to 1024?

In this case, the right answer is result ← result * num.

The steps would look like this:
The beginning value of result is 1, and then the loop acts ten times, each time multiplying result times the value of num, the formal parameter.

During the first iteration of the loop, the value of result changes to 2.
During the second iteration of the loop, the value of result changes to 4, then 8, 16, 32, 64, 128, 256, 512, and finally on the tenth iteration, result becomes 1024.

The choice that says, "result ← result * i" would yield an answer of 1*1*2*3*4*5*6*7*8*9*10, which represents 10 factorial, and VERY large value, not 1024.

The choice that says, "result ← result - i" would yield an answer of 1-1-2-3-4-5-6-7-8-9-10, which is -54.

The choice that says, "result ← result / num" would yield an answer of 1/2/2/2/2/2/2/2/2/2/2, which is zero.


problem


What is the output of this loop process?
int x ← 0
for(x ← 14; x < 23 ; x ← x + 2)
	print "*"
end for
print x
****24
*****24 correct
****23
*****23
Explanation:
x is 14
* is printed
x is 16
* is printed
x is 18
* is printed
x is 20
* is printed
x is 22
* is printed
x is 24, which stops the loop
x is printed
loop stops


problem


Consider this snippet of code:
void fizzBuzz ()
  for(int x ← 10; x > 1; x ← x - 1)
    if (x % 3 == 0)
      print "Fizz "
    else if (x % 5 == 0)
      print "Buzz "
    else
      print x + " "
  end for
end main
What would be the output of the fizzBuzz method?
10 9 8 7 6 5 4 3 2
Buzz Fizz Buzz Fizz Buzz Fizz Buzz Fizz Buzz
Buzz Fizz 8 7 Fizz Buzz 4 Fizz 2 correct
2 3 4 5 6 7 8 9 10

Explanation

The void method called fizzBuzz contains a for loop that has a variable called x that is initialized at 10. While x is greater than 1, the for loop will decrement x down by 1.

Inside of the loop, the instructions are to print "Fizz " whenever the remainder of x divided by 3 is 0 (x % 3 == 0) print "Buzz " whenever the remainder of x divided by 5 is 0 (x % 5 == 0), and to just print out the value of x if those two cases don't apply. Therefore, the output of the method will be: Buzz Fizz 8 7 Fizz Buzz 4 Fizz 2. Remember that the loop will end when the x is 1 and the inside will not run.


problem


Consider this snippet of code:
int f(num)
  int result ← 1
  for (int i ← 1; i ≤ num; i ← i + 1)
    /*Missing For Body*/
  end for
  return result
end

If the value of result at the end of the method call f(5) is 120, which of the following statements should replace /*Missing For Body*/?
result ← result * num
result ← result - i
result ← result * i correct
result ← result / i

Explanation

The return method f is defined with the initial value of the integer variable result as 1. The for loop with control variable i starts at 1 and increments by 1 to 5 (the parameter passed in the method call). The question for us is, what would the inside of the for loop need to look like such that, at the end of the code snippet, the result variable is equal to 120?

In this case, the right answer is result ← result * i, which achieves the process called factorial. The steps would look like this:

    In the first iteration (i ← 1), result would be 1. Multiply result by i(1) and result is still 1.
    In the second iteration (i ← 2), result would be 1. Multiply result by i(2) and result is now 2.
    In the third iteration (i ← 3), result would be 2. Multiply result by i(3) and result is now 6.
    In the fourth iteration (i ← 4), result would be 6. Multiply result by i(4) and result is now 24.
    In the fifth iteration (i ← 5), result would be 24. Multiply result by i(5) and result is now 120.



problem


Consider this snippet of code:
void main ()
  for(int x ← 10; x > 1; x ← x - 1)
    print x + " "
  end for
end main

What would be the output of the main method?
10 9 8 7 6 5 4 3 2 1
1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 correct
2 3 4 5 6 7 8 9 10

Explanation

The void method called main contains a for loop that has a variable called x that is initialized at 10. While x is greater than 1, the for loop will decrement x down by one.

Inside of the loop, the instructions are to print x each time the loop runs. Therefore, the output of the method will be: 10 9 8 7 6 5 4 3 2. Remember that the loop will end when the x is 1 and the inside will not run.


problem


How many stars will be output by this loop?
int x ← 0
for(x ← 100 ; x < 10000000 ; x ← x * 10)
  print "*"
end for
5 correct
7
6
None
Infinitely many
Explanation:
x is 100
* is printed
x is 1000
* is printed
x is 10000
* is printed
x is 100000
* is printed
x is 1000000
* is printed
x is 10000000
loop stops


problem


How many times will the action statement happen in the loop shown?
for(int x ← 0 ; x ≤ 25 ; x ← x + 1)
	<action>
end for
24
25
26 correct
27
Explanation:
The 26 values that cause the "x ≤ 25" condition to be true are: 0 through 25.


problem


Consider this snippet of code:
int x ← 26
for (int y ← 1; y ≤ 10; y ← y + 1)
  if (x > 5)
  	/*Missing If Body*/
  end if
end for
If the value of x at the end of this statement is 6, which of the following statements should replace /*Missing If Body*/?
x ← x - 3
x ← x - 4
x ← x - 2 correct
x ← x - 5

Explanation

The initial value of x is 26. The index variable y in the for statement increments by 1 from 1 to 10. The question for us is, what would the inside of the if statement need to look like such that, at the end of the code snippet, x is equal to 6.

A good technique in this case is to plug the numbers in to each option and see the results. In this case, the right answer is x ← x - 2. The steps would look like this:

    In the first iteration (y ← 1), x would be 26. Subtract 2 from x and x is now 24.
    In the second iteration (y ← 2), x would be 24. Subtract 2 from x and x is now 22.
    In the third iteration (y ← 3), x would be 22. Subtract 2 from x and x is now 20.
    In the fourth iteration (y ← 4), x would be 20. Subtract 2 from x and x is now 18.
    In the fifth iteration (y ← 5), x would be 18. Subtract 2 from x and x is now 16.
    In the sixth iteration (y ← 6), x would be 16. Subtract 2 from x and x is now 14.
    In the seventh iteration (y ← 7), x would be 14. Subtract 2 from x and x is now 12.
    In the eigth iteration (y ← 8), x would be 12. Subtract 2 from x and x is now 10.
    In the ninth iteration (y ← 9), x would be 10. Subtract 2 from x and x is now 8.
    In the tenth iteration (y ← 10), x would be 8. Subtract 2 from x and x is now 6.

So x is equal to 6, while y is still within its bounds (y <= 10) and within the bounds of the if statement (x > 5).


problem


Consider this snippet of code:
int x ← 18
for (int y ← 8; y ≥ 8; y ← y - 1)
  if (x > 0)
  	/*Missing If Body*/
  end if
end for
If the value of x at the end of this statement is 9, which of the following statements should replace /*Missing If Body*/?
x ← x - 4
x ← x - 6
x ← x - 9 correct
x ← x - 7

Explanation

The initial value of x is 18. The index variable y in the for statement decrements by 1 from 8 to 7. Note that the set up of the for loop is such that this loop will only run one time, since once y becomes 7, the loop will no longer execute. The question for us is, what would the inside of the if statement need to look like such that, at the end of the code snippet, x is equal to 9.

In this case, the right answer is x ← x - 9. The steps would look like this:

    In the first iteration (y ← 8), x would be 18. Subtract 9 from x and x is now 9.

At this point, the loop will no longer execute since y is no longer greater than or equal to 8. So the final value of x will be 9.









While Loop Practice
problem

flowchart describing a simple program
Given the flowchart above, which of these loops describes the program?
int x ← 5
    int y ← 20
    while (y ≤ x)
      y ← y - 1
    end while
int x ← 20
    int y ← 5
    while (y ≥ x)
      y ← y - 1
    end while
int x ← 5
    int y ← 20
    while (y ≥ x)
      y ← y - 1
    end while correct
int x ← 5
    int y ← 20
    while (y > x)
      y ← y - 1
    end while

problem


What is output by this pseudocode segment?
int x ← 0
int sum ← 0
while(x < 6)
     sum ← sum + x
     x ← x + 1
end while
print sum
21
0
6
10
15 correct

Explanation:
sum is 0, x is 0
sum becomes 0, x becomes 1
sum becomes 1, x becomes 2
sum becomes 3, x becomes 3
sum becomes 6, x becomes 4
sum becomes 10, x becomes 5
sum becomes 15, x becomes 6
loop stops
The final value of sum (15) is printed


problem

void main ()
	int x ← 0
	while (x < 8)
  		x ← x + 2
  		print x + " "
  	end while
end main
What would be the output of the main method?
0 2 4 6
0 2 4 6 8
2 4 6 8 correct
2 4 6

Explanation

The void method called main contains a while loop that has a variable called x that is initialized at 0. While x is less than 8, the loop will execute.

The inside of the loop has the instructions to increment x by 2, then print the value of x every time the loop runs. Therefore, the output of this method will be 2 4 6 8. Note that x is incremented before being printed, so the method will not print 0. Since the value changes to 8, then prints before the check condition is false, the 8 is printed.


problem

flowchart describing a simple program
Given the flowchart above, which of these loops describes the program?
int j ← 5
    while (j ≤ 5)
      j ← j + 1
    end while
int j ← 5
    while (j ≥ 5)
      y ← j + 5
    end while
int j ← 5
    while (j ≤ 20)
      j ← j + 5
    end while correct
int j ← 5
    while (j > 20)
      j ← j - 5
    end while

problem


Which of these loop styles is considered a pretest loop?

I.	for
II.	while
III.	do while
I and II correct
All three
III only
II only
I only

Explanation:
Both the while and for loops check the condition before the action takes place, therefore are considered pretest loops.


problem


What is output by this pseudocode segment?
int x ← 10
int sum ← 0
while(x ≥ 0)
	sum ← sum - x
	x ← x - 1
end while
print sum
-45
45
55
No output due to an infinite loop
-55 correct

Explanation:
x is 10
sum is 0
sum becomes -10
x becomes 9
sum becomes -19
x becomes 8
sum becomes -27
x becomes 7
sum becomes -34
x becomes 6
sum becomes -40
x becomes 5
sum becomes -45
x becomes 4
sum becomes -49
x becomes 3
sum becomes -52
x becomes 2
sum becomes -54
x becomes 1
sum becomes -55
x becomes 0
sum becomes -55
x becomes -1
The final value of x is -1, which stops the loop
The final value of sum (-55) is printed


problem

void main ()
	int x ← 0
	while (x < 3)
  		print x + " "
  		x ← x + 2
  	end while
end main
What would be the output of the main method?
0 2 4
2
0 2 correct
2 4

Explanation

The void method called main contains a while loop that has a variable called x that is initialized at 0. While x is less than 3, the loop will execute.

Inside of the loop, the instructions are to print x and to increment x by 2 each time the loop runs. Therefore, the output of the method will be: 0 2. Remember that the loop will end when the x is 3 or greater and the inside will not run.


problem


Consider the following method:
int factorial (int num)
  int result ← 1
  for (int x ← 1; x ≤ num; x ← x + 1)
  	result ← result * x
  end for
  return result
end factorial
Which of the following loops would produce the same output as the for loop in the factorial method?
int x ← 1
    while (x ≤ num)
    	x ← x + 1
       	result ← result * x
    end while
int x ← 1
    while (x < num)
      result ← result * x
      x ← x + 1
    end while
int x ← 1
    while (x ≤ num)
      result ← result * x
      x ← x + 1
    end while correct
int x ← 0
    while (x ≤ num)
      result ← result * x
      x ← x + 1
    end while

Explanation

The return method factorial accepts the formal parameter num. Inside the method, an integer variable named result has been initialized to 1.

The factorial method contains a for loop that initializes the counter variable x to 1. While x is less than or equal to the value of num, the loop will execute and x will increment by 1.

Inside the loop, the result variable is assigned the current value of the result variable multiplied by the current value of x. At the end of the method, the value of result is returned.

If you use 3 as the num variable, this method works like this:

    The for loop will run from 1 until x is equal to 3.
    On the first iteration (x ← 1), results is equal to 1. Result will become 1 * 1 (1);
    On the second iteration (x ← 2), results is equal to 1. Result will become 1 * 2 (3);
    On the third iteration (x ← 3), results is equal to 2. Result will become 2 * 3 (6);

After x is equal to 3, the loop will no longer run, so the value of result will be 6. We need a while loop with same output. Of these choices,
int x ← 1
  while (x ≤ num)
  	result ← result * x
  	x ← x + 1
  end while

is the one that does the job.

If you plug the while loop into the method and use 3 for the num parameter, you will get the same result of 6.


problem


What is the output of this loop process?
int x ← 15
while(x < 20)
	print "*"
	x ← x + 1
end while
print x
*****20 correct
******20
*****19
******21

Explanation:
x is 15
* is printed
x becomes 16
* is printed
x becomes 17
* is printed
x becomes 18
* is printed
x becomes 19
* is printed
x becomes 20, which stops the loop
The final value of x (20) is printed


problem


Consider the following for loop:
for(int x ← 75; x > 40; x ← x - 5)
  	print x + " "
end for
Which of the following loops will produce the same output?
int x ← 80
    while (x > 40)
    	x ← x - 10
       	print x
    end while
int x ← 75
    while (x < 40)
      print x
      x ← x - 5
    end while
int x ← 80
    while (x > 45)
      x ← x - 5
      print x
    end while correct
int x ← 75
    while (x ≥ 40)
      print x
      x ← x - 10
    end while

Explanation

The for loop has a variable called x that is initialized at 75. While x is greater than 40, the for loop will decrement x by 5.

Inside of the loop, the instructions are to print x each time the loop runs. Therefore, the output of the loop will be: 75 60 65 60 55 50 45.

So we need a while loop with same output. Of these choices,
int x ← 80
  while (x > 45)
  	x ← x - 5
  	print x
  end while

is the one that does the job.

The variable x is initialized to 80. The while loop has the condition, while x is greater than 45. The inside of the loop has the instructions to decrement x by 5 and then to print x every time the loop is run. Because x is decremented before being printed, this will result in the same output as the for loop: 75 70 65 60 55 50 45.














Do While Loop Practice
problem


Consider the following method:
void main ()
  int x ← 10
  do {
    x ← x - 2
    print x + " "
  } while (x > 20)
end main
What would be the output of the main method?
10 8
Nothing
8 correct
10

Explanation

The void method called main contains a do while loop that has a variable called x that is initialized at 10. While x is greater than 20, the loop will execute, but this check does not take place until after the action.

Inside of the loop, the instructions are to decrement x by 2 and print the value of x each time the loop runs. The only output of the method will be 8, since the first check at the end of the loop is false. Remember that, in a do while loop, the do portion executes AT LEAST ONCE, even if the first check is false.


problem


Consider the following method:
void main ()
  int x ← 10
  do {
    print x + " "
    if (x > 5)
      x ← x - 5
    else
      x ← x - 2
  } while (x ≥ 0)
end main
What would be the output of the main method?
10 5 0
5 3 1 -1
10 5 3 1 correct
10 8 6 4 2 0

Explanation

The void method called main contains a do while loop that has a variable called x that is initialized at 10. While x is greater than or equal to 0, the body of the loop will act.

Inside of the do portion of the loop, the instructions are to print the value of x. There is also an conditional if/else statement which states that, if x is greater than 5, decrement x by 5. Otherwise (else) decrement x by 2. Therefore, the output of the method will be: 10 5 3 1. Note x will be printed before being decremented so that no negative numbers will be printed. although the final value of x is -1, which stops the loop process.


problem


Consider the following method:
void main ()
  int x ← 10
  do {
    x ← x - 2
  } while (x >= 0)
  print x + " "
end main
What would be the output of the main method?
10 8 6 4 2 0 -2
10 8 6 4 2 0
-2 correct
8 6 4 2 0

Explanation

The void method called main contains a do while loop that has a variable called x that is initialized at 10. While x is greater than or equal to 0, the loop will execute.

Inside of the loop, the instructions are to decrement x by 2 each time the loop runs. After the loop, the instructions are to print the value of x. Therefore, the output of the method will be -2. Note that no printing is taking place inside of the loop so the main method will only print the value of x once. Also remember that the loop will continue while x is greater than or equal to 0. This means that, even after x has reached 0, the inside of the loop will run one more time, which means the final value of x is -2.


problem


Which of these loop styles is considered a posttest loop?

I. for
II. while
III. do while
II only
All three
I only
III only correct
I and II

Explanation:
The do while loop is the only posttest loop structure that will be considered on the certification test. Some languages also have the repeat until loop, which is also a posttest loop, but this will not be tested on the exam.


problem


Consider the following for loop:
for(int x ← 100; x > 0; x ← x - 10)
  print x
end for
Which of the following loops will produce the same output?
int x ← 100
      do {
        x ← x - 10
        print x
      while (x > 0)
int x ← 100
      do {
        x ← x - 10
        print x
      while (x > 10)
int x ← 110
      do {
        x ← x - 10
        print x
      while (x > 10) correct
int x ← 110
      do {
        print x
        x ← x - 10
      while (x > 10)

Explanation

The for loop has a variable called x that is initialized at 100. While x is greater than 0, the for loop will decrement x by 10.

Inside of the loop, the instructions are to print x each time the loop runs. Therefore, the output of the loop will be: 100, 90, 80, 70, 60, 50, 40, 30, 20, 10.

So we need a while loop with same output. Of these choices,
int x ← 110
  do {
    x ← x - 10
    print x
  while (x > 10)

is the one that does the job.

The variable x is initialized to 110. The do while loop condition, while x is greater than 10, is checked at the end. The inside of the loop has the instructions to decrement x by 10 and then print the value of x every time the loop is run. This will result in the same output as the for loop: 100, 90, 80, 70, 60, 50, 40, 30, 20, 10.


problem

flowchart describing a simple program
Given the flowchart above, which of these loops describes the program?
int j ← -5
      do {
      	j ← j + 1
      	print j
      } while (j ≤ 0)
int j ← -5
      do {
      	print j
      	j ← j + 1
      } while (j ≥ 0)
int j ← -5
      do {
      	print j
      	j ← j + 1
      } while (j ≤ 0) correct
int j ← -5
      while (j < 0)
      	print j
      	j ← j + 1
      end while

Explanation

The program described in the flowchart initializes the variable j to -5. Then it prints the variable j and increments j by 1. The decision point asks, is j less than or equal to 0? If so, return to the step where the value of j is printed and start again. If not, stop the program.

The loop that describes this is:
int j ← -5
  do {
  	print j
  	j ← j + 1
  } while (j ≤ 0)

This loop intializes the variable j to -5. The do portion of the loop prints the value of j and then increments j by 1. The while statement in the loop has the condition, while j is less than or equal to 0. This would result in the same output. If the while condition was j < 0, then the last output of j would be 1 instead of 0. Note that the order of statements is important. If j is incremented BEFORE being printed, the output would be different.


problem


Consider the following while loop:
int x ← 10
while(x < 30)
  x ← x + 5
  print x + " "
end while
Which of the following loops will produce the same output?
int x ← 30
      do {
        print x + " "
        x ← x - 5
      while (x > 0)
int x ← 10
      do {
        print x + " "
        x ← x + 5
      while (x < 30)
int x ← 10
      do {
        x ← x + 5
        print x + " "
      while (x < 30) correct
int x ← 10
      do {
        x ← x + 5
        print x + " "
      while (x <= 30)

Explanation

The while loop has a variable called x that is initialized at 10. The condition being tested is: x less than 30.

Inside of the loop, the instructions are to increment x by 5, and then print the value of x. Therefore, the output of the loop will be: 15 20 25 30.

So we need a do while loop with same output. Of these choices,
int x ← 10
do {
  x ← x + 5
  print x + " "
while (x < 30)

is the one that does the job.

The variable x is initialized to 10. The while portion of loop has the condition, x less than 30. The do portion of the loop has the instructions to increment x by 5 and then print the value of x. This will result in the same output as the for loop: 15 20 25 30.


problem


What is the output of this loop process?
int x ← 15
do {
  x ← x + 1
  print "*"
} while(x ≤ 20)
print x
*****21
*****20
******21 correct
******20

Explanation:
x is 15
x becomes 16, * is printed
x becomes 17, * is printed
x becomes 18, * is printed
x becomes 19, * is printed
x becomes 20, * is printed
x becomes 21, * is printed
loop stops
21 is printed


problem


How many stars will be output by this loop?
int x ← 54
do {
  print "*"
  x ← x / 2
} while(x > 0)

6 correct
None
Infinitely many
5
7

Explanation:
x is 54
* is printed, x becomes 27
* is printed, x becomes 13
* is printed, x becomes 6
* is printed, x becomes 3
* is printed, x becomes 1
* is printed, x becomes 0
loop stops









All Loop Practice
problem

int f(num)
  int result ← 0
  for (int i ← num; i >= 1; i ← i - 1)
  	/*Missing For Body*/
  end for
  return result
end f

If the value of result at the end of the method call f(10) is 55, which of the following statements should replace /*Missing For Body*/?
result ← result * num
result ← result + num
result ← result + i correct
result ← result * i

Explanation

The return method f is defined with the variable result as an accumulator. With the for loop using the control variable i, it is initialized to the same value as num (10, in this case). The condition in the for statement checks to see if i is greater than or equal to 1. The variable i is decremented by 1 each time the loop runs. The question for us is, what would the inside of the for loop need to look like such that, at the end of the code snippet, the result variable is equal to 55?

In this case, the right answer is result ← result + i. The steps would look like this:

    In the first iteration (i ← 10), result would be 0. Add 10 to 0 and the result is 10.
    In the second iteration (i ← 9), result would be 10. Add 10 to 9 and the result is 19.
    In the third iteration (i ← 8), result would be 19. Add 19 to 8 and the result is 27.
    In the fourth iteration (i ← 7), result would be 27. Add 27 to 7 and the result is 34.
    In the fifth iteration (i ← 6), result would be 34. Add 34 to 6 and the result is 40.
    In the sixth iteration (i ← 5), result would be 40. Add 40 to 5 and the result is 45.
    In the seventh iteration (i ← 4), result would be 45. Add 45 to 4 and the result is 49.
    In the eigth iteration (i ← 3), result would be 49. Add 49 to 3 and the result is 52.
    In the ninth iteration (i ← 2), result would be 52. Add 52 to 2 and the result is 54.
    In the tenth iteration (i ← 1), result would be 54. Add 54 to 1 and the result is 55.



problem

int x ← 0
  for(int n ← 0; n < 5; n ← n + 1)
    x ← x + n
    print x + " "
  end for

What is output by the code segment shown?
1 3 6 10 15
1 2 3 4 5
0 1 3 6 10 correct
0 1 2 3 4 5

Explanation

The void method called main initializes the variables x to 0. Then a for loop defines the counter variable n to 0. The condition asks if n is less than 5. Each time the loop is run, n is incremented up by 1. The variable n is incremented up by 1. Inside of the loop, the variable x is incremented up by n. Then, the value of x is printed, with an output sequence of 0 1 3 6 10.


problem

int f(num)
  int result ← num
  while (result > 5)
  	/*Missing While Body*/
  end while
  return result
end f

If the value of result at the end of the method call f(10) is 4, which of the following statements should replace /*Missing For Body*/?
result ← result + num
result ← result - num
result ← result - 2 correct
result ← result + 2

Explanation

The return method f is then defined. Inside it has a while loop. The integer variable result is initialized to the same value as the formal parameter num. The condition in the while statement checks to see if result is greater than 5. The question for us is, what would the inside of the while loop need to look like such that, at the end of the code, the result variable is equal to 4?

In this case, the right answer is result ← result - 2. The steps would look like this:

    In the first iteration, result would be 10. Subtract 2 from 10 and result would be 8.
    In the second iteration, result would be 8. Subtract 2 from 8 and result would be 6.
    In the third iteration, result would be 6. Subtract 2 from 6 and result would be 4.

At this point, result is no longer greater than 5, so result at the end of the code is 4.


problem

for (/*start; check; step*/)
  	print "I will not skateboard in the halls"
  end for

If the statement "I will not skateboard in the halls" prints 500 times, which of the following statements should replace /*start; check; step*/?
int x ← 0; x ≤ 500; x ← x + 1
int x ← 1; x < 500; x ← x + 1
int x ← 0; x < 500; x ← x + 1 correct
int x ← 0; x > 500; x ← x + 1

Explanation

The body of the for loop contains a print statement, print "I will not skateboard in the halls." The question for us is, what would the start, condition, and step portion of the for loop need to look like, such that, at the end of the code snippet, the print statement is executed 500 times?

Of these choices, the right solution is int x ← 0; x < 500; x ← x + 1;

x is initialized to 0. While x is less than 500, then x will increment up by 1. This means that the loop will run 500 times (from 0 to 499).


problem

flowchart describing a simple program
Given the flowchart above, which of these loops describes the program?
int x ← 5
      for (int y ← 20; x < y; y++)
        y ← y - 4
        print y
      end for
int x ← 5
      int y ← 20
      while (x <= y)
        y ← y - 4
      end while
int x ← 5
      int y ← 20
      while (y > x)
      	y ← y - 4
      end while correct
int x ← 5
      int y ← 20
      do {
      	y ← y - 4
      } while (y <= x)
      print y

Explanation

This one is a bit tricky. The program described in the flowchart initializes the variable x to 5 and the variable y to 20. The decision point in the flowchart asks, is y less than or equal to x? If so, stop, otherwise decrement y by 4 and return to the decision point, and continue until the loop stops. The right answer choice does a double reverse in the logic, checking to see if y is greater than x (the opposite of the flowchart condition), decrementing by 4 if yes (also opposite the flowchart action), stopping if not, effectively doing the same thing as the flowchart.

The loop that describes this is:
int x ← 5
      int y ← 20
      while (y > x)
      	y ← y - 4
      end while

This produces the same logic as the flowchart.


problem


Consider the following method:
void main ()
  int x ← 15
  do {
    if (x > 12)
      x ← x - 5
    else
      x ← x - 3
    print x
  } while (x >= 0)
end main
Which of the following loops will produce the same output?
for ( int x ← 15; x >= 1; x ← x - 3 )
      print x
      x ← x - 5
      end for
int x ← 15
      while ( x > 0 )
      	if (x > 12)
          x ← x - 5
          print x
      	else
          x ← x - 3
      	end if
      end while
int x ← 15
      while ( x >= 0 )
      	if (x > 12)
          x ← x - 5
      	else
          x ← x - 3
      	end if
      	print x
      end while correct
for ( int x ← 15; x >= 0; x ← x - 5 )
      	x ← x - 5
      	print x
      end for

Explanation

The void method called main contains a do while loop that has a variable called x that is initialized at 15. While x is greater than or equal to 0, the loop will execute.

Inside of the do portion of the loop, there is also an conditional if/else statement which states that, if x is greater than 12, decrement x by 5. Otherwise (else) decrement x by 3. The value of x is then printed each time. Therefore, the output of the method will be: 10 7 4 1 -2.

So we need a while loop with same output. Of these choices,
int x ← 15
while ( x >= 0 )
  if (x > 12)
    x ← x - 5
  else
    x ← x - 3
  end if
  print x
end while

is the one that does the job.

The variable x is initialized to 15. The while loop has the condition, while x is greater than or equal to 0. The inside of the loop has an if/else statement. If x is greater than 12, decrement x down by 5. Otherwise, decrement x down by 3. This results in the same output: 10 7 4 1 -2.


problem


  int n ← 0
  int x ← 0
  while(n < 5)
    n ← n + 1
    x ← x + n
    print x + " "
  end while

What is the output of the code segment shown?
0 1 3 6 10 15
1 2 3 4 5
1 3 6 10 15 correct
0 1 2 3 4 5

Explanation

The void method called main initializes the variables n and x to 0. Then a while loop is defined with the condition: while n is less than 5. The variable n is incremented by 1 and the variable x is incremented by n. Then the value of x is printed, which makes the output 1 3 6 10 15.


problem


Consider the following while loop:
int x ← 10
while(x < 20)
  if (x % 5 == 0)
    x ← x + 2
  else
  	x ← x + 5
  end if
  print x
end while
Which of the following loops will produce the same output?
int x ← 10
      for(x % 5 == 0; x < 20; x ← x + 2)
        x ← x + 5
      	print x
      end for
int x ← 10
      do {
        print x
        if (x % 5 == 0)
          x ← x + 2
        else
          x ← x + 5
        end if
      } while (x < 20)
int x ← 10
      do {
        if (x % 5 == 0)
          x ← x + 2
        else
          x ← x + 5
        end if
        print x
      } while (x < 20) correct
int x ← 10
      for(x; x % 5 == 0; x ← x + 5)
        print x
      end for

Explanation

The while loop has a variable called x that is initialized at 10. The condition is: while x is less than 20.

Inside of the loop, there is an if/else statement. If x mod 5 is equal to 0, increment x up by 2. Otherwise, increment x up by 5.

So we need another loop with same output. Of these choices,
int x ← 10
do {
  if (x % 5 == 0)
    x ← x + 2
  else
    x ← x + 5
  end if
  print x
} while (x < 20)

is the one that does the job.

The variable x is initialized to 10. The while portion of loop has the condition while x is less than 20. The do portion of the loop has there is an if/else statement. If x mod 5 is equal to 0, increment x by 2. Otherwise, increment x by 5. Notice that, in this instance, the structure of the do while loop mimics the structure of the while loop.


problem

flowchart describing a simple program
Given the flowchart above, which of these loops describes the program?
int books ← 12
      for (int read ← 0; read < 12; read++)
        if (read == books)
          print "You've read " + books + " books."
        end if
      end for
int read ← 0
      int books ← 12
      while (read <= books)
        print "You've read " + read + " books."
      	read ← read + 1
      end while
int books ← 12
      for (int read ← 0; read < books; read ← read + 1)
        if (read == books)
          print "You've read " + books + " books."
        end if
      end for

          int read ← 0
      int books ← 12
      do {
      	    read ← read + 1
      } while (read < books)
      print "You've read " + read + " books."
        correct

Explanation

The program described in the flowchart initializes the variable read to 0, and the variable books to 12. Then it increments read by 1. The decision point asks, is read equal to books? If so, print the concatenation "You've read " + books + " books." If not, return to the point where read is incremented by 1 and start again. The final values of read and books is 12.

The loop that describes this is:
int read ← 0
      int books ← 12
      do {
      	    read ← read + 1
      } while (read < books)
      print "You've read " + read + " books."

This loop intializes the variable books to 12 and read to 0. The do while statement increments read by 1 while read is less than books. As soon as the two values are equal, the while condition evaluates to false, and the output statement is printed, "You've read 12 books.", and both read and books have values of 12.















Recursion Basics
Recursion
    Recursion in computer science is a method where the solution to a process involves that process calling another instance of itself, stacking up process calls over and over again, moving towards a base case, at which time the unstacking process happens and the entire recursive process is concluded.
Base Case
    The terminating scenario or situation in recursive programming that does not use recursion to produce an answer.
Recursive Case
    One of two situations in a recursive method, the other being the base case, where another method call is made, moving closer and closer to the base case, which terminates the recursive process and unstacks all previously called methods, until a final value is achieved.



if(condition is true)
    base case
else
    recursive call

so in dumb logic no base case, there is infinite recursion, memory is used up and had to reboot the computer!!!

ex
void doStuff(int x)
    if(x > 0)
          doStuff(x-1)
    print x
end doStuff
void main
    doStuff(3)
end main

The call to doStuff(3) immediately calls doStuff(2) which immediately calls
doStuff(1), which immediately calls doStuff(0).
Now, when we get to doStuff(0) the if condition is false,
the action for the if just doesn't happen and we simply print 0.
doStuff(0)'s job is done, control goes back to doStuff(1)
which can finish print 1, then doStuff(2) can finish print 2,
then doStuff(3) can finish print 3, and now the whole process is finished.

result is 0 1 2 3




Loops vs Recursion

Remember that anything that a loop can do, recursion can do, but NOT the other way around. Some tasks are more efficiently and more easily coded as a recursive process.
Both repeat things in a program, just in different ways.
Recursion defines a method that calls itself using an 'if else' statement
Loops generally use control variables but sometimes use other Boolean events
to eventually stop the process.
Loops are memory efficient.
Recursion is a memory hog.
Anything done by a loop can also be done by a recursion.
However not everything done by recursion can be done by a loop.
In general when you can, use a loop.
Otherwise, use recursion.

In general, use a loop whenever possible.
	                                                     Loops	Recursion
Used to repeat a block of code 	                       Yes 	Yes
Memory intensive (uses a lot of computer memory) 	     No 	Yes
Can do anything the other can do 	                     No 	Yes












Recursion Practice
problem


Consider the following method:
int f ( int x )
    if (x ≤ 1)
    	return 1
    else
    	return x + f(x - 2)
    end if
end f

What is returned by the call below?
f( 4 )

0
2
7 correct
4

Explanation

Method f takes in the actual parameter 4. Inside of the method, that value becomes the formal parameter x. The method returns 7.

The function works out this way:

    f(4) = 4 + f(2) = ?
    f(2) = 2 + f(0) = ?
    f(0) = 1
    f(2) = 2 + f(0) = 2 + 1 = 3
    f(4) = 4 + f(2) = 4 + 3 = 7

So, f(4) = 7


problem


Consider the following method:
int f ( int value, int divisor )
    if (divisor == 0)
    	return 0
    if (value < divisor )
    	return value
    return f(value - divisor, divisor)
    end if
end f

What is returned by the call below?
f( 10, 3 )

10
0
1 correct
3

Explanation

Method f takes in the actual parameters 10 and 3. Inside of the method, those values become the formal parameters value and divisor, respectively. The method returns 1, the remainder of 10/3.

The function works out this way:

    f(10, 3) = f(7, 3) = ?
    f(7, 3) = f(4, 3) = ?
    f(4, 3) = f(1, 3) = ?
    f(1, 3) = 1
    f(4, 3) = f(1, 3) = 1
    f(7, 3) = f(4, 3) = 1
    f(10, 3) = f (7, 3) = 1

So f(10, 3) is 1.


problem

Which control structure listed below is the primary one used in a recursive method?
Sequential processing
if else statement correct
Loop
Switch statement
All of these

Explanation:
The if else statement is the key control structure for recursive methods.


problem


Consider the following method:
int f ( int x, int y )
    if (x > y)
    	return f(x - y, y + 1) + 2
    else
    	return x + y
    end if
end f

What is returned by the call below?
f( 11, 3 )

5
10
13 correct
26

Explanation

Method f takes in the actual parameters 11 and 3. Inside of the method, those values becomes the formal parameters x and y. The method returns 13.

The function works out this way:

f(11, 3) = f(11 - 3, 3 + 1) + 2

We figure out the values for all of the necessary recursive steps:

    f(11, 3) = f(8, 4) + 2 = ?
    f(8, 4) = f(4, 5) + 2 = ?
    f(4, 5) = 4 + 5 = 9
    f(8, 4) = f(4, 5) + 2 = 9 + 2 = 11
    f(11, 3) = f(8, 4) + 2 = 11 + 2 = 13

So f(11, 3) is 13.


problem


Consider the following method:
void f ( int x )
    print x
    if (x > 1)
    	f(x - 1)
    end if
end f

What is the output of the call below?
f( 3 )

1
1 2 3
3 2 1 correct
0

Explanation

Method f is called with the actual parameter 3, which is received using the formal parameter x. The method prints 3 2 1.

The function works out this way:

    f(3) = print 3, call f(2)
    f(2) = print 2, call f(1)
    f(1) = print 1 and done



problem


What is output by this pseudocode segment?
int f(int x, int y)
   if(y == 1)
      return x
   else
      return x * f(x, y - 1)
   end if
end f
//client code
print f(3, 5)

243 correct
81
27
9
3
Explanation:
f(3,5) = 3 * f(3,4) = ?
f(3,4) = 3 * f(3,3) = ?
f(3,3) = 3 * f(3,2) = ?
f(3,2) = 3 * f(3,1) = ?
f(3,1) = 3
f(3,2) = 3 * f(3,1) = 3 * 3 = 9
f(3,3) = 3 * f(3,2) = 3 * 9 = 27
f(3,4) = 3 * f(3,3) = 3 * 27 = 81
f(3,5) = 3 * f(3,4) = 3 * 81 = 243



problem


Consider the following method:
int power ( int base, int exponent )
    if (exponent == 0)
    	return 1
    else
    	return base * power(base, exponent - 1)
    end if
end power

What is returned by the call below?
power( 2, 3 )

9
16
8 correct
3

Explanation

Method power takes in the actual parameters 2 and 3. Inside of the method, those values become the formal parameters base and exponent, respectively. The method returns 8, the result of 2^3(2 to the 3rd power).

The function works out this way:

    power(2, 3) = 2 * power(2,2) = ?
    power(2, 2) = 2 * power(2,1) = ?
    power(2, 1) = 2 * power(2,0) = ?
    power(2, 0) = 1
    power(2, 1) = 2 * power(2,0) = 2 * 1 = 2
    power(2, 2) = 2 * power(2,1) = 2 * 2 = 4
    power(2, 3) = 2 * power(2,2) = 2 * 4 = 8

So the value of power(2, 3) is 8.


problem


What is output by this pseudocode segment?
int f(int x)
   if(x>5)
       return f(x-4)+1
   else
       return 2
   end if else
end f
print f(20)
6 correct
7
8
9
10

Explanation:

f(20) = f(16) + 1 = ?
f(16) = f(12) + 1 = ?
f(12) = f(8) + 1 = ?
f(8) = f(4) + 1 = ?
f(4) = 2
f(8) = f(4) + 1 = 2 + 1 = 3
f(12) = f(8) + 1 = 3 + 1 = 4
f(16) = f(12) + 1 = 4 + 1 = 5
f(20) = f(16) + 1 = 5 + 1 = 6


problem


Consider the following method:
int f ( int a, int b )
    int remainder = a % b
    if (remainder == 0)
    	return b
    else
    	return f(b, remainder)
    end if
end f

What is returned by the call below?
f( 15, 27 )

0
5
3 correct
10

Explanation
This is the recursive version of Euclid's famous algorithm for finding the greatest common divisor between two integers. Method f takes in the actual parameters 15 and 27. Inside of the method, those values become the formal parameters a and b, respectively. The method returns 3, the greatest common denominator of 15 and 27.
Here is the sequence:
Assign to remainder the modulus of 15 and 27, which is 15.
Since the remainder is NOT zero, f(27, 15) is called.
The remainder gets the modulus value of 27 and 15 is 12, which generates the call to f(15,12).
The remainder gets the modulus of 15 and 12 is 3, and then f(12,3) is called.
Since the modulus of 12 and 3 is zero, 3 is returned as the answer, all the way back up the stack call chain.
So f(15, 27) is 3.


problem


What is output by this pseudocode segment?
int f(int x)
   if(x > 10 AND x ≤ 20)
      return f(x + 1) + 4
   else
   if(x ≤ 10)
      return f(2 * x) - 1
   else
      return 2
   end if else chain
end f
print f(2)
19 correct
22
2
-1
10

Explanation:
f(2) = f(4) - 1 = ?
f(4) = f(8) - 1 = ?
f(8) = f(16) - 1 = ?
f(16) = f(17) + 4 = ?
f(17) = f(18) + 4 = ?
f(18) = f(19) + 4 = ?
f(19) = f(20) + 4 = ?
f(20) = f(21) + 4 = ?
f(21) = 2
f(20) = f(21) + 4 = 2 + 4 = 6
f(19) = f(20) + 4 = 6 + 4 = 10
f(18) = f(19) + 4 = 10 + 4 = 14
f(17) = f(18) + 4 = 14 + 4 = 18
f(16) = f(17) + 4 = 18 + 4 = 22
f(8) = f(16) - 1 = 22 - 1 = 21
f(4) = f(8) - 1 = 21 - 1 = 20
f(2) = f(4) - 1 = 20 - 1 = 19







Optional For Loop Practice
problem


What is the output of the code segment shown below?

  for(int x ← 0; x < 3; x ← x + 1)
    print x + " "
  end for
0 1 2 3
1 2 3
0 1 2 correct
1 2

Explanation

The void method called main contains a for loop that has a variable called x that is initialized at 0. While x is less than 3, the for loop will increment x by one.

Inside of the loop, the instructions are to print x each time the loop runs. Therefore, the output of the method will be: 0 1 2. Remember that the loop will end when the x is 3 which causes the check condition to be false.


problem


What is the output of the code segment shown below?
for(int x ← 100; x > 0; x ← x - 10)
    print x + " "
  end for
90 80 70 60 50 40 30 20 10
10 20 30 40 50 60 70 80 90 100
100 90 80 70 60 50 40 30 20 10 correct
100 90 80 70 60 50 40 30 20 10 0

Explanation

The for loop control variable x is initialized to 100. While x is greater than 0, the for loop will decrement x by 10.

Inside of the loop, the instructions are to print x each time the loop runs. Therefore, the output will be: 100 90 80 70 60 50 40 30 20 10. Remember that the loop will stop once x is equal to 0 and the action will not execute.


problem


What is the output of the code segment shown below?
for(int x ← 0; x ≤ 15; x ← x + 5)
    print x + " "
  end for
0 5 10
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
0 5 10 15 correct
0 1 2 3 4 5 10 15

Explanation

The for loop control variable x is initialized at 0. While x is less than or equal to 15, the for loop will increment x by 5.

Inside of the loop, the instructions are to print x each time the loop condition is true. Therefore, the output of the method will be: 0 5 10 15. Remember that the loop will run even when x is equal to 15.








Optional While Loop Practice
problem

void main ()
	int x ← 0
	while (x > 3)
  		print x + " "
  		x ← x + 2
  	end while
end main
What would be the output of the main method?
0 2 4
0 2
Nothing correct
2 4

Explanation

The variable x is initialized to 0. While x is greater than 3, the loop will act.

However, in this case, the while loop will never act because x is 0, which causes the check condition to be false, so the output will be nothing.


problem

flowchart describing a simple program
Given the flowchart above, which of these loops describes the program?
int x ← 25
    int y ← 5
    while (y < x)
      y ← y - 5
    end while
int x ← 25
    int y ← 5
    while (y ≥ x)
      y ← y + 5
    end while
int x ← 25
    int y ← 5
    while (y ≤ x)
      y ← y + 5
    end while correct
int x ← 25
    int y ← 5
    while (y > x)
      y ← y + 5
    end while

Explanation

The program described in the flowchart initializes the variable x to 25, and the variable y to 5. The decision point asks, is y greater than x? If so, stop the program. If not, increment y by 5 and return to the decision point.

The loop that describes this is:
int x ← 25
int y ← 5
  while (y ≤ x)
  	y ← y + 5
  end while

This loop intializes the variable x to 25 and the variable y to 5. The while loop has the condition, while y is less than or equal to x (which is the opposite of asking if y is greater than x). While y is less than or equal to x, then the variable y will be incremented up by 5.


problem


Consider the following for loop:
for(int x ← 100; x > 0; x ← x - 10)
  	print x
end for
Which of the following loops will produce the same output?
int x ← 100
    while (x > 0)
    	x ← x - 10
       	print x
   end while
int x ← 100
    while (x < 0)
      print x
      x ← x - 10
    end while
int x ← 100
    while (x > 0)
      print x
      x ← x - 10
    end while correct
int x ← 110
    while (x > 0)
      print x + " "
      x ← x - 10
    end while

Explanation

The for loop has a variable called x that is initialized at 100. While x is greater than 0, the for loop will decrement x by 10.

Inside of the loop, the instructions are to print x each time the loop runs. Therefore, the output of the loop will be: 100 90 80 70 60 50 40 30 20 10.

So we need a while loop with same output. Of these choices,
int x ← 100
  while (x > 0)
  	print x
  	x ← x - 10
  end while

is the one that does the job.

The variable x is initialized to 100. The while loop has the condition, while x is greater than 0. The inside of the loop has the instructions to print the value of x and then to decrement x down by 10 every time the loop is run. This will result in the same output as the for loop: 100 90 80 70 60 50 40 30 20 10.


problem

void main ()
	int x ← 0
	while (x < 3)
  		print x + " "
  		x ← x - 1
  	end while
end main
What would be the output of the main method?
0 1 2
0
Infinite Loop correct
Nothing

Explanation

The void method called main contains a while loop that has a variable called x that is initialized at 0. While x is less than 3, the loop will execute.

Inside the loop, the instructions are to print x and then decrement x by 1 every time the loop runs. This loop will never stop executing because x will never be 3 or greater. This will produce an infinite loop.


problem


How many times will the action statement happen in the loop shown?
int x ← 23
while(x < 23)
	<action>
	x ← x + 1
end while
1
2
3
4
0 correct

Explanation:
Since the initial value of x causes the "x < 23" condition to be false, this loop will not act at all.






problem


Consider the following method:
void main ()
 int x ← 0
 do {
   print x + " "
   x ← x + 2
 } while (x ≤ 3)
end main
What would be the output of the main method?
0 2 4
2
0 2 correct
2 4

Explanation

The void method called main contains a do while loop that has a variable called x that is initialized at 0. While x is less than or equal to 3, the loop will execute.

Inside of the loop, the instructions are to print x and to increment x by 2 each time the loop runs. Therefore, the output of the method will be: 0 2. Remember that the loop will end when the x is 3 or greater and the inside will not run. This means that, although x is equal to 4 at the end of the method, the loop will not print that value of x.


problem


Consider the following while loop:
int count ← 1
while(count < 5)
 print "Count is: " + count
 count ← count + 1
end while
Which of the following loops will produce the same output?
int count ← 1
     do {
       print "Count is: " + count
       count ← count + 1
     } while (count <= 5)
int count ← 0
     do {
       print "Count is: " + count
       count ← count + 1
     } while (count < 4)
int count ← 0
     do {
       count ← count + 1
       print "Count is: " + count
     } while (count < 4) correct
int count ← 1
     do {
       count ← count + 1
       print "Count is: " + count
     } while (count <= 4)

Explanation

The while loop has a variable called count that is initialized at 1. The condition is: while count is less than 5.

Inside of the loop, the instructions are to print the concatenation of "Count is: " with the value of count and then to increment count by 1 each time the loop runs. Therefore, the output of the loop will be: "Count is: 1", "Count is: 2", "Count is: 3", "Count is: 4".

So we need a do while loop with same output. Of these choices,
int count ← 0
     do {
       count ← count + 1
       print "Count is: " + count
     } while (count < 4)

is the one that does the job.

The variable count is initialized to 0. The while statement has the condition, while count is less than 4. The do portion of the loop has the instructions to increment count by 1 and then print the concatenation of "Count is: " and the value of count every time the loop is run. This will result in the same output as the while loop: "Count is: 1", "Count is: 2", "Count is: 3", "Count is: 4". Notice that, though count begins at 0, it is incremented up BEFORE it is printed, resulting in the same output.





Recursion Optional Practice
problem


Consider the following method:
int f ( int x )
    if (x == 0)
    	return 1
    else if (x > 0)
    	return 0
    else
    	return 2 * f(x + 2) - f(x + 1) + 1
    end if
end f

What is returned by the call below?
f(-5 )

1
-5
-12 correct
0

Explanation

We figure out the values for all of the necessary recursive steps:

    f(-5) = 2 * f(-3) - f(-4) + 1 = ?
    f(-4) = 2 * f(-2) - f(-3) + 1 = ?
    f(-3) = 2 * f(-1) - f(-2) + 1 = ?
    f(-2) = 2 * f(0) - f(-1) + 1 = ?
    f(-1) = 2 * f(1) - f(0) + 1 = ?
    f(1) = 0
    f(0) = 1
    f(-1) = 2 * f(1) - f(0) + 1 = 2 * 0 - 1 + 1 = 0 - 1 + 1 = 0
    f(-2) = 2 * f(0) - f(-1) + 1 = 2 * 1 - 0 + 1 = 2 - 0 + 1 = 3
    f(-3) = 2 * f(-1) - f(-2) + 1 = 2 * 0 - 3 + 1 = 0 - 3 + 1 = -2
    f(-4) = 2 * f(-2) - f(-3) + 1 = 2 * 3 - -2 + 1 = 6 + 2 + 1 = 9
    f(-5) = 2 * f(-3) - f(-4) + 1 = 2 * -2 - 9 + 1 = -4 - 9 + 1 = -12



problem


Consider the following method:
int f ( int x )
    if (x == 1)
    	return 1
    else
    	return x + f(x - 1)
    end if
end f

What is returned by the call below?
f(4)

9
6
10 correct
5

Explanation

Method f takes in the actual parameter 4. Inside of the method, that value becomes the formal parameter x. The method returns 10.

The function works out this way:

    f(4) = 4 + f(3) = ?
    f(3) = 3 + f(2) = ?
    f(2) = 2 + f(1) = ?
    f(1) = 1
    f(2) = 2 + f(1) = 2 + 1 = 3
    f(3) = 3 + f(2) = 3 + 3 = 6
    f(4) = 4 + f(3) = 4 + 6 = 10

So f(4) is 10


problem


Consider the following method:
int f ( int x )
    if (x == 0)
    	return 1
    else if (x == 1)
    	return 2
    else
    	return f(x - 1) * f(x - 2)
    end if
end f

What is returned by the call below?
f( 4 )

12
4
8 correct
10

Explanation

Method f takes in the actual parameter 4. Inside of the method, that value becomes the formal parameter x. The method returns 8. Here's how it works.
f(4) = f(3) * f(2) = ?
f(3) = f(2) * f(1) = ?
f(2) = f(1) * f(0) = ?
f(1) = 2
f(0) = 1
f(2) = f(1) * f(0) = 2 * 1 = 2
f(3) = f(2) * f(1) = 2 * 2 = 4
f(4) = f(3) * f(2) = 4 * 2 = 8


problem


Consider the following method:
int f ( int x )
    if (x == 1)
    	return 1
    else
    	return x * f(x - 1)
    end if
end f

What is returned by the call below?
f(5)

105
15
120 correct
520

Explanation

The function works out this way:

    f(5) = 5 * f(4) = ?
    f(4) = 4 * f(3) = ?
    f(3) = 3 * f(2) = ?
    f(2) = 2 * f(1) = ?
    f(1) = 1
    f(2) = 2 * f(1) = 2 * 1 = 2
    f(3) = 3 * f(2) = 3 * 2 = 6
    f(4) = 4 * f(3) = 4 * 6 = 24
    f(5) = 5 * f(4) = 5 * 24 = 120







Arrays

Arrays are a really important data structure that you will use over and over again in programming. Arrays can be either 1-dimensional or multi-dimensional (arrays of arrays). We'll cover both of these, how to access the data, and how you would process arrays using loops. The memory used by an array is static, not able to change size once declared, but easy to access since it is in contiguous (side-by-side) memory.
Stacks and Queues

Stacks and Queues are both quite similar to arrays but have some special rules that apply to them. We'll cover the differences between these two structures and give you practice in using the methods that manage the data inside of these: push, pop, and peek.
Linked Lists

Linked lists are also quite similar to arrays, but don't use contiguous memory (that is, it doesn't use memory that is side by side). The up side of this is that they are flexible, able to grow or shrink in size.  The down side is that they are a bit more difficult to manage.  We'll discuss how linked lists work and have a look at some pseudocode that would create a linked list.
Binary Trees

Binary trees will be an important data structure to know when we move on to looking at binary search trees and heaps. We'll look at how binary trees work, how to traverse (travel between the nodes of) binary trees, have a look at binary search trees, and look at special binary trees called heaps.
Graphs

Graphs are another special data structure, similar to trees, but this is one that we'll only cover at a high level, learning about the general theory, but not really getting into real code.





1D Arrays, Terms, Guided Practice
Array (1D)
    A linear collection of data items in a program, all of the same type, such as an array of integers or an array of strings, stored in contiguous memory, and easily accessed using a process called indexing.
Array length
    A value that represents the number of elements contained in an array.  Often there is a process associated with an array that provides this value, such as list.length, or len(list).
Array Index
    A value that indicates the position in the array of a particular value. In many languages, and for the purpose of this course and for the certification test, the index of the first element of an array is zero. The index value of the first element in the array is zero. Therefore, the array index value of the element in position zero, the first position of the array, is zero. The index value for the last element of a zero-indexed array would be the length of the array, minus 1. For example, and array with 10 elements has the first element in position zero, and the last element in position 9.
Contiguous Memory
    Memory that is "side-by-side" in a computer, typical of an array structure.
Static Memory
    Memory allocated to an array, which cannot grow or shrink once declared.

You need to know how to process an array,
specifically how to create one with the data type that you need,
use a length method or process to check to see how many elements it contains,
to access individual elements --
either to use them in a process or to change the element value,
and then use a loop to access all of the elements in the array --
Linear Data Structure
    A programming data structure that occupies contiguous memory, such as an array of values.

Array Indices and Elements

Elements in an array are accessed through their indices (plural for index). It's like looking up a file by its order in a folder. Remember, in most programming languages, arrays are based on a 0-index system. The first element in the array is at position (index) 0 NOT 1, and the last element is in position length-of-the-array, minus 1.

Array Indices   0 1 2 3 4
Array Elements  1 2 3 4 5


Declaring and Initializing arrays

A simple way of initializing an array is shown below:

int [] list1 ← {4,2,7,5,1,9}

Here is a way to declare an initially empty array, containing all zero values by default:

int [] list2 ← new int [5]

------------------------------------------------------
Exercise 1 (answer below) - Write a statement to initialize an integer array called nums
with 6 random single digit positive integer values of your own choosing.
Exercise 2 - Write a statement to declare an array called vals that can contain
ten float values, initially all zero.
Exercise 3 - Write a statement to initialize an array called lets that contains all of
the unique characters of your first name.
Exercise 4 - Write a statement to declare an array called names that can contain
1000 first names. (Hint: Think carefully about the type of data that can contain someone's name.)
------------------------------------------------------

Finding the length of an Array

To find and use the length of an existing array, most languages use a method like len, which receives the array as a parameter and returns the length of the array, like this:

print len(list1)           ...resulting in an output of...6

Some languages have a feature that belongs to an array designating the length of that array, called using dot notation, like this:

print list2.length           ...resulting in an output of...5

------------------------------------------------------
Exercise 5 - Using a method called len which receives an array as a parameter, write the statement that prints the length of an array called names.
Exercise 6 - Using the length feature as described above, write the command using dot notation that assigns to an integer called num the length of an array called parts.

------------------------------------------------------

Output

To output an element of an array, such as the first element in list1 declared and initialized above, is to do this:
     print list1[0]           ...resulting in an output of...4
To output the last element of an array, such as the last element in list1 declared and initialized above, is to do this:
     print list1[5]
or
     print list1[len(list1)-1]
or
     print list1[list1.length-1]
     ...all resulting in an output of...9

One common task when creating programs is to loop through the elements of an array and do something with them. Most often, this is done using a for loop. For example:

int [] list ← {1,2,3,4,5}
for ( int x ← 0; x < list.length; x ← x + 1 )
 print list[x]
end for

where the command list.length returns the length of the array.

The reason you can do this is because you can access elements of an array using their index.

------------------------------------------------------

Exercise 7 - Assuming the declaration of an array called stuff that can contain 50 elements, write a statement that outputs the first element of this array.
Exercise 8 - Using the same array stuff mentioned above, write a statement that outputs the fourth element of this array.
Exercise 9 - Using the same array stuff mentioned above, assign to a variable called end the value in the final position of the array.
Exercise 10 - Write a statement that assigns to position 10 of the stuff array the value 25.
Exercise 11 - Write a statement that assigns to the first position of the stuff array the value of the element in position 7 of the array.
Exercise 12 - Again using the stuff array, write a loop that prints all of the values in the array from front to back.

------------------------------------------------------

Answers to Exercises

Exercise 1:   int [] nums ← {4, 2, 7, 6, 1, 3} //values may vary
Exercise 2:   float [] vals ← new float[10]
Exercise 3:   char [] lets ← {'J', 'O', 'H', 'N'}
Exercise 4:   string [] names ← new string[1000]
Exercise 5:   print len(names)
Exercise 6:   int num <- parts.length
Exercise 7:   print stuff[0]
Exercise 8:   print stuff[3]
Exercise 9:   end <- stuff[stuff.length-1]  OR  end <- stuff[len(stuff)-1]
Exercise 10:  stuff[10] <- 25
Exercise 11:  stuff[0] <- stuff[7]
Exercise 12:  for(int x <- 0 ; x < stuff.length ; x <- x+1)
                  print stuff[x]







1D Array Practice
problem


Assume that there is a procedure len which returns the length of an array. Now consider the function leftShift, which should shift the contents of all elements in a given array to a lower index, wrapping around to the end of the array if necessary:
procedure leftShift( int[] list, int places )
    for (int i ← 0; i < places; i ← i + 1)
    	int first ← list[0]
        for (int j ← 0; <condition> ; j ← j + 1)
            list[ j ] ← list[ j + 1 ]
    	end for
        list[ len( list ) - 1 ] ← first
    end for
end leftshift

Which of the following could be substituted for <condition> to cause leftshift to function as intended?
j < i
j < len ( list ) - 1 correct
j < len ( list ) - i
j < len ( list )

Explanation
The inner loop is designed to shift the contents of the array down one place. This should be performed on every element except for the last one.

For more help with this question, see the video called 1D Array leftShift


problem


Which loop shown below will rightly traverse the given array, outputting the values in order from front to back?
int list [] ← {5, 4, 3, 2, 1}

for(int x ← 0; x < list.length; x ← x + 1) print list[x] correct
for(int x ← 0; x ≤ list.length; x ← x + 1) print list[x]
for(int x ← len(list); x > 0; x ← x - 1) print list[x]
for(int x ← len(list)-1; x ≥ 0; x ← x + 1) print list[x]
for(int x ← len(list)-1; x ≥ 0; x ← x - 1) print list[x]

Explanation
To traverse from front to back, the start of the loop must be at position zero, indicated by the expression int x ← 0. To keep going, the loop control variable must still be less than the length of the array, indicated by the check expression x < list.length, or x < len(list), and the step must be an increment, shown by the statement, x ← x + 1.


problem


Which loop shown below will rightly traverse the given array, outputting the values in order from the back of the array to the front?
int list [] ← {5, 4, 3, 2, 1}

for(int x ← 0; x < list.length; x ← x + 1) print list[x]
for(int x ← 0; x ≤ list.length; x ← x + 1) print list[x]
for(int x ← len(list); x > 0; x ← x - 1) print list[x]
for(int x ← len(list)-1; x ≥ 0; x ← x + 1) print list[x]
for(int x ← len(list)-1; x ≥ 0; x ← x - 1) print list[x] correct

Explanation
To traverse from back to front, the start of the loop must be at the end position of the array, indicated by one less than the length of the array, either using the expression list.length - 1, or len(list) - 1. To keep going, the loop control variable must still be greater than or equal to zero, the first position of the array, indicated by the check expression x ≥ 0, and the step must be a decrement, shown by the statement, x ← x - 1.


problem


Which choice shown below is NOT a valid declaration of an array?
int [] list
float nums []
char array letters
boolean flags correct

Explanation

In most languages, some symbol or word must be used to indicate the declaration of an array. In the pseudocode system for the certification test, either the square brackets [] or the word array is used to do this.


problem


Given the pseudocode segment below, which of the choices shown has a false value?
int list [] ← {5, 4, 3, 2, 1}

list[0] > list[3]
list.length == list[1] correct
list[3] ≤ list[2] - list[4]
len(list) ≥ list[0]
list[4]*2 ≠ list[2]

Explanation
int list [] ← {5, 4, 3, 2, 1}

list[0] > list[3] : The value in position zero is a 5, which is indeed greater than the value in position 3, which is a 2, resulting in a true value for this expression.
list.length == list[1] : The length of this list is 5, which is equal to the value in position zero, not position 1, making this expression false.
list[3] ≤ list[2] - list[4] : The value in position 3, the 2, is equal in value to the difference between 3, the value in position 2, and 1, the value in position 4, making this expression true.
len(list) ≥ list[0] : The length of list is 5, which is equal to the value in position 0, also a 5, making this expression true.
list[4]*2 ≠ list[2] : Twice the value 1, the contents of position 4, is 2, which is indeed NOT equal to the value in position 2, the 3, making this expression evaluate to true.


problem


Assume that there is a function len that returns the length of a given array. Now consider the following definition for the function combine:
int[] combine( int[] list1 , int[] list2 )
    int[] result ← new int[ len ( list1 ) + len ( list2 ) ]
    for (int i ← 0; i < len ( result ) ; i ← i + 1)
        // loop body
    end for
    return result
end combine

Which of the following loop bodies will result in the combine returning a new list with the contents of list1 preceding the contents of list2?

if ( i < len ( list1 ) )
    result[i] ← list1[i]
else
    result[i] ← list2[i]
end if

if ( i < len ( list1 ) )
    result[i] ← list1[i]
else
    i ← 0
    result[i] ← list2[i + len( list1 )]
end if

if ( i < len ( list1 ) )
    result[i] ← list1[i]
else
    result[i] ← list2[len( list1 ) - i]
end if

if ( i < len ( list1 ) )
    result[i] ← list1[i]
else
    result[i] ← list2[i - len( list1 )]
end if
correct

Explanation
When copying the contents of list2, each element must be copied from list2 starting at its first index. However, to achieve that first index we must "remove" the length of list1 from the current index where we are storing the copied values in order for the array index to artificially "start over" at index 0 in list2.

For more help with this question, see the video called 1D Array Combine


problem


Assume that there is a function len which returns the length of an array. Now consider the procedure histogram ( result , data ) which should fill each index of result with the number of matching elements in the array data, such that if the value of data was { 2, 4, 2, 1, 0 }, the value of result after execution will be { 1, 1, 2, 0, 1 }:
procedure histogram(pass-by-reference int[] result, pass-by-value int[] data )
    for (int i ← 0; i < len ( data ); i ← i + 1)
        result[ data[i] ] ← result [ data[i] ] + 1
    end for
end histogram

Which of the following pre-conditions must be true for histogram to execute without error?
result's greatest value must be greater than data's last index
result's last index must be greater than data's last index
result's last index must be greater than or equal to data's greatest value correct
result's greatest value must be greater than data's greatest value

Explanation

If the largest value in data is used as an index for result, then it must be a valid index within the bounds


problem


Assume there is a function swap(int [] array, int index1, int index2 ) which swaps the cells at index1 and index2 in array. Also assume that there is a function len which returns the length of an array. Now consider the function reverse which should reverse the order of the contents of the given array:
procedure reverse( int[] list )
                               //integer division, truncates odd numbers
    for (int i ← 0; i < len ( list ) / 2; i ← i + 1)
        // call to swap
    end for
end reverse

Which of the following calls to swap in the loop body will cause reverse to function properly?
swap ( list, i, i + len ( list ) )
swap ( list, i, len ( list ) - i )
swap ( list, i, len ( list ) - i - 1 ) correct
swap ( list, i, len ( list ) - ( i - 1 ) )

Explanation

When calculating the position of the second index with which to swap, the calculated index cannot be past the last index of the array. When i = 0, the second index must be one less than the length of the list.


problem


Assume that there is a function len which returns the length of an array. Now consider the function stuff:
int stuff( int[] list )
    int largest ← 0
    for (int i ← 0; i < len ( list ); i ← i + 1)
        if ( list[ i ] > largest ) then
            largest ← list [ i ]
        end if
    end for
    return largest
end stuff

The post condition of stuff is that it returns the largest value of list. Which pre-condition listed below is necessary to meet this post-condition?
list must contain only values greater than 0
list must contain only values greater than -1
list's largest value must be greater than 0.
list's largest value must be greater than or equal to 0. correct

Explanation

Values greater than or equal to 0 include 0. If 0 is the largest value in list, the body of the if statement will never execute, but the function will still return the right largest value. However, if none of the values are greater than or equal to zero, all negative, the answer provided by the function will be not right.


problem


Which of the following is a feature of arrays?
Arrays are indexed correct
For a 0-based array of length 5, the index of the last cell is 5
Arrays are primitive data types
None of the above

Explanation

Arrays are indexed. A 0-based array has a last index of its length minus one. Because they contain primitives, they are considered aggregate data types.


problem


Consider the following block of code:

    int[] list ← { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 }
    for (int i ← 0; i < 10; i ← i + 1)
        // loop body
    end for

The intended post-condition of the loop is that list contains values in the Fibonacci sequence { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 }. Which loop body will accomplish this post-condition?

list[ i + 2 ] ← list [ i ] + list [ i + 1 ]

list[ i ] ← list [ i - 1 ] + list [ i -  2 ]

if ( i < 8 )
    list[ i + 2 ] ← list [ i ] + list [ i + 1 ]
end if
correct

if ( i > 1 )
    list[ i ] ← list [ i - 1 ] + list [ i - 2 ]
end if
correct

Explanation

Any loop body processing an array must make sure that no index that is out-of-bounds will be accessed. Although these first two answers would be acceptable in that any given value is a sum of the two previous values in the list, an out of bounds error occurs for each of them, at the end for the first choice, and at the beginning for the next one. In addition, the loop must not alter the first "seed" values of the Fibonacci sequence (the 0 and 1 at the beginning of the array.) Therefore, it is necessary to use if statements to make sure all of these situations are managed, resulting in two possible right answers here.


problem


Which of the following statements about arrays is NOT correct?
Arrays are stored in contiguous memory.
Arrays are able to contain primitive values, objects, and even other arrays.
Access to array elements is achieved through a process called indexing.
Arrays are dynamic, able to grow or shrink in size. correct
All of the elements of an array must be of the same type of data.

Explanation

Arrays are not able to grow or shrink in size, and are considered to be static, not dynamic. To accomplish a different size array, a new one must be created in memory, either larger or smaller, all contents of the previous array must be assigned to the new array, and then the original array is disposed of.


problem


Assume that there is a function len which returns the length of an array. Now consider the function fun:
int fun( int[] list )
    int num ← 0
    for (int i ← 1; i < len ( list ); i ← i + 1)
        if ( list[ num ] < list[ i ] ) then
            num ← i
        end if
    end for
    return num
end fun

What is returned by fun?
The greatest value in list
The least value in list
The index of the greatest value in list correct
The index of the least value in list

Explanation

The loop searches for the largest value in list and saves its index in num. The value of the variable num is returned, which represents the location in the list of the largest value in the array. The logic of the if statement is a bit misleading, since it is using the less than symbol, but think about it carefully, and it will make sense to you.


problem


Assume there is a function swap which, as a post-condition of execution, swaps the values of two indexed positions in an array parameter named list. Which of the following is the right function declaration for this function?
swap (pass-by-reference int [] list, pass-by-reference int index1, pass-by-reference int index2) correct
swap (pass-by-value int [] list, pass-by-value int index1, pass-by-value int index2)
swap (pass-by-value int [] list, pass-by-reference int index1, pass-by-reference int index2)
swap (pass-by-value int [] list, pass-by-reference int index1, pass-by-value int index2)

Explanation

In order for any swap function to rightly achieve the given post-condition, list must by passed by reference. Otherwise, any operations performed on the parameter list will not persist outside of the function.



Suggestion: Before you view a video, try the practice problem associated with it first.  Then view the video for further clarification.

    1D Array Swap
    1D Array LeftShift
    1D Array Reverse
    1D Array Fibonacci
    1D Array Histogram
    1D Array Combine



2D Arrays, Terms to Know, Guided Practice and Exercises
Two-Dimensional (2D) Array
    An array of arrays, characterized by rows and columns, arranged in a grid format, but still stored in contiguous, or side-by-side memory, accessed using two index values.

Row Major
    An array where the two index values for any element are the row first, then the column.

Ragged Array
    An array where the number of columns in each row may be different. For example, there could be two elements in the first row, three in the second, and five in the third.

Array Indices and Elements

Remember that a 2D Array is arranged like a grid. It is an array of arrays.

int [] [] grid ←  new int [2] [5]

Array Indices    grid           [0]   [1]   [2]   [3]   [4]     //rows
      columns           [0]     1     2     3     4     5
                        [1]     6     7     8               Array Elements


In the diagram above, the array defined has two elements, or rows.  Each of those elements is an array which contains several elements, or columns of the row.

At position 0, the element (row) is an array of 5 elements (1, 2, 3, 4, 5).

At position 1, the element is an array of 3 elements (6, 7, 8).

To access the first element of the first row, use the index reference [0][0].

The value 4 is in position [0][3].

The value 8 is in position [1][2].
GUIDED PRACTICE AND EXERCISES
Declaring and Initializing 2D arrays

A simple way of initializing a 2D array is shown below:

int [][] grid1 ← {{4,2,7},{5,1,9}}

Here is how this array would look like in row/column format:
4 2 7
5 1 9

Here is a way to declare an initially empty 2D array, containing all zero values by default:

int [][] grid2 ← new int [5][3]

This grid would have five rows with three elements in each row, for a total of 15 elements.

------------------------------------------------------
Exercise 1 (answer below) - Write a statement to initialize an integer 2D array called matrix
with eight random single digit positive integer values of your own choosing, arranged in
two rows of four elements each.
Exercise 2 - Write a statement to declare a 2D array called box that can contain
fifteen float values in 5 equal sized rows.
Exercise 3 - Write a statement to declare a symmetrical 2D array called square that can
contain 100 characters for a word search puzzle.
Exercise 4 - Write a statement to initialize a 2D array called names that contains the names
of your several current media personalities, first names in the first row, and last names in the
next row.
------------------------------------------------------

Using the length function with 2D arrays

Since there are two dimensions in a 2D array, the length feature can be used for either
dimension, the number of rows, or the number of columns in a row. Using a method called
len with the array yields the number of rows that grid contains, like these statement...

print len(grid1)
  or
print grid1.length            ...resulting in an output of...2

If you need to discover the number of elements in a particular row of an array, you would
do something like this:

print len(grid1[0])
  or
print grid1[0].length         ...resulting in an output of...3

------------------------------------------------------
Exercise 5 - Using a method called len which receives an array as a parameter, write the statement that prints the number of rows in names.
Exercise 6 - Using the length feature as described above, write the command using dot notation that assigns to an integer called num the number of columns in the second row of the 2D array called parts.

------------------------------------------------------

Output

int [][] grid1 ← {{4,2,7},{5,1,9}}

To output an element of a 2D array, such as the first element in grid1 declared and initialized above, is to do this:
 print grid1[0][0] ...resulting in an output of...4
To output the last element of an array, such as the last element in grid1 declared and initialized above, is to do this:
 print grid1[1][2]
or
 print grid1[len(grid1)-1][len(grid1[len(grid1)-1]-1]
             //last row        last col of last row
or
 print grid1[grid1.length-1][grid1[grid1.length-1]-1]
            //last row        last col of last row

 ...all resulting in an output of...9

Just as with one-dimensional arrays, you can use for loops to iterate over the elements in a two dimensional array.  Here are some examples:

int [] grid3 ← {{1,2},{3,4,5}}
 //outputs the contents of the first column of each row ... 1 3
for ( int x ← 0; x < grid3.length; x ← x + 1 )
 print grid3[x][0]

 //outputs the contents of the second column of each row ... 2 4
for ( int x ← 0; x < grid3.length; x ← x + 1 )
 print grid3[x][1]

 //outputs the contents of the first row ... 1 2
for ( int x ← 0; x < grid3[0].length; x ← x + 1 )
 print grid3[0][x]

 //outputs the contents of the second row ... 3 4 5
for ( int x ← 0; x < grid3[1].length; x ← x + 1 )
 print grid3[1][x]

 //using a nested loop structure outputs the contents of the entire grid ... 1 2 3 4 5

for ( int r ← 0; r < grid3.length; r ← r + 1 )
 for ( int c ← 0; c < grid3[r].length; c ← c + 1 )
 print grid3[r][c]
 end for
end for

 ------------------------------------------------------

Exercise 7 - Assuming the declaration of a 2D integer array called stuff, write a statement that outputs the first element of this 2D array.
Exercise 8 - Using the same 2D array stuff mentioned above, write a statement that outputs the third element in the first row of this array.
Exercise 9 - Using the same array stuff mentioned above, assign to a variable called end the value in the final position (last column of last row) of the array.
Exercise 10 - Write a statement that assigns to row 1, column 0 of the stuff array the value 25.
Exercise 11 - Write a statement that assigns to the third column in the fourth row of stuff the value of the first element of the array.
Exercise 12 - Again using the stuff 2D array, write a loop that prints all of the values in the first row of the array.

------------------------------------------------------

Answers to Exercises

Exercise 1:   int [][] matrix ← {{3,6,5,1},{9,0,6,1}}//values may vary
Exercise 2:   float [][] box ← new float[5][3]
Exercise 3:   char [][] square ← new char[10][10]
Exercise 4:   string [][] names ← {{Donald, Hillary, Clint},{Trump, Clinton, Eastwood}}
Exercise 5:   print len(names)
Exercise 6:   int num <- parts[1].length
Exercise 7:   print stuff[0][0]
Exercise 8:   print stuff[0][2]
Exercise 9:   int end <- stuff[stuff.length-1][stuff[stuff.length-1]-1]
Exercise 10:  stuff[1][0] <- 25
Exercise 11:  stuff[3][2] <- stuff[0][0]
Exercise 12:  for(int x <- 0 ; x < stuff[0].length ; x <- x+1)
                  print stuff[0][x]









2D Array Practice
problem


Assume there is a function len which returns the number of elements in an array. Consider the function int greatest(pass-by-reference int [][] grid ), which accepts parameter grid as a 2D array with at least one row and one column. Its intended post-condition is that it will return the greatest value in the array.
int greatest(pass-by-reference int [][] grid)
    int num ← grid[0][0]
    for (int i ← 0; i < len ( grid ); i ← i + 1)
        for (int j ← 0; j < len ( grid ); j ← j + 1)
            if (grid [ i ][ j ] > num )
                num ← grid[ i ][ j ]
            end if
        end for
    end for
    return num
end greatest


The inner loop of the function has been written not rightly and does not always successfully complete its post-condition. Choose a value for grid which will cause highest to return an not right value.
{ { 1, 2, 3 }, { 4, 5, 6 } } correct
{ { 1, 2 }, { 3, 4 } }
{ { 6, 5, 4 }, { 3, 2, 1 } }
{ { 4, 3 }, { 2, 1 } }

Explanation

The error in the code is in the nested for loop that iterates through j. This code is not rightly written to use the length of the 2D array as the upper bound of the nested loop. len( grid ) will return the number of rows in the array when passed the entire 2D array. Typically, the inside loop of a nested loop structure is intended to iterate through columns and should use len( grid[i] ) as the upper bound of the loop. As such, if there are more columns than rows and the largest value appears in the last column, the nested loops will fail to inspect that value.

In this case, the values 3 and 6 of the array {{ 1, 2, 3 }, { 4, 5, 6 }} will never be reached, and the algorithm will fail to return the greatest value of the array.


problem


Assume a function len has been defined which returns the number of elements in an array. Now consider a function flatten (pass-by-reference int [] square, pass-by-reference int [] flat). The post-condition of flatten is that flat should have the contents of square, copied row by row. For example, if square contains: { { A, B, C }, { D, E, F } } then after execution flat should contain { A, B, C, D, E, F }. Which function body for flatten will achieve the specified post-condition?

    for (int i ← 0; i < len( square ); i ← i + 1)
        for (int j ← 0; j < len( square[0] ); j ← j + 1)
            flat[ i * len ( square ) + j ] ← square[ i ][ j ]
        end for
    end for

    for (int i ← 0; i < len( square ); i ← i + 1)
        for (int j ← 0; j < len( square[0] ); j ← j + 1)
            flat[ i + j * len ( square ) ] ← square[ i ][ j ]
        end for
    end for

    for (int i ← 0; i < len( square ); i ← i + 1)
        for (int j ← 0; j < len( square[0] ); j ← j + 1)
            flat[ i * len ( square[ 0 ] ) + j ] ← square[ i ][ j ]
        end for
    end for correct

    for (int i ← 0; i < len( square ); i ← i + 1)
        for (int j ← 0; j < len( square[0] ); j ← j + 1)
            flat[ i + j * len ( square [ 0 ]) ] ← square[ i ][ j ]
        end for
    end for

Explanation

The nested loops in each code body iterates through square by row and then column. To find the index of the each row as it appears in flat, i must be multiplied by the length of each row, which can be determined with the length of the first row of square - len (square [ 0 ])


problem


Assume a function len has been defined that returns the number of elements in an array. A programmer is trying to implement matrix multiplication, where two non-empty row-major matrices A and B of at least 1x1 size are multiplied to create a new matrix. The number of columns of A is equivalent to the number of rows of B. If A is n x m elements and B is m x p elements, the result R will be n x p elements. If A and B are 2D arrays, which of the following rightly declares R?
int [][] R ← new int [ len( A ) ][ len( B ) ]
int [][] R ← new int [ len( A[0] ) ][ len( B[0] ) ]
int [][] R ← new int [ len( A[0] ) ][ len( B ) ]
int [][] R ← new int [ len( A ) ][ len( B[0] ) ] correct

Explanation
The new array R must have the same number of rows as A and the same number of columns as B, stated above as n x p. The number of rows in A, or n , can be determined with len( A ), and the number of columns in B, or p, is len( B[0] ), i.e., the length of the first row of B.


problem


Which of the following situations would be best suited for storage in a 2D array?
A student record with fields of differing data types
A number sequence of unknown length
A decision tree
An image made of rows and columns of pixels correct

Explanation

A 2D array is typically used to represent rows and columns of values. In this case, individual pixels would comprise the values in the array.


problem


How many integers can be stored in a 2D array with the definition int [][] grid ← new int[ 5 ][ 10 ]?
5
10
36
50 correct

Explanation

In a fixed-length two dimensional array with fixed length sub-arrays, the number of items is the number of items in each sub-array multiplied by the number of sub-arrays, which in this case is 5 rows of 10 columns in each row, or 5 times 10, or 50.


problem


Consider the following block of code, which declares a 2D array named grid with sub-arrays of unspecified length:
int [][] grid ← new int [ 3 ][]
grid[ 0 ] ← new int [ 3 ]
grid[ 1 ] ← new int [ 4 ]
grid [ 2 ] ← new int [ 5 ]

How many integers can grid contain after this code is executed?
9
12 correct
15
36

Explanation

In languages that support 2D arrays as "arrays of arrays", each sub-array can be of variable length. The sum total of all cells in each sub-array is capacity of the entire data structure. In this example, the three rows have 3, 4, and 5 locations, respectively, for a total capacity of 12.















Stack
    A stack is an abstract data type that serves as a collection of elements, with three principal operations: push, pop, and peek, as described above.  A stack is often considered a LIFO array (Last In, First Out).

Push
    A method used in stack processing where a new value is inserted onto the top of the stack.
Pop
    A method used in stack processing where a copy of the top value is acquired, and then removed.
Peek
    A method used in stack processing where a copy of the top value of the stack is acquired, without removing that item.

Push, Pop, and Peek
Push, pop and peek are three operations that you can perform on a stack.

Operation	          Description	                                                Example
Push 	              Put a value on the top of a stack 	                        push 9
                                                                                Puts the value 9 onto the top of a stack
Pop                 Remove and use the value from the top of a stack 	          pop x
                                                                                Gets a copy of and removes the top value of a stack
Peek 	              Look at and use the value from the top of the stack 	      peek x
                                                                                Gets a copy of, but does not remove, the top value of a stack





Stacks are LIFO
Remember that stacks are a LIFO data structure: Last In, First Out. Push, pop, and peek operate on the top element of the stack.






Stack Practice
problem


Consider the following implementation of a Stack class, where the class variables contents and highest are accessible for reading and writing by all methods in the class:
class Stack
    int [] contents ← new int[ 10 ]
    int highest ← -1
    void push( int item )
        highest ← highest + 1
        contents[ highest ] ← item
    end push

Which of the following is a valid implementation of peek, assuming a pre-condition that the stack is not empty?

int peek( )
    return contents[ highest ]
end peek correct

int peek( )
    highest ← highest - 1
end peek

int peek( )
    highest ← highest - 1
    return contents[ highest ]
end peek

int peek(  )
    highest ← highest - 1
    return contents[ highest + 1 ]
end peek

Explanation

peek should only return the last element added to the stack and not modify the stack in any way. highest represents the index of the last element added to the stack.


problem


Which of the following describes a characteristic of stacks?
First in, first out
Last in, last out
Last in, first out correct
Ordered by value

Explanation

Stacks are last in, first out (LIFO) data structures. The last value added with push will be the first value returned with pop.


problem


A stack object has had 8 calls to push, 5 calls to pop and 3 calls to peek. How many elements does it currently contain?
0
3 correct
5
8

Explanation

Each call to push adds an element. Each call to pop removes an element. Calls to peek do not alter the stack. The order of the calls does not matter. Therefore the number of elements can be found by adding the number of push calls and subtracting the number of pop calls.


problem


Consider the following block of code:
Stack s ← new Stack ()
    s.push( 9 )
    s.push( 3 )
    s.push( 6 )
    s.peek( )
    s.pop( )
    s.push( 8 )
    s.push( 9 )
    s.pop( )
    s.pop( )

What is returned by a subsequent call to s.peek( )?
3 correct
6
8
9

Explanation

Every call to push adds an element, while the single call to peek does not alter the stack. Therefore, line-by-line, the contents of the stack are: { 9 }, { 9, 3 }, { 9, 3, 6 }, { 9, 3, 6 }, { 9, 3 }, { 9, 3, 8 }, { 9, 3, 8, 9 }, { 9, 3, 8 }, and finally { 9, 3 }


problem


Which of the following does not describe a behavior of stacks?
pop returns and removes the last element pushed
push adds an element to the stack
peek returns and removes the top element of the stack correct
peek returns the last element pushed

Explanation

peek methods for stacks and queues do not alter the contents of these data structures.


problem


Assume there is a function len which returns the number of elements in an array. Now consider the function function reverse( pass-by-reference int [] list ), with the post-condition that elements of list are left in reverse order:
function reverse( pass-by-reference int [] list )
    Stack s ← new Stack ()
    for ( int i ← 0; i < list; i ← i + 1 )
        s.push ( list [ i ] )
    end for
    for ( int i ← 0; i < list; i ← i + 1 )
        list [ i ] = s.pop()
    end for
end function

Choose the best explanation for how reverse accomplishes its post-condition
All elements of list are pushed in order to the stack. list is then filled in the order in which all elements were pushed.
All elements of list are pushed in reverse order to the stack. list is then filled in the order in which all elements were pushed.
All elements of list are pushed in order to the stack. list is then filled in the reverse order in which all elements were pushed. correct
All elements of list are pushed in reverse order to the stack. list is then filled in the reverse order in which all elements were pushed.

Explanation

The first loop traverses list in order and pushes each element to the stack. The second loop traverses list again, this time popping elements from the stack. Popping elements always occurs in reverse order from which they were pushed.













Queue
    A FIFO (first in first out) data structure, similar to a stack, but where the first element added to the queue will be the first one to be removed, and where a new element is added to the back of the queue, much like a waiting line. The three main operations are also similar to a stack - push, pop, and peek - where push inserts to the back of the queue, and pop and peek work at the front of the queue.

Push, Pop, and Peek

Similar to stacks, push, pop and peek are three operations that you can perform on a queue. Note that they work a little differently for this data structure.
Operation	                                Description	                                                Example
Push (Enqueue) 	                          Put a value at the back of the queue 	                      push 9
                                                                                                      Will push the value 9 to the back of the queue
Pop (Dequeue) 	                          Remove and use the value from the front of the queue 	      pop x
                                                                                                      Will pop the value from the front of the queue
Peek 	                                    Look at and use the value at the front of the queue 	      peek x
                                                                                                      Will look at the front value of the queue

Queues are FIFO

Remember that queues are a FIFO data structure: you push elements to the back of the queue and pop and peek elements at the front of the queue.

A B C                 → D →            A B C D
Queue before          push D          Queue After

Comparison of Stacks and Queues

Let's review some of the similarities and differences between stacks and queues.
	                                       Stacks	                                Queues
Data Structure Description 	             LIFO (last in, first out) 	            FIFO (first in, first out)
Good analogy 	                           Stack of cafeteria trays 	            Queue (line) for concert tickets
Pushes to 	                             The top of the stack 	                The back of the queue
Peeks at 	                               The top of the stack 	                The front of the queue
Pops from 	                             The top of the stack 	                The front of the queue






Queue Practice
problem


Consider the following implementation of a Queue class, where contents, front and rear are accessible for reading and writing by all members of the class:
class Queue
    int [] contents ← new int[ 10 ]
    int front ← -1
    int rear ← -1

If front represents the index of the array with the item at the front of the queue and rear represents the index of the array with the item at the end of the queue, what is a description of an implementation of pop that would work with this Queue class?
Retrieve the element at contents[ front ], update the value of rear to represent the new rear of the list.
Retrieve the element at contents[ front ], update the value of front to represent the new front of the list. correct
Retrieve the element at contents[ rear ], update the value of rear to represent the new rear of the list.
Retrieve the element at contents[ rear ], update the value of front to represent the new front of the list. correct

Explanation

Dequeueing from an array always retrieves and returns the value at the head of the queue. Once this value has been retrieved, the head index should be modified to represent that there the head of hte queue has now changed to a different element.


problem


Assume there is a function now which returns the current time as an integer. Now consider the following two classes, where timestamp and text are readable and writeable by Receiver:
class Message
    int timestamp
    String text

class Receiver
    Queue q ← new Queue()

    Message receive( pass-by-reference Message m )
        m.timestamp = now()
        q.enqueue ( m )
    end receive

    void nextMessage ( )
        // nextMessage function body
    end nextMessage

If each subsequent call to nextMessage() should print the timestamp and text of the oldest message received and remove it, which is a valid implementation of nextMessage()?

print q.pop().timestamp
print q.pop().text

print q.peek().timestamp
print q.peek().text

print q.peek().timestamp
print q.pop().text correct

print q.pop().timestamp
print q.peek().text

Explanation

The intended post-condition is that only one message is read and removed. Peeking does not modify the queue, while dequeueing will remove a message. There should be exactly one call to dequeue, and it should happen after a peek to print the timestamp. If the dequeue happens before, then the message at the front will be removed. Its timestamp will be printed, but the text of the next message will be printed.


problem


Which of the following is an appropriate use of queues?
Maintaining an ascending list of items ordered by values
A place for storing received messages, to be handled in order of receipt correct
A list of visited destinations that can be used for backtracking
A searchable list of values

Explanation

Queues are designed to preserve chronological order, with items that are chronologically oldest being removed first. Queues that store messages for processing in order of receipt are typically called "message queues."


problem


Which of the following is a characteristic of queues?
Peeking will return the value at the front of the queue correct
Peeking will remove and return the value at the front of the queue
Peeking will remove and return the value that has been in the queue least
Peeking will return the value that has been the queue longest

Explanation

Peeking returns the value at the "front" of the queue, which will be the value that has chronologically been present the longest. It will not modify the queue.


problem


Consider the following block of code:
Queue q ← new Queue ()
    q.push( 9 )
    q.push( 3 )
    q.push( 6 )
    q.peek( )
    q.pop( )
    q.push( 8 )
    q.push( 9 )
    q.pop( )
    q.pop( )

What is returned by a subsequent call to q.peek( )?
3
6
8 correct
9

Explanation

Every call to push adds an element, while the single call to peek does not alter the stack. Therefore, line-by-line, the contents of the stack are: { 9 }, { 9, 3 }, { 9, 3, 6 }, { 9, 3, 6 }, { 3, 6 }, { 3, 6, 8 }, { 3, 6, 8, 9 }, { 6, 8, 9 }, and finally { 8, 9 }


problem


Which of the following is a true statement?
Popping from a queue functions in the same way as popping from a stack.
The "pop" operation will return the tail element of a queue.
The "pop" operation will remove and return the tail element of a tail.
The "pop" operation will remove and return the head element of a queue. correct

Explanation

Last-in, first-out (LIFO) behavior is a characteristic of stacks. It is not a characteristic of queues. Pop will remove and return the front element of a queue.













Linked List
    A linear data structure, much like an array, that consists of nodes, where each node contains data as well as a link to the next node, but that does not use contiguous memory.
Node
    In a linked list, tree, or similar graph-based structure, a node is an object linked to other objects, representing some entity in that data structure.
Non-Linear Data Structure
    A data structure that does not occupy contiguous memory, such as a linked list, graph, or tree.
Dynamic Memory
    Memory that is NOT contiguous (side-by-side), is allocated, or removed, as needed,  specifically during the implementation of a linked-list style data structure, which also includes binary trees and graphs.
Head
    This is a typical object variable identifier names used to reference, or point to, the first object in a linked list.  The number one rule for processing linked lists is, "Never let go of the head of the list!", otherwise all of the list is lost in memory. The number two rule when managing linked lists is, "Always connect before you disconnect!".

Image Interactive
Linked List Pseudocode

This pseudocode example creates a linked list.

Class Definition

The Node class includes the fields and methods that you will use to help build up the linked list. This includes the data field and the link, which points to the next node. If there is no next node, many languages point to null.

Main Method

The main method houses the actual code that builds the linked list. Let's take a closer look line by line.

Line 1: Creating the Head Node

Line 1 creates an empty node. This node will be the head of the list. Remember that the head is the reference for all of the rest of the nodes.

Line 2: Giving the Head Node Data

Line 2 gives the head node the integer 5 as data.

Line 3: Creating the Next Node

Line 3 creates the next node. Notice how there is no index. Instead this node is the next node down from the head.

Line 4: Giving the Next Node Data

Line 4 gives the next node the integer 3 as data.

Line 5: Creating the Third Node

Line 5 creates the third node. Notice again how this node is created as head.next.next.

Line 6: Giving the Third Node Data

Line 6 gives the third node the integer 6 as data.




Linked List Practice
problem


Assume there is a function tail which returns a reference to the last Node of a linked list, given the head Node. For this problem, also assume there is a non-empty linked list reference declared as list. Now consider the following line of code:
Node temp ← tail ( list )

Immediately after this line of code is executed, which of the following conditions will be true, according to the post-condition of tail
temp is equal to null
temp.item is equal to 0
temp.next is equal to null correct
temp.next.item is equal to null

Explanation

The next field of a Node is always null for the last Node in a linked list. A non-empty linked list will always return a non-null last node, even if the only node in the list is the head node. Because the line of code finds the last Node of list and stores a reference to it in temp, temp.next will be null. tail does not specify any conditions concerning the item contained in the last node. It is also impossible to evaluate temp.next.item because temp.next is null


problem


Assume there is a function tail which returns a reference to the last Node of a list. Assuming that there is a reference head which points to the head Node of a linked list, which of the following pseudo-code descriptions would append a Node with the value newItem to the end of the list?
Set the tail Node's item value to the newItem
Set the tail Node's next link to the newItem
Create a new Node with the value newItem; set the tail Node's item value to the new Node
Create a new Node with the value newItem; set the tail Node's next link to the new Node correct

Explanation

In a typical linked list Node, item refers to a data value and next refers to the Node which follows. The tail function supplied will find the last Node of the linked list. To add any element to a linked list, a new Node must be created with the new value. To attach the new Node to the list, the new Node must be assigned to the tail Node's next link.


problem


Consider the following linked list in this diagram:

Assuming that a Node reference head is null, which of the following code blocks will NOT result in the Linked List pictured above?

head ← new Node( )
head.item ← 5
head.next ← new Node ( )
head.next.item ← 3
head.next.next ← new Node ( )
head.next.next.item ← 6

head ← new Node( )
head.next ← new Node ( )
head.next.next ← new Node ( )
head.item ← 5
head.next.item ← 3
head.next.next.item ← 6

head ← new Node( )
head.item ← 5
head.next ← new Node ( )
head.item ← 3
head.next ← new Node ( )
head.item ← 6 correct

head ← new Node( )
head.item ← 5
temp ← new Node()
temp.item ← 3
head.next ← temp
temp ← new Node()
temp.item ← 6
head.next.next ← temp

Explanation

The first node in this list is always head. The second node is head.next and the third is head.next.next. Choice C does not function rightly because the code assigns the values 3, and then 6 to the first node, and not the nodes found at what would be the second and third indices.


problem


Consider the following linked list in this diagram:

Now consider the following block of code:
int num ← 0
Node temp ← head
while ( temp ≠ null )
    if ( temp.item == 3 )
        print num
    end if
    num ← num + 1
    temp ← temp.next
end while

What will be printed by the above block of code?
0
1 correct
2
3

Explanation

The while loop of this block of code traverses the linked list. The if statement checks to see if the current node in the traversal (referenced by temp) has a value equivalent to 3. num keeps track of the current node index, where the head node's index is 0. Therefore, the index of the node with value 3 is 1.


problem


Consider the following linked list in this diagram:

Which of the following is not a true statement about this linked list?
The head node contains the value 5
head.next.next.item is equal to 6
There are three nodes in this list
null represents a node that exists but does not contain a value correct

Explanation

null is a special value that means there is no existing node. In this case, no node exists after the node containing the value 6.


problem


Which of the following does not describe a feature of linked lists?
Dynamically allocated in memory
Abstract data type
Fixed length correct
O(N) complexity to access any node in the list

Explanation

Linked lists is a dynamically allocated abstract data type. "Fixed length" is a characterization more typical of arrays. To access an individual cell in a linked list, the worst case scenario is that for n elements, all n elements must be traversed. Therefore, it has O(n) access complexity (as opposed to arrays which are said to have O(1) access complexity.)















Binary Tree
    A data structure that consists of nodes, with one root node at the base of the tree, and two nodes (left child and right child) extending from the root, and from each child node.
Children
    The term used in trees to indicate a node that extends from another node, such as left child and right child in a binary tree.
Complete Tree
    A complete tree (not to be confused with a full tree) is one in which there are no missing nodes when looking at each level of the tree. The lowest level of tree may not be completely full, but does not have any missing nodes. All other levels are full.
Full Tree
    A tree in which every level of the tree is completely full, with no missing nodes, not to be confused with a complete tree.
Depth
    In a tree data structure, the depth of the tree is most commonly expressed as the number of steps from the root of the tree to the farthest outlying node in the tree. Height is also used to mean the same thing.
Leaf
    A leaf is a node in a tree data structure that has no children, and is at the end of a branch in a tree.
Parent Node
    The parent node in tree structure is a node, including the root, which has one or more child nodes connected to it. Note: It is possible for a parent node to have only one child, either a left child, or a right child.
Root
    The root node is the base level node in tree; the node that has no parent.



Image Interactive

Binary Tree Pseudocode

This pseudocode example creates a binary tree. The void method main refers to a class called TreeNode. The TreeNode class includes the fields and methods that you can use to help build up the object.
Line 1: Creating the Root Node

The first line of the body of the main method creates the root node.
Line 2: Giving the Root Node Data

The next line (line 2) gives the root node the integer 5 as data.
Line 3: Creating the Left Child Node

Line 3 creates an empty left child node.
Line 4: Giving the Left Child Node Data

Line 4 gives the left child node the integer 3 as data.





General Binary Tree Practice
problem


Consider the following tree in this diagram:

Which statement is true?
6, 5 and 3 are parent nodes
Only 7, 2 and 3 are child nodes
All nodes except for 6 are child nodes correct
Only 6 and 5 are root nodes

Explanation

A parent node is any node that has at least one child. 3 is not a parent node, therefore choice A is false. In a tree, every node except for the root are child nodes. Therefore, choice B is false and choice C is true. There can be only one root node, therefore choice D is false.


problem


Consider the following tree in this diagram:

If a new node was to be inserted with the maintaining this tree's completeness, where would it be inserted?
The left child of 7
The right child of 7
The left child of 3 correct
The right child of 3

Explanation

A complete binary tree is a tree where every level except the last has nodes with two children. On the last level, any empty spaces should be as far right as possible. To insert another node with the intent of making a full complete, no new level should be started. Therefore, the parent node of the new node should be 3 and its left child should be the new node.


problem


Consider the following tree in this diagram:

Which nodes are considered leaf nodes?
5, 3, 7, 2
3, 7, 2 correct
7, 2
6, 5

Explanation

Leaf nodes are nodes that do not have children. There are no child nodes of 7, 2 or 3, therefore they are leaf nodes


problem


Consider the following tree in this diagram:

Which nodes are considered parent nodes?
6, 5, 3
3, 7, 2
7, 2
6, 5 correct

Explanation

Parent nodes are nodes that have a child. Because nodes 6 and 5 have other nodes linking to them, they are considered parent nodes.


problem


Consider the following tree in this diagram:

If this is a general tree, as described by this curriculum, from which array was this tree built?
{ 6, 5, 7, 2, 3 }
{ 7, 5, 2, 6, 3 }
{ 7, 2, 5, 3, 6 }
{ 6, 5, 3, 7, 2 } correct

Explanation

When building a tree from an array, the tree is filled level by level from the root to the bottom, from left to right on each level. When each level is filled, the next level of the tree may be started.


problem


Consider the following tree in this diagram:

Which statement is false?
The root is 6
The tree is complete
The tree is full correct
The tree has three leaves

Explanation

A full binary tree is a tree where every node has two children except for leaves on the deepest level of the tree. Because node 3 is not at the deepest level of the tree and does not have two children, the tree is not full. A full tree is one where every node except for those on the deepest level has two children. A leaf is a node with no children. The root of a tree is the topmost node with no parents.









Binary Tree Traversal
    The process of systematically visiting every node in a tree once. The three most common traversals are: pre-order, in-order, and post-order.
Full Tree Traversal
Full Tree Traversal
    A non-executable, visual approach to help determine the pre-order, in-order, or post-order traversal of a tree, as in the diagram shown above.
Pre-Order Traversal
    The process of systematically visiting every node in a tree once, starting with the root node, proceeding to the left along the tree and accessing the node when the "left" side of the node is encountered.  The pre-order traversal of the tree example shown above is: 5, 9, 4, 1, 8, 6, 5, 3, 2 , 7.
In-Order Traversal
    The process of systematically visiting every node in a tree once, starting at the root and proceeding left down the tree, accessing the first node encountered at its "center", proceeding likewise along the tree, accessing each node as encountered at the "center".  The in-order traversal of the tree example shown above is: 1, 4, 8, 9, 5, 6, 5, 2, 3, 7.
Post-Order Traversal
    The process of systematically visiting every node in a tree once, starting at the root and proceeding left down the tree, accessing the first node encountered at its "right" side, proceeding likewise along the tree, accessing each node as encountered at its "right" side.  The post-order traversal of the tree example shown above is: 1, 8, 4, 5, 6, 9, 2, 7, 3, 5.





Tree Traversal Practice
problem


Consider the following tree in this diagram:

Which of the following is a pre-order traversal of this tree?
2, 3, 5, 6, 7
6, 5, 7, 2, 3 correct
7, 5, 2, 6, 3
7, 2, 5, 3, 6

Explanation

You may use the visual strategy for performing tree traversals. View the video on "Binary Tree Traversals" to see how this works.


problem


Which of the following statements about Tree Traversals are true?
Traversals add all cells of an array to a tree
Traversals print all nodes of a tree
Traversals delete all nodes of a tree
Traversals access all nodes correct

Explanation

A traversal on a tree is an operation that access the all data stored in a tree. They do not modify the tree. While a traversal can print elements encountered during a traversal, their primary purpose is to access the data. What is done with the data (such as printing) is not within the definition of a traversal.


problem


Consider the following tree in this diagram:

Which of the following is a post-order traversal of this tree?
2, 3, 5, 6, 7
6, 5, 7, 2, 3
7, 5, 2, 6, 3
7, 2, 5, 3, 6 correct

Explanation

You may use the visual strategy for performing tree traversals. View the video on "Binary Tree Traversals" to see how this works.


problem


Consider the following tree in this diagram:

Which of the following is a in-order traversal of this tree?
2, 3, 5, 6, 7
6, 5, 7, 2, 3
7, 5, 2, 6, 3 correct
7, 2, 5, 3, 6

Explanation

You may use the visual strategy for performing tree traversals. View the video on "Binary Tree Traversals" to see how this works.


problem


Which of the following is not a type of traversal of a tree?
Pre-order
Sorted-order correct
In-order
Post-order

Explanation

The three traversals of a tree are pre-order, in-order and post-order. If a tree is a binary search tree where left children are always less than or equal to their parents and right children are always greater than their parents, then the in-order traversal will produce a sorted order traversal. However, this question is about all trees -- not specifically binary search trees.









Binary Search Tree
    A tree in which nodes are inserted systematically in natural order, with the final property of each left child being less than or equal to its parent, and each right child being greater than its parent.




Search Tree Practice
problem


Which of the following statements is true for binary search trees, as specified for this curriculum?
The root node is the value that was inserted first correct
The smallest value is the left most node of the last level of every binary search tree
The greatest value is the right most node of the last level of every binary search tree
A pre-order traversal of a binary search tree will traverse nodes in the order in which they were added to the binary search tree.

Explanation

Statements B is false because the left most node of the last level of a binary search tree may be a right child of the least value. Statement C is false because the right most node of the last level of a binary search tree may be a left child of the greatest value. Statement D is false because trees do not preserve the order in which nodes were inserted.


problem


Consider the following binary search tree in this diagram:

Which of the following arrays does not represent a possible order in which values were inserted?
{ 6, 3, 7, 2, 5 }
{ 6, 7, 3, 5, 2 }
{ 6, 2, 5, 3, 7 } correct
{ 6, 3, 7, 5, 2 }

Explanation

If the node with value 2 was inserted before the node with value 3, then the left child of the root node 6 would have been 2, with the node 3 as the right child of node 2.


problem


Consider the following binary search tree in this diagram:

Which of the following represents a pre-order traversal of the tree?
6, 3, 7, 2, 5
7, 6, 5, 3, 2
2, 3, 5, 6, 7
6, 3, 2, 5, 7 correct

Explanation

An pre-order traversal for a binary search tree is no different than a pre-order traversal for a generic tree.


problem


Consider the following binary search tree in this diagram:

Which of the following represents an in-order traversal of the tree?
6, 3, 7, 2, 5
7, 6, 5, 3, 2
2, 3, 5, 6, 7 correct
6, 3, 2, 5, 7

Explanation

An in-order traversal of a binary search tree always traverses nodes in ascending order of value. This is a special property of binary search trees.


problem


Consider the following binary search tree in this diagram:

If a new node with the value 8 was to be inserted while preserving the properties of the binary search tree, where would it be inserted?
The left child of 7
The right child of 7 correct
The left child of 5
The right child of 5

Explanation

When inserting a new node, compare the value of the new node to each node starting at the root. If the value of the new node is greater than the current node, the new node moves to the right of the current node and the comparison is repeated until an empty space is found. In this case, 8 is greater than 6. The new node "slides" to the right child of 6 and is then compared. This child is 7. Because 8 is greater than 7 and 7 does not already have a right child, the new node with value 8 is inserted as the right child of 7.


problem


A binary search tree is built from an array. Which of the following statements is true?
Any traversal of this tree will visit nodes in ascending order of value.
Pre-order traversals of this tree will visit nodes in the order of which they were added to the tree
Post-order traversals of this tree will visit nodes in descending order of value.
In-order traversals of this tree will visit nodes in ascending order of value. correct

Explanation

Binary search trees are a special case of binary trees where left child nodes are always less than or equal to their parent node and right child nodes are always greater than their parent node. The only guarantee of a traversal is that an in-order traversal on a binary search tree will be in ascending order. No traversal will gaurantee a "chronological" ordering because binary search trees do not preserve the order in which nodes were added.


problem


Which of the following statements is not true for binary search trees, as described in this curriculum?
The root node is the value that was inserted first
Every child node to the left of a node is less than or equal to the parent node
Every child node to the right of a node is greater than or equal to the parent node correct
An in-order traversal of a binary search tree will always traverse elements in order of ascending values

Explanation

Every child node in a binary search tree to the right of a parent node will always be greater than, but not equal to, the parent node.








Minimum Heap Tree

A tree in which every parent is lesser in value than both its children, which means that the root of the tree is the least value in the tree.

Maximum Heap Tree

A tree in which every parent is greater in value than both its children, which means that the root of the tree is the greatest value in the tree.

Note:  When in the removal process, a tie occurs between the left and right child in deciding which will replace the root, it really does not matter which way you resolve it.  Most code examples show that the tie goes to the left.  For example, in the min heap video, the value 7 ends up in the root position, with two child values of 5. Which value is switched with the 7? Let's go with the left child to stay consistent with most code examples.




Heap Practice
problem


Which of the following statements is false for minimum heap trees?
New nodes always become the new root. correct
After adding a node, minimum heap state must be maintained.
After removing a node, minimum heap state must be maintained.
The root will always be the smallest value in a minimum heap tree.

Explanation

After performing addition or removal operations on a minimum heap tree, the minimum heap state must be maintained. That is to say, the "heapify" operation must be performed. As a result, the root will always have the least value in a minimum heap tree.


problem


Which of the following statements is true for all minimum heap trees?
The tree is always complete correct
The tree is always full
Left child nodes are always less than their parent nodes
The root is always the median value

Explanation

Minimum heap trees always maintain two conditions - that they are complete (with the every parent node having two children except for the last level, wherein all nodes must be to the left) and that each parent must be less than its two children. A minimum heap tree may not always be full (with every parent node having two children and the last level being completely filled). Trees which specify that left child nodes are always less than their parent nodes are typically binary search trees. One special property of minimum heap trees is that the root is always the least value.


problem


Consider the following minimum heap tree in this diagram:

If the value 1 is inserted, where would its final position be after the heap state was maintained?
The left child of 3
The right child of 4
The root of the heap correct
The left child of 7

Explanation

When inserting into a heap, the first step is to insert new elements where they will maintain heap "completeness." In this case, that position would be the left child of 3. After insertion, the heap state must be maintained, otherwise referred to as "heapify" in the video lectures of this curriculum. The new element is verified to make sure that it is greater than its parent, for a minimum heap tree. If it is less than its parent, the tree must be re-arranged until either it has a parent less than itself or it has become the root of the heap. In a minimum heap tree, the smallest value in the tree will be always be the root after the heap state is maintained.


problem


Consider the following minimum heap tree in this diagram:

If the value 2 was removed during a heap traversal, what value would become the new root after the heap state was maintained?
3 correct
5
6
7

Explanation

During a traversal of the heap where the root is removed, the rightmost node of the last level of the heap would replace the root. However, this would be temporary. When the heap state is maintained, if this replacement root is larger than either of its children then it will not retain its position as root. At the end of the "heapify" process for a minimum heap tree, the root should always contain the smallest value.


problem


Consider the following minimum heap tree in this diagram:

If the value 2 was added to the heap and minimum heap state was maintained, where would be the final position of the new node containing 2?
The root of the tree
The left child of the root
The right child of the root correct
The left child of 3

Explanation

In the case of adding the value 2, the new node will be added to the left child of the node with value 3. However, the heap state must be maintained. Therefore, it will trade places with the parent node with the value 3. At this point, the node will not continue to travel towards the root. Its position is the right child of the root. When the root and the new node are compared, they have the same value. Therefore, it is not necessary to continue performing the "heapify" operation.


problem


Consider the following minimum heap tree in this diagram:

If the value 4 is inserted, where would its final position be after the heap state was maintained?
The left child of 3 correct
The right child of 3
The root of the heap
The left child of 7

Explanation

When inserting into a heap, the first step is to insert new elements where they will maintain heap "completeness." In this case, that position would be the left child of 3. After insertion, the heap state must be maintained, otherwise referred to as "heapify" in the video lectures of this curriculum. The new element is verified to make sure that it is greater than its parent, for a minimum heap tree. If it is less than its parent, the tree must be re-arranged until either it has a parent less than itself or it has become the root of the heap.

















Graph
    A data structure in programming (not to be confused with a geometry style graph of a line or a parabola) which consists of a set of vertices (nodes) and edges (connections).
Vertex
    An object in a graph, sometimes called a node.  This object could be a city on a roadmap, an event in a chain of events, or any number of things.
Edge
    The connection in a graph between two vertices, such as the road between two cities, or the process to get from one event in a chain to the next event.
Directed Graph
    This is a graph where an edge has a direction associated with it, for example, a plane flight that takes off in one location and arrives in another. The return flight would be considered a separate edge.
Undirected Graph
    A graph that contains edges between vertices with no specific direction associated with any edge, like a bridge across a river where traffic can travel in either direction.











1D and 2D Array Practice
problem


Consider the following class Student:
class Student
    int age
    string name

Now consider the following array:
Student[] englishClass = new Student [ 10 ]

Assuming no other code has been executed, which of the following statements is false?
englishClass can contain up to 10 instances of Student
Upon declaration of englishClass, individual elements contain a Student with age 0 and a blank name correct
Each element of englishClass is currently blank.
The length of englishClass can be determined

Explanation

When creating an array of objects, the individual elements of the array are blank, and contain no Student objects (some languages use the value null to indicate this) until they are individually assigned with a new instance, such as with englishClass[2] ← new Student()


problem


A programmer is writing pixel image editing software and has created the following data structures for use in the software:
class Pixel
    int r, g, b

class Image
    Pixel [][] raster

class Album
    Image [] photos

If there is a variable called vacation that is an instance of Album, which of the following is a valid way of accessing an individual Pixel?
vacation.raster[ 200 ][ 300 ]
vacation.photos[7].raster[ 200 ][ 300 ] correct
vacation[7].photos.raster[ 200 ][ 300 ]
vacation.photos[7].raster[ 200 ][ 300 ].r

Explanation

Consider what is an instance and what is an array of instances. vacation is an instance of Album. Therefore, to access an individual Image the reference must be vacation.photos[7]. Each instance of Image contains a field called raster which is a 2D array of pixels.


problem


A programmer is creating video software and has defined the following data types:
class Frame
    int [][] redRaster ← new int[ 1920 ][ 1280 ]
    int [][] greenRaster ← new int[ 1920 ][ 1280 ]
    int [][] blueRaster ← new int[ 1920 ][ 1280 ]

class Movie
    Frame [] frames

If there is a variable called clip, what is a valid way of initializing the frames so that it is ready to contain 200 instances of Frame?
clip.frames[ 200 ] ← new Frame()
clip.frames ← new Frame( 200 )
clip.frames [ 200 ] ← new Frame [ 200 ]
clip.frames ← new Frame [ 200 ] correct

Explanation

To create a new array of objects, use the new keyword, followed by the class name, followed by hard brackets [ ] with the number of elements.


problem


A programmer needs to store information about a list of students, including information about age, height, grade point average and class rank. Individual student names should not be stored, for privacy reasons. Which of the following represents the best data structure to accomplish this task?
Separate parallel 1D arrays for age, height, grade point average and class rank
One 1D array of a student record class that contains age, height, grade point average and class rank correct
One 2D array where each row corresponds to a single student and there are separate columns for age, height, grade point average and class rank.
One 2D array where each column corresponds to a single student and there are separate rows for age, height, grade point average and class rank.

Explanation

Standard practice concerning records (individual collections of named data for a particular student) is to create a class representing an individual and then creating a single 1D array to contain multiple instances of the record class.


problem


Consider the following code:
int [] a ← { 4, 5, 6 }
int [] b ← { 1, 2, 3 }
int [] c ← { 7, 8, 9 }
int [][] d ← { c, b, a }

What is the value of d after this code is executed?
{ 7, 8, 9, 1, 2, 3, 4, 5, 6 }
{ { 7, 8, 9, 1, 2, 3, 4, 5, 6 } }
{ { 7, 8, 9 }, { 1, 2, 3 }, { 4, 5, 6 } } correct
{ 7, 8, 9, { 1, 2, 3, { 4, 5, 6 } } }

Explanation

d is a 2D array. Recall that 2D arrays are simply arrays of arrays. Therefore, when represented as an array constant, it will be a set of { } with individual, comma separated sets of a { }.


problem


Assume there is a function len which returns the number of elements in an array. Assume the following class has been defined:
class Student
    int grade

Now consider a function average, designed to return the average of the grade field of each element of classroom:
float average(pass-by-value Student [] classroom)
  float sum
  // Iterate through classroom
  return sum / len( classroom )
end average

Choose code that can be substituted for // Iterate through classroom that will fulfill the post-condition.

for (int i ← 0; i < len ( classroom ); i ← i + 1)
    sum ← sum + classroom.grade
end for

for (int i ← 0; i < len ( classroom ); i ← i + 1)
    sum ← sum + classroom.grade[ i ]
end for

for (int i ← 0; i < len ( classroom ); i ← i + 1)
    sum ← sum + classroom[ i ].grade
end for
correct

for (int i ← 0; i < len ( classroom ); i ← i + 1)
    sum ← sum + classroom[ grade ]
end for

Explanation

To access the an individual student's grade, first reference the array cell classroom[ i ] and then the grade field with classroom[ i ].grade





Stack and Queue Practice
problem


Which of the following statements is true about stacks and queues?
push is analagous to dequeue
pop is analagous to enqueue
push is analagous to enqueue correct
peek is functionally the same for both stacks and queues

Explanation

Push is analagous to enqueue in that both add elements to their respective data structures. Peek is not functionally the same for both stacks and queues, because it will return the newest element of a stack, whereas in a queue it will return the oldest element.


problem


Consider a class Hybrid, designed to implement both stack and queue implementations of push, pop and peek. It uses an array int [] contents to store data, where contents[ 0 ] will always be the oldest element in the data structure and contents[ highest ] will always be the newest element in the data structure.

A programmer is adding two methods -- int stackPeek( ) and int queuePeek( ), designed to implement the stack version of peek and the queue version of peek, respectively. What are descriptions of implementations for these methods?
stackPeek( ) would return contents[ highest ] and queuePeek would return contents[ highest ]
stackPeek( ) would return contents[ 0 ] and queuePeek would return contents[ 0 ]
stackPeek( ) would return contents[ 0 ] and queuePeek would return contents[ highest ]
stackPeek( ) would return contents[ highest ] and queuePeek would return contents[ 0 ] correct

Explanation

The stack version of peek should return the newest element of the list, while the queue version of the peek should return the oldest element in the list.


problem


An operating system must use stacks and queues to execute methods and instruction sets. Method calls must be placed in one data structure, while instruction sets must be placed in a separate data structure. Methods must be executed with the most recently added methods finishing first. Instruction sets must be executed with the oldest instructions finishing first. Which of the following is an appropriate selection of data structures for methods and instruction sets?
A stack for methods and a stack for instruction sets
A queue for methods and a queue for instruction sets
A stack for methods and a queue for instruction sets correct
A queue for methods and a stack for instruction sets

Explanation

Stacks behave in a last-in, first-out fashion. That is, the most recently added items are removed first. Therefore, it is an appropriate selection for handling methods in this operating system. Because instruction sets are handled in a first-in, first-out fashion, queues are an appropriate selection for handling instruction sets.


problem


Which of the following is a true statement for both Stacks and Queues?
The last element pushed will be the first element popped
Peek will return the least recently pushed element
Peek will return the most recently pushed element
Peek will not modify the data structure correct

Explanation

The only guarantee of any operation that is common between stacks and queues is that neither data structure's peek operation will modify the contents of the structure


problem


Consider the following implementation of a Navigation class, designed to provide sequential upcoming destinations while allowing a user to backtrack through visited destinations in reverse chronological order:
class Navigation
    Queue upcoming ← Queue()
    Stack visited ← Stack()

    function addUpcoming( Destination place )
        upcoming.enqueue( place )
    end function

    Destination backtrack( )
        return visited.pop()
    end backtrack

    Destination next( )
        // next function body
    end next

If each subsequent call to the method next is intended to traverse the upcoming queue of destinations while filling the backtrack stack, which of the following is a valid implementation for next?

visited.push( upcoming.peek() )
return upcoming.peek()

visited.push( upcoming.pop() )
return upcoming.peek()

visited.push( upcoming.pop() )
return upcoming.pop()

visited.push( upcoming.peek() )
return upcoming.pop() correct

Explanation

The next method should add the item at the front of the upcoming queue. However, only by peeking for this value will the next call to upcoming.pop() retrieve the next destination without "skipping" over the one that was just added to the visited stack.


problem


Consider the following code block:
Stack s ← new Stack()
Queue q ← new Queue()
s.push( 3 )
s.push( 5 )
q.push( 3 )
q.push( s.peek() )
q.pop()
s.push( 8 )
s.push( 9 )
q.push( s.pop() )
q.push( s.pop() )
q.pop()
q.pop()

What value will be returned by a subsequent call to q.peek?
3
5
8 correct
9

Explanation

Recall the difference between stacks and queues - pushing will always add to the "end" of the data structure, but popping will remove from the "end" of a stack and the "beginning" of a queue.



















Big O Analysis of Algorithms

In computing, processes (a.k.a algorithms) need to be as efficient as possible, and in order to determine efficiency, a system was devised called Order of Magnitude, often referred to as Big O.  The main idea is to count, to a certain degree of precision, the number of significant steps it takes for an algorithm to complete the job, based on the value N, which represents the size (number of elements) of the data set on which the process is performed. There are various ways to measure efficiency, and this Big O process is the most general way.  In a college level algorithms class, you (or your students) will explore more specific and precise ways to analyze efficiency, but for the purposes of this course and for the certification test, this fundamental knowledge will suffice.
Searches

We'll cover two basic search types: the linear search and the binary search. We'll look closely at the pseudocode for each and break down how its parts work. We'll also look at the Big O running time designation for the best, average, and worst case scenarios for each search.
Sorts

We'll cover five sorts in this section:

    Selection
    Bubble
    Insertion
    Merge
    Quick

There are other search algorithms, but these are sufficient to serve the purposes of this course.

For each sort, we'll begin with a story played out with a deck of cards. This is an excellent teaching strategy that we encourage you to use with your classes! Have a deck of playing cards handy. We'll then look closely at both the pseudocode and the Big O running time efficiency for each sort in the best, average, and worst case scenarios.
Big O Revisited

We'll wrap up this section with a summary of Big O and the best, average, and worst case scenario for all of the searches and sorts we covered.








OOP Basic Class Design
Access Modifier
    Access modifiers (or access specifiers) are keywords in object-oriented languages that set the accessibility of classes, methods, and other members. The two most common are private and public, where private limits access only to members of the class, and public grants open access.
Class Method
    A process in a class definition that acts on the data that belongs to that class.
Class Variable
    A variable that belongs to the class, and is not specific to any particular object, indicated by the word "static", of which only a single copy exists, regardless of how many instances of the class exist.
Construct
    The process of instantiating (bringing into existence) an object based on a class definition.
Constructor
    A method in a class definition whose sole responsibility is to construct a new object. Classes can have many versions of constructors, a key feature of polymorphism called overloading.
new
    A reserved word in several languages that asks the compiler to instantiate a new object.

UML Diagram of the StudentInfo Class

The video showed you the pseudocode version of what a class might look like. Remember that you can use a UML diagram to visualize your class design before you create it.

Here is what the StudentInfo class would look like in a UML diagram.







Class Design Practice

For all of the following questions, refer to this class definition:

class StudentInfo
  private int studentID

  void setStudentID(int i)
    studentID ← i
  end setStudentID

  int getStudentID()
    return studentID
  end getStudentID
end class
problem


If there is client code with a reference to an instance of StudentInfo named s, what is the right way to set the studentID member of s to the value 12345?
s.studentID ← 12345
s.getStudentID(12345)
s.setStudentID(12345) correct
s.studentID ← s.getStudentID(12345)

Explanation

The setStudentID mutator must be used to modify the value of studentID in client code, because the client does not have permission to access studentID directly due to it being marked as private. Therefore, a call to s.setStudentID(12345) is necessary.


problem


Consider the class definition above.

Now consider the following client code:
StudentInfo [] list = new StudentInfo[5]

Which of the following statements is true?
list is an instance of StudentInfo with a value of 5
list is an array that can contain 5 instances of StudentInfo correct
list is an array of StudentInfo, each with a value of 5
list is an array of 5 instances of StudentInfo each with a studentID value of 5

Explanation

The client code establishes an array called list. The type of values in this array are references to instances of StudentInfo. The capacity of the list is 5 elements. However, this code does not create any individual instances of StudentInfo, nor would it modify the class variables of any instances of StudentInfo that have yet to be created.


problem


Consider the class definition above.

Now consider the following array definition in code:
StudentInfo [] list = new StudentInfo[5]
    // ... code to fill the array with StudentInfo objects

Which of the following client pseudocode segments would print the studentID of each element in list?

for (int i ← 0; i < 5; i ← i + 1
    print list[ i ]
end for

for (int i ← 0; i < 5; i ← i + 1
    print list[ i ].studentID
end for

for (int i ← 0; i < 5; i ← i + 1
    print list[ i ].setStudentID()
end for

for (int i ← 0; i < 5; i ← i + 1
    print list[ i ].getStudentID()
end for correct

Explanation

The loop must access each element of list using list[ i ]. However, note that there is no toString method defined, meaning that studentID must be further accessed. Because studentID is private, it must be accessed using getStudentID


problem


Which of the following is a true statement that describes the best use of mutators and accessors?
Mutators and accessors provide encapsulation and abstraction to public class variables
Mutators and accessors are not required for private class variables
Mutators and accessors provide encapsulation and abstraction to private class variables correct
Mutators and accessors are required for public class variables

Explanation

Mutators and accessors are typically associated with private class variables. There are many use cases where the modification of a private class variable must result in some other internal record keeping or state change that client code is not privy to. The hiding of such internal record keeping or state change is called "encapsulation", or "information hiding". The operation that is encapsulated is said to have achieved "abstraction", because the client code only sees the abstraction of the operation, not the details of the operation themselves. Because such abstraction is not possible with publicly visible class variables, mutators and accessors are never required for them.


problem


If a proper constructor is added to the class definition, which of the following is a valid statement for creating an instance of StudentInfo?
StudentInfo s ← "Jane"
StudentInfo s ← new StudentInfo
StudentInfo s ← new("Jane")
StudentInfo s ← new StudentInfo("Jane") correct

Explanation

To create an instance of a class, its constructor must be called, typically with the new keyword. Parameters such as initial values of class variables can be passed to the constructor, which shares the name of the class itself.


problem


Which of the following statements about the class StudentInfo is true?
getStudentID is a mutator for studentID
setStudentID is an accessor for studentID
setStudentID is a mutator for studentID correct
studentID is publicly accessible to client code

Explanation

Because studentID is a private class variable of StudentInfo, client code may not access it directly. Instead, getStudentID and setStudentID must be used. Mutator functions modify a class variable, while Accessor functions simply return the value in the class variable. Therefore, setStudentID is a mutator for studentID




Array of Objects
Accessor Method
    Method in a Java class that allows and controls access to private data of objects.

A Note about the Term "Record"

The standards mention knowing about "arrays of records".  This terminology is associated with past programming languages, like Pascal and C++, and means the same thing as "arrays of objects" associated with OOP design.  A record is a data type just like an object is, containing data and actions associated with the data, and is considered the forerunner of the OOP object.









Powers of Two Table

Here's what the Powers of Two look like in table form.

N	  2^N
0 	1
1 	2
2 	4
3 	8
4 	16
5 	32
6 	64
7 	128
8 	256
9 	512
10 	1024
11 	2048
12 	4096




Order of Magnitude: Big O
Algorithm
    Procedure or formula for solving a problem and finding an exact example, as opposed to a heuristic, which calculates an approximate, or educated guess.
Algorithm Analysis
    A general process that determines the amount of resources (such as time and storage) necessary to execute any particular algorithm, most commonly using Big O notation, such as O(N) or O(N^2).
Big O Notation
    A notation system used to classify algorithms (see algorithm analysis). The primary notation levels are: O(1), O(log N), O(N), O(N log N), and O(N^2).
Constant Run Time
    An algorithm is said to be constant time (also written as O(1) time) if process only involves one step, regardless of the size of the array, such as accessing any particular element in a static array.
Linear Run Time (Linear Process)
    Linear run-time is a level of algorithm complexity which requires the number of steps directly proportional to the size of the data structure in order to process, such as outputting all of the elements of an array, or performing a linear search on an array of values.
Logarithmic Run Time
    Logarithmic run time is a level of complexity which requires the number of steps roughly equivalent to the log value (base 2) of the size of the data set. For example, for a set of 1000 values, the approximate log base 2 value of 1000 is 10, which means it would take at most 10 steps for an O(log N) algorithm to perform its task on 1000 items in a data structure. The most well-known O(log N) algorithm is the binary search (see the video on the dictionary search).
Order of Magnitude
    In the analysis process for algorithms, the order of magnitude of an algorithm is roughly the number of steps it takes in order for the algorithm to execute, most often expressed using the Big O notation system.
Quadratic Run Time
    A level of complexity of an algorithm that is characterized by a nested loop process, taking roughly N^2 steps to complete, so for an array size of 10 items, it would take roughly 100 steps to complete the process.

The Five Levels of Big O

O(1) - Regardless of the size of N, a process with a running time of O(1) takes 1 step to accomplish the task.  This is like searching through a list of items and finding the target on the first try.

O(N) - A process with this running time (often called "linear") will take roughly the same number of steps as there are items in the list, like outputting all of the values in a list, or searching through a list one item at a time and finally finding the target item in the final step, or discovering that the item is not there. It is most commonly characterized by the use of a loop that starts at the first item and goes one step at a time all the way to the last item in the list.

O(N^2)- A process with this running time (often called "quadratic")  is characterized by the use of two loops, one inside the other, often referred to as "nested loops". Three of the sorts you will study - Selection, Bubble, Insertion - have this basic structure and running time efficiency.  This simply means that it will take roughly N times N steps to process a collection of N data items.  For example, if the list contains 10 items, it will take approximately 100 steps to complete the process. This is generally considered a very inefficient process, and should not be used with significantly large values of N.

O(log N)- A process with this running time is very efficient because it uses a "divide and conquer" process, characterized by a division by 2 as an integral part of the code implementation.  For example, for a data set of 128 items, the number of times required for a log N algorithm is 7 steps.  The value 7 is the log, base 2, of 128, hence the term "O(log N)". The binary search process is the classic example of this, and is demonstrated in the Binary Search video, which searches for a word in a dictionary and finds it quite quickly using this process. This running time is less efficient than O(1), but much more efficient than O(N).

O(N log N)- This running time is a product of N and log N, which means that a process that is measured at this efficiency uses a combination of "divide and conquer" with N steps, resulting in the N times log N total steps. For a data set of 128 items, which we discussed above as having a log N of 7 steps, the product of 128 and 7 is 896 steps, which means that this process would take that many steps to complete.  Compared to an O(N^2) process using the same N value of 128 data items, requiring 128 times 128, more than 16,000 steps, 896 steps is very efficient in comparison.  Two of the sorts you will study have this running time for the most part: merge sort and quick sort. This running time is less efficient than O(N), but much more efficient than O(N2).
Big O Table

Remember that Big O is a set of values that help us understand how many steps it will take a particular algorithm to process a certain number of pieces of data.
N	    O(1)	O(log N)	O(N)	       O(N log N)	       O(N^2)
2 	   1 	  1 	      2 	         2 	               4
3 	   1 	  2 	      3 	         6 	               9
4 	   1 	  2 	      4 	         8 	               16
6 	   1 	  3 	      6 	         18 	             36
10 	   1 	  4 	      10 	         40 	             100
50 	   1 	  6 	      50 	         300 	             2500
100    1 	  7 	      100 	       700 	             10,000
1000 	 1 	  10 	      1000 	       10,000 	         1,000,000
2000 	 1 	  11 	      2000 	       22,000 	         4,000,000





Linear Search
    A loop based search process using an array of values that starts looking at the first of the list and continues towards the end of the list until the target is found, or until the end of the array is reached.

Linear Search Pseudocode

int linearSearch( int [] list, int target)
   for(int j ← 0; j < list.length; j ← j + 1)
     if (list [j] == target) //if element at position j is target element
       return j //return the number j
     end if
   end for
 return -1 //otherwise, if element not found, return -1
end linearSearch

Best, Average, and Worst Case for a Linear Search

This search process is very simple.  It starts at the beginning of the list, looks at each item one at a time, all the way through the list, and stops when it finds the item, or when it has traversed the entire list and discovered the item is not there.  It is generally regarded as an O(N) algorithm.
	                 Big O Notation	               Case Description
Best Case 	        O(1) 	                        Target is the first element in the list
Average Case 	      O(N) 	                        Target is somewhere in the middle of the list
Worst Case 	        O(N) 	                        Target is last element or not in the list





Linear Search Practice
problem


Consider the following pseudocode for a linear search:
int linearSearch( int [] list, int target )
    for (int i ← 0; i < list.length; i ← i + 1 )
        if ( list[ i ] == target )
            return i
        end if
    end for
    return -1
end linearSearch

Which of the following is a pre-condition for this linear search?
list is sorted
target is guaranteed to be a value contained in list
list must have a length of at least 1
None of the above correct

Explanation

This implementation of a linear search handles all of the above conditions. list is not required to be sorted because the algorithm does not optimize for a sorted list, which is generally a requirement of a binary search. If target does not exist, -1 is returned. If list has a length of 0, -1 is returned.


problem


Consider a list:

{ 9, 2, 6, 8, -3 }

If a linear search for the value 2 is performed, what will be returned?
-1
1 correct
2
5

Explanation

A linear search will return the index of the target value. In this case, the value 2 occupies index 1.


problem


Which of the following is not a post-condition of a linear search?
The index of the target value is returned if it occurs within the list
-1 is returned if the target value does not occur within the list
The list is modified to maintain a sorted order correct
The list does not get modified

Explanation

Sorting a list is beyond the scope of searching through a list. A search should not modify the list and typically will return either the index of the target value or -1 if the value does not occur within the list.


problem


Which of the following is an application of a linear search?
Maintaining sorted order on a list
Determining if a value exists within a list correct
Determining the length of a list
Filling a list with a specified value

Explanation

A linear search will return the index of the target value, or -1 if it does not exist within a list. Because of this expected post-condition, a linear search can be performed for the express purpose of seeing if a value exists within a list. If the returned value is not -1, then the value exists within the list.


problem


What is the worse case order of complexity for a linear search?
O(1)
O(N) correct
O(N log N)
O(N2)

Explanation

An order of complexity that is O(N) is generally refered to as "linear" complexity. In a worst case linear search on an array of N elements, all N elements would be examined resulting in N operations.


problem


Consider a list:

{ 9, 2, 6, 8, -3 }

If a linear search for the value 20 is performed, what will be returned?
-1 correct
-3
4
5

Explanation

If a linear search is unable to find the index of a target value because the value does not exist within the list, -1 is returned to indicate the absence of the value.








Binary Search
    The process of searching through an ordered set of data using the "divide and conquer" technique, which guarantees a final result in O(log N) steps.

Binary Search Pseudocode

int binarySearch( int [] list, int target)
  int left ← 0,
      right ← list.length - 1
  while(left <= right)
    int middle ← (left + right) / 2
    if (target == list[middle]) //target found
      return middle
    else
      if (target < list[middle]) //look left
        right ← middle - 1
    else
      left ← middle + 1 //look right
    end if else chain
  end while
return -1 //otherwise, if element not found, return -1
end binarySearch

Best, Average, and Worst Case for a Binary Search

As mentioned above, this search process is very efficient, but has one important precondition: the incoming list must be in sorted order, as is the case with a dictionary.  It uses a "divide and conquer" approach, and is generally regarded as an O(log N) process.
	                 Big O Notation	Case        Description
Best Case 	          O(1) 	                    Target is the first middle position
Average Case 	        O(log N)
Worst Case 	          O(log N)




Binary Search Practice
problem


In which of the cases listed below would a binary search perform worse than a linear search?
When the target value is the first element of the list. correct
When the target value is the middle element of the list.
When the target value is the last element of the list.
When the target value does not exist within the list.

Explanation

If a value appears at the beginning of a list, a linear search will return an answer after only one comparison operation, a running time of O(1). For a binary search, the extremes of the list (first or last element) would be considered a worst case scenario. In almost every other situation, a binary search requires fewer comparisons than a linear search.


problem


A binary search is performed on a list of 40 elements in ascending sorted order. What is the worst case running time performance (most number of comparisions required) when searching for a value that does not exist within this list?
1 comparison
5 comparisons
6 comparisons correct
40 comparison

Explanation

Binary searches perform with O(log2 N) average or worst case performance. A quick way to determine this is to find the approximate base 2 log of the N value. In this case, the N value of 40 falls in between the 5th and 6th powers of 2, or 32 and 64. The values 5 and 6 are exponents, or logs. The appropriate log to use is the larger of the two, therefore a maximum of 6 comparisons are required to locate a value, or to determine that the value does not exist at all within the list.


problem


Consider a list:

{ -3, 5, 9, 12, 24, 31, 46, 48 }

If a binary search for the value 48 is performed, how many comparison operations will be required to locate its index?
1
3
4 correct
8

Explanation

There are four middle values considered in this search. The first middle value is 12, then 31, then 46, and finally 48, where the target is found. Even though the log, base 2, of 8 is 3, the fact that this search takes 4 steps represents a worst case scenario, which is still close enough to consider it a O(log N) process.


problem


Which of the following is a required pre-condition of a binary search?
The target value exists within the list being searched.
The list being searched must be in random order.
The list being searched is in ascending sorted order. correct
The number of elements in the list being searched is a power of 2.

Explanation

The only requirement for a binary search is that the list being searched is in ascending sorted order. If a value doesn't exist within the list being searched, a negative value will be returned to indicate that the value was not found.


problem


Which of the following describes a feature of the binary search?
Every element of a searched list is examined.
A divide and conquer strategy is used correct
A linear strategy is used
Random elements are chosen from the list until the item is found.

Explanation

A binary search is a divide and conquer algorithm. Binary algorithms typically involve a divde and conquer approach. The middle position is examined first, and if it is not a match, either the left side of the list is considered, or the right side. This process is repeated until the item is found, or until it is determined that the target does not exist in the list.


problem


Consider a list:

{ -3, 5, 9, 12, 24, 31, 46, 48 }

If a binary search for the value 33 is performed on this list, how many comparisons will occur before an answer is returned?
3 correct
4
5
6

Explanation

There are three middle values considered in this search. The first middle value is 12 in position 3. Since 33 is greater than 12, the left marker is reset to position 4, and the right half of the list is now considered (positions 4 through 7). The new middle position is 5, which contains 31. The value 33 is greater than that, so again the left marker is adjusted to position 6, with right still at 7. The next middle position is 6, which contains 46. Since 33 is less than 46, the right marker is set to one spot before the 46 (position 6), which is now the position 5, effectively stopping the search because the left and right markers have crossed, indicating that 33 is not there.
















Selection Sort Trace, Analysis, and Pseudocode
Selection Sort
    A sorting routine that uses a nested loop process to systematically select the best value among the unsorted elements of the array for the next position in the array, starting with position zero all the way to the end.
Sort
    An algorithm used to arrange elements of an array into natural order, such as numeric or alphabetical.
Swap
    The process in sort routines of exchanging two values in an array, using a temporary variable, taking three steps to execute.

Selection Sort Psuedocode

void selectionSort( pass-by-reference int [] list)
  for (int k ← 0; k < list.length; k ← k + 1)
  //k loop begins at position 0 and stops one position short of end of list
   int best ← k //assume that position k has best value
   for (int q ← k + 1; q < list.length; q ← q + 1)
   //q loop searches the rest of the loop for a better value
      if (list[q] < list[best]) //if q indicates a better value
        best ← q //best gets q
   end for //end q loop
  swap (list, k, best) //swap values at position k and best
  end for //end k loop
end selectionSort
//three step swap process
void swap (pass-by-reference int [] list, int i, int j)
  int temp ← list[i]
  list[i] ← list[j]
  list[j] ← temp
end swap

Best, Average, and Worst Case for a Selection Sort

This sort systematically looks through the list, selecting the best value for each position, starting at one end and working towards the other.  For example, for the first position of the list, a search is conducted through the rest of the list to find a better value, if there is one, and then a swap is made between those two items.  The process is then repeated for the next position, and for the next one, and so on, until the entire list is in order. The basic structure is a nested loop process, which has a basic running time of O(N^2), often referred to as a "quadratic sort".
	                             Big O Notation	Case                     Description
Best Case 	                   O(N^2) 	                                   All elements already in order
Average Case 	                 O(N^2) 	                                   Elements in random order
Worst Case 	                   O(N^2) 	                                   Elements in reverse order





Selection Sort Practice
problem


Consider the following array, to be sorted using selection sort:

{ 7, 2, 6, 4, 5, 0, 3, 1 }

How many passes must be performed on this selection sort before the value 3 is in its right position, assuming that the selection sort is intended to produce a list sorted in ascending order?
3
4 correct
7
8

Explanation

In each pass of a selection sort, the next smallest value (in an ascending sort) is placed in the right position. Because the value 3 would be the smallest value found during the 4th pass through the list, 4 passes are required before the value 3 is placed in the right index.


problem


Which of the following describes a selection sort?
Values that are out of place are shifted into order.
Adjacent values are compared and swapped if out of order.
The next "best" value is swapped into its right position with each pass. correct
The list is partitioned around a pivot point.

Explanation

A selection sort selects the next "best" value and swaps it into its right position with each pass. An insertion sort shifts values that are out of place into the right order. A bubble sort compares adjacent values and performs swaps. A quicksort partitions a list around pivot points.


problem


Consider a partially sorted list that is undergoing the selection sort:

{ 0, 1, 7, 5, 4, 2, 3 }

If the values 0 and 1 have already been sorted, how many comparisons must be performed in the next pass of the selection sort?
1
3
4 correct
5

Explanation

In each pass of the selection sort, the next place to be sorted is assumed to have the smallest value. Each place after that is compared to select the smallest value. In this case, the cell with the value 7 is where the next smallest value will be stored. Temporarily, the value 7 is assumed to be the smallest before the selection is performed. Because there are 4 additional cells that may potentially contain the smallest value, 4 comparisons are performed.


problem


Consider the following array, partially sorted with a selection sort.

{ 0, 1, 6, 4, 5, 2, 3, 7 }

If two passes have already been performed such that the values 0 and 1 are in the right position, what will the array look like after the next pass?
{ 0, 1, 4, 5, 2, 3, 6, 7 }
{ 0, 1, 2, 4, 5, 6, 3, 7 } correct
{ 0, 1, 4, 6, 5, 2, 3, 7 }
{ 0, 1, 2, 6, 4, 5, 3, 7 }

Explanation

In each pass of a selection sort, the next smallest value (in an ascending sort) is placed in the right position. The only values that are swapped are the next smallest value and the value in the position where the next smallest value should go. In this case, the next smallest value after 0 and 1 is 2. Therefore, the value 6 (where the 2 should go) will be swapped into the position that 2 currently occupies.


problem


Assume there is a function defined swap( pass-by-reference int [] list, int position1, int position2 ) which swaps values in the array list at index position1 and index position2. Now consider the following code for a selection sort:
void selectionSort( pass-by-reference int [] list )
    for ( int k ← 0; k < list.length - 1; k ← k + 1 )
        int best ← k
        for ( int q ← k + 1; q < list.length; q ← q + 1 )
            if ( condition )
                best ← q
            end if
        end for
        swap( list, best, k )
    end for
end void

Which of the following boolean expressions would best replace condition to cause the selection sort to sort values in list in descending order?
best < list[ q ]
best > list[ q ]
list[ best ] > list[ q ]
list[ q ] > list[ best ] correct

Explanation

In the code for this selection sort, the assignment statement that re-assigns the value best replaces the current value with an array index. In this case, the index is determined by the loop variable q. Therefore, the comparison statement should compare the list value retrieved from index best with the list value retrieved from index q. In addition, because the sort should perform the selection sort in descending order, the comparison should look for the next greatest value in the list. Therefore the comparison should be list[ q ] > list[ best ]





Bubble Sort
    A simple (and relatively slow) sorting algorithm that repeatedly loops through a list of values, comparing adjacent values and swapping them if they are in the wrong order.

Bubble Sort Psuedocode

void bubbleSort( pass-by-reference int [] list)
  boolean done ← false //this step gets you into the while loop
  while (NOT done)
   done ← true //assume list is sorted
   for (int k ← 0; k < list.length - 1; k ← k + 1) //look of "out of order" neighbors
     if (list[k + 1] < list[k])
     //if value of next-door neighbor is less than current value
       swap (list, k, k + 1) //swap the two values
       done ← false //set done to false
     end for //end k loop
  end while
end bubbleSort
//three step swap process
void swap (pass-by-reference int [] list, int i, int j)
  int temp ← list[i]
  list[i] ← list[j]
  list[j] ← temp
end swap

Best, Average, and Worst Case for a Bubble Sort

This sort continuously iterates through the list, swapping neighboring values that are out of order, until it achieves a "clear pass", which means no swaps are made in the last pass through the list. It can be very efficient when the list is already in order, or very inefficient when the list is completely reversed.

Due to its nested loop structure, it is also considered a "quadratic sort", with running time of O(N^2).
	                     Big O Notation	                       Case Description
Best Case 	            O(N) 	                                 Elements already in order
Average Case 	          O(N^2) 	                               Random list
Worst Case 	            O(N^2) 	                               Elements in reverse order








Bubble Sort Practice
problem


Which of the following describes a bubble sort?
List contents are placed in a minimum heap.
Adjacent values are compared and swapped if out of order. correct
The next smallest value is moved directly into its right position with each pass.
The list is partitioned around a pivot point.

Explanation

A selection sort finds the best value for the current position with each pass. An insertion finds the best position for the next value. A bubble sort repeatedly compares adjacent values and performs swaps. A quicksort partitions a list around pivot points.


problem


Which of the following does not describe part of the process for an ascending bubble sort?
For n values, perform at least 1 pass, but no more than n-1 passes.
Compare adjacent values, and if they are out of order, swap them.
Find the next smallest value in the remaining unsorted elements. correct
After each pass, the next highest unsorted value should be in the right position.

Explanation

A bubble sort performs at least 1 pass, and no more than n-1 passes on n values. In each pass, each adjacent "neighbor" value is compared to see if they are out of order. If so, they are swapped. After each pass, the next highest value should be in the right position if the sort is in ascending order. Finding the smallest value in remaining unsorted elements is a characteristic of the selection sort.


problem


Assume there is a function defined swap( pass-by-reference int [] list, int position1, int position2 ) which swaps values in the array list at index position1 and index position2. Now consider the following code for a bubble sort:
void bubbleSort( pass-by-reference int [] list )
    boolean b ← false
    while ( not b )
        b ← true
        for ( int k ← 0; k < list.length - 1; k ← k + 1 )
            if ( list[ k ] > list[ k + 1] )
                swap( list, k, k + 1 )
                b ← false
            end if
        end for
    end while
end void

What is the purpose of the b variable?
Determines if a swap should occur
Determines if swaps have occurred during a pass correct
Determines the number of comparisons that should occur during a pass
Determines if a comparison has taken place during a pass

Explanation

The purpose of b is to allow the bubble sort to terminate if no swaps have occurred during a pass, which means the list is in sorted order. The pass is performed by the for loop in this implementation. The for loop iterates through adjacent neighbors and performs comparisons. The comparison takes place regardless of the value of b. In addition, the swap will take place conditionally if the adjacent neighbors are out of order, but b will not intrinsically cause this swap to occur. If the swap does occur, however, b is flagged as false, meaning the outer while loop will continue to perform passes until a pass happens where no swapping happens. In this case, the list is sorted and the while loop will terminate.


problem


Consider the following array, to be sorted using bubble sort in ascending order:

{ 7, 2, 6, 4, 5, 0, 3, 1 }

How many passes must be performed in this bubble sort before the value 7 is in its right position at the end of the list?
0
1 correct
7
8

Explanation

In each pass of a bubble sort, adjacent neighbors are compared and swaps may occur. 7 swaps will occurin order to move the value 7 to into its proper position. This will occur in a single pass since it is the larget value in the list. In each pass of an ascending bubble sort, the next largest value will move to its right position in the list.


problem


Consider the following array:

{ 0, 1, 6, 4, 5, 2, 3, 7 }

After one pass of an ascending order bubble sort is applied, what will this array look like?
{ 0, 1, 4, 5, 2, 3, 6, 7 } correct
{ 0, 1, 2, 4, 5, 6, 3, 7 }
{ 0, 1, 4, 6, 5, 2, 3, 7 }
{ 0, 1, 2, 3, 4, 5, 6, 7 }

Explanation

In each pass of a bubble sort, the next largest unsorted value will move to the right place. In this case, 7 is in its sorted position, so the next largest value that has yet to be sorted will be 6. As swaps are performed, 6 will move to the place before 7, with all other values remaining in relative position as before.


problem


Consider a partially sorted list that is undergoing the bubble sort in ascending order:

{ 3, 4, 6, 5, 1, 2, 7 }

If the value 7 has already been sorted, which will be the next value to be placed in its final position after the next pass?
1
3
5
6 correct

Explanation

Bubble sort passes are performed by comparing adjacent values and swapping them if they are out of order. The value 6 will continually move up in the next pass until it occupies the index before 7. This is its final position.

Insertion Sort Trace, Analysis, and Pseudocode
Insertion Sort
    A type of sort that uses a nested loop process to systematically find the best place in the current array for an unsorted item.

Insertion Sort Psuedocode

void insertionSort( pass-by-reference int [] list)
  for (int k ← 1; k < list.length; k++)
  //k loop starts at position 1 and stops at end of list
    int temp ← list[k] //save a copy of the current value to be inserted
    int best ← k //assume current position is best, BUT...
    while (best > 0 AND temp < list[best - 1]) //keep looking for a better place
    //while previous place is better and you haven't reached
    //the start of the list, shift values over 1 spot
      list[best] ← list[best - 1]
      best ← best - 1
    end while
    list[best] ← temp //insert current value in the best place
  end for //end k loop
end insertionSort

Best, Average, and Worst Case for an Insertion Sort

This sort works through an unsorted list, one value at a time, and finds the best position for the value, systematically shifting already sorted values down the way as a better position is found for an unsorted value. This process too can be very efficient when the list is already in order, or very inefficient when the list is completely reversed.

Due to its nested loop structure, it is also considered a "quadratic sort", with running time of O(N^2).
	                             Big O Notation	                   Case Description
Best Case 	                    O(N) 	                                 Elements already in order
Average Case 	                  O(N^2) 	                               Random list
Worst Case 	                    O(N^2) 	                               Elements in reverse order


Insertion Sort Practice
problem


Which of the following does not describe part of the process for an ascending insertion sort?
For n values, perform n-1 passes.
During any given pass, a nested loop must search for the best position for the current value.
Compare adjacent neighbors and swap them if they are out of order. correct
The portion of the list containing inserted values must remain sorted.

Explanation

An insertion sort works by inserting additional values from further in the list with each pass into a growing list of values that is sorted. The lower portion of the list must always be in order.


problem


Consider the following array, partially sorted with a ascending insertion sort.

{ 0, 1, 6, 4, 5, 2, 3, 7 }

If two passes have already been performed where 0, 1, and 6 are in right relative order, what will the array look like after another insertion pass?
{ 0, 1, 4, 5, 2, 3, 6, 7 }
{ 0, 1, 2, 4, 5, 6, 3, 7 }
{ 0, 1, 4, 6, 5, 2, 3, 7 } correct
{ 0, 1, 2, 3, 4, 5, 6, 7 }

Explanation

In each pass of the insertion sort, the next value in the list that has yet to be inserted will be placed in a location below its current location in order. Because 6 is the last value that was inserted, 4 will be the next value inserted. It will move to a position between 1 and 6.


problem


Consider the following array, to be sorted using insertion sort in ascending order:

{ 7, 2, 6, 4, 5, 0, 3, 1 }

How many passes must be performed in this insertion sort before the value 7 is in its right position at the end of the list?
1
4
7 correct
8

Explanation

In each pass of the insertion sort, additional values are inserted nearer to the beginning of the list with greater values eventually being pushed to the back of the list. Because 7 is the highest value in the list, it will not be placed in the right position until all lesser values have been inserted. Therefore, 7 insertion passes must be performed before it reaches its final position at the end of the list.


problem


Consider a partially sorted list that is undergoing the insertion sort in ascending order:

{ 1, 6, 7, 5, 4, 2, 3 }

How many shifts must be performed to insert the value 5 into the right position?
1
2 correct
3
4

Explanation

During an ascending insertion sort, the value to be inserted will occupy a space made available by shifting greater values one space to the right until the next value is no longer greater than the inserted value. In this case, 6 and 7 must be shifted so that 5 must be placed between 1 and 6. Therefore, 2 shifts will occur.


problem


Consider the following code for an insertion sort in ascending order:
void insertionSort( pass-by-reference int [] list )
    for ( int k ← 1; k < list.length; k ← k + 1 )
        int temp ← list [ k ]
        int best ← k
        while ( condition )
            list[ best ] ← list[ best - 1]
            best ← best - 1
        end while
        list[ best ] ← temp
    end for
end void

Which expression best replaces the condition so that the list is sorted in ascending order?
best < 0 AND temp < list[ best - 1 ]
best < 0 AND temp > list[ best - 1 ]
best > 0 AND temp < list[ best - 1 ] correct
best > 0 AND temp > list[ best - 1 ]

Explanation

There are two requirements for the while loop in an insertion sort. The first requirement is that the index being searched must always be greater than 0, so as not to go out of bounds. Therefore, best > 0 must be part of the condition. The second requirement is that as values are shifted to the right, the shifting process should stop for a sort pass when the next value should not be shifted. The while loop uses a "descending search" methodology, where the next value to be examined is at index best - 1. Therefore, if the contents of the list at the next search index is less than the value being inserted, then the best location has been found and shifting should stop.


problem


Which of the following describes an insertion sort?
All values in a list are placed in a minimum heap, which is then traversed to produce the sorted list.
n-1 passes are performed for n values where adjacent values are compared and swapped if out of order.
Additional values are inserted each pass into a portion of the list that maintains a sorted order. correct
A "divide and conquer" approach is used to break apart the list and sort smaller portions of it.

Explanation

In an insertion sort, additional values are included into a sorted "lower" portion of the list. As each value is included, it is moved into the list at a position that is "best" and maintains the sorted ordering of the "lower" portion.


Merge Sort Analysis and Pseudocode
Merge Sort
    Merge sort is a recursive algorithm that continually splits a list in half, until each half is either empty or one item, at which point the two halves are merged together in natural order, back up the division process until the entire list has been sorted.

Merge Sort Psuedocode

void mergeSort( pass-by-reference int [] list) //method for initial call
  int n ← list.length
  int[] temp ← new int[n] //creates a temporary utility array
  mergeSortHelper(list, 0, n - 1, temp)
end mergeSort

void mergeSortHelper ( pass-by-reference int[] list, int front,
                       int back, pass-by-reference int[] temp )
  if (front < back) //if front and back are not equal and have not crossed
    int mid ← (front + back)/2 //find the middle position
    mergeSortHelper(list, front, mid, temp) //sort the left side
    mergeSortHelper(list, mid + 1, back, temp) //sort the right side
    merge(list, front, mid, back, temp) //merge the two sides
  end if
end mergeSortHelper

void merge ( pass-by-reference int_array list, int front, int mid
             int back, pass-by-reference int_array temp)
  int i ← front //i marks the front of the left side list being merged
  int j ← mid + 1 //j marks the front of the right side list being merged
  int k ← front //k marks the front of the temporary list that receives
                //the two merged sides
  while (i <= mid && j <= back) //while both sides still contain values
    if (list[i] < list[j]) //if the left front value is less than
                           //the right front value
      temp[k] ← list[i] //put left front value into the temp list
      i ← i + 1 //and move up one value on the left side
    else //otherwise
      temp[k] ← list[j] //put right side front value into temp list
      j ← j + 1 //and move up one value on the right side
    end if else
    k ← k + 1
  end while

//At this point, one of the two halves of the list has been completely loaded into the
temporary array. If the left half still has values, this is the code to clean out the
remaining left half into the temporary list.
  while (i <= mid)
   temp[k] ← list[i] //put i's value into temporary list
   k ← k + 1 //step both k and i one place to the right
   i ← i + 1
  end while
//If the right half still has values, this is the code to clean out the remaining
right half into the temporary list
  while (j <= back)
   temp[k] ← list[j] //put j's value into temporary list
   j ← j + 1 //step both k and j one place to the right
   k ← k + 1
  end while
//This is the final step: load all values in the temporary list back into the
original list
  for (int x ← front; x <= back; x ← x + 1)
   list[x] ← temp[x]
  end for
end merge

Best, Average, and Worst Case for a Merge Sort

This O(N log N) process uses a "divide and conquer" process to continuously divide a list into smaller and smaller halves until each half is just one item, then reassembles, or "merges" the two smaller halves into a sorted "larger" half, repeating this divide and merge process until the entire list has been merged into one sorted list.  The efficiency of this sort is offset to a degree by the memory cost required, double the size of the list, since part of its process is the use of a temporary array the same size as the original array.
	                       Big O Notation	Case                         Description
Best Case 	              O(N log N) 	                                     Situation of the data doesn't matter for this sort
Average Case 	            O(N log N) 	                                     Situation of the data doesn't matter for this sort
Worst Case 	              O(N Log N) 	                                     Situation of the data doesn't matter for this sort


Merge Sort Practice
problem


Consider the following lists:

{ 1, 6, 7, 9 } and { 2, 3, 5, 8 }

If the lists are merged during a merge sort, what will be the resulting list?
{ 1, 6, 7, 9, 2, 3, 5, 8 }
{ 1, 2, 6, 3, 7, 5, 9, 8 }
{ 1, 2, 3, 5, 6, 7, 9, 8 }
{ 1, 2, 3, 5, 6, 7, 8, 9 } correct

Explanation

During the merge process of a merge sort, lists are combined so that the resulting list has every element in sorted order. Therefore, the merged lists would be a completely sorted list with each element from both sub-lists.


problem


Which of the following statements describes a merge sort?
Compare adjacent neighbors and swap them
Divide elements into sublists sorted around a pivot value
Select the next best value and insert them into a sorted sublist
Divide elements into sublists and then reassembles them into sorted order correct

Explanation

A merge sort uses a "divide and conquer" strategy. This is a similarity shared with the quick sort. However, no sorting or decision making about ordering is done until the division process is done and merge process takes over.


problem


Consider the following list:

{ 1, 6, 7, 3, 4, 2, 5, 8 }

If the list is sorted using the merge sort, how many total division operations will take place during the entire process of the merge sort?
1
3
7 correct
8

Explanation

Ultimately, the entire list must be divided into sublists with only 1 element each. Since there are 8 elements to begin with, it will take 7 divisions to create 8 sublists with 1 element each. For example, the first division will be into the lists 1,6,7,3 and 4,2,5,8. The left list will then be divided again into 1,6 and 7,3, and then each of them into two 1 element lists. The other side will be divided in the same way, which adds up to 7 divisions.


problem


Which of the following statements does not describe part of the merge sort process?
Evenly divide lists into smaller lists
Merge smaller lists into ordered larger lists
Divide lists into partitions using a pivot value correct
Merge smaller lists until there is only one sorted list

Explanation

Pivoting is a process used in quick sort. The merge sort divides lists into sublists of only one element before merging them back together into one sorted list.


problem


Consider the following list:

{ 1, 6, 7, 3, 4, 2, 5, 8 }

If the list is divided into two lists during the Merge sort, what would be the contents of the two smaller lists?
{ 1, 3, 4, 2 } and { 6, 7, 5, 8 }
{ 1, 2, 3 } and { 6, 7, 4, 5, 8 }
{ 1, 6, 7, 3 } and { 4, 2, 5, 8 } correct
{ 1, 6, 7, 3, 4 } and { 2, 5, 8 }

Explanation

Merge sorting always divides a list into sublists as evenly as possible. No re-ordering or logic is used to determine which elements are part of the sub-lists, other than to insure that the lengths of each sublist are as close as possible.


problem


A merge sort is perfomed on a list with 16 items. How many merge operations must take place across the entire sort operation?
1
4
15 correct
16

Explanation

In a merge sort, if there are n elements in the list, then the number of merge operations called will always be n-1 times to reassemble the entire list, the same number as the number of divisions required.


Quick Sort
    Quick sort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order.

Quick Sort Pseudocode

void quickSort( pass-by-reference int [] list, int lo, int hi)
  if (lo >= hi) //if the current values for lo and hi have met or crossed
    return //do not continue this process
  end if
  int left ← lo //left marker gets low end of current portion of list being sorted
  int right ← hi //right marker gets high end of current portion of list being sorted
  int pivot ← list[(lo + hi)/2] //pivot gets middle position value of current list
  while (left < right) //while left and right markers have not met or crossed
    while (list[left] < pivot) //look for a value to the left of the pivot that is
                               //on the wrong side and stop there, with left marking
                               //that spot.
      left ← left + 1
    end while
    while (list[right] > pivot) //look for a value to the right of the pivot that is
                                //on the wrong side and stop there, with right marking
                                //that spot.
     right ← right - 1
    end while
    if (left <= right) //if the left and right positions have not crossed,
      swap (list, left, right) //swap the two values at those positions, and
      left ← left + 1 //step left marker to the right, and
      right ← right - 1 //step right marker to the left
    end if
  end while
  quickSort(list, lo, right) //quicksort the left partition
  quickSort(list, left, hi) //quicksort the right partition
end quickSort

void swap (pass-by-reference int[] list, int i, int j)
  int temp ← list[i]
  list[i] ← list[j]
  list[j] ← temp
end swap

Best, Average, and Worst Case for a Quick Sort

This O(N log N) process also uses a "divide and conquer" process, but through a partitioning process around a pivot value, effectively moving values that are on the "wrong side" of the pivot to the right side of it, with lesser values on the left and greater values on the right. Once two partitions are rightly formed, each partition is then similarly processed with a new pivot value, creating new partitions in the same way on either side, until each partition has a size of zero or one value, at which the process stops.
	                     Big O Notation	               Case Description
Best Case 	            O(N log N) 	                     List is balanced all of the time
Average Case 	          O(N log N) 	                     List is fairly balanced, most of the time
Worst Case 	            O(N^2) 	                         List balance is off, all of the time





Quick Sort Practice
problem


Consider the following list:

{ 3, 8, 7, 12, 24, 18, 16, 14 }

Now consider the pseudocode for a quick sort pass that selects a pivot point, given a lo and hi index representing the inclusive bounds of the partition to be sorted.
void quickSort(pass-by-reference int [] list, int lo, int hi )
    int pivot = list[ ( lo + hi ) / 2 ]
    ...

What will be the pivot value, if the quick sort pass is called with quickSort( list, 4, 7 )?
5
12
18 correct
19

Explanation

Although there are many strategies for choosing a pivot that appear in different implementations of a quick sort, this particular strategy chooses a value close to the "middle" of the current partition. To find the index of the pivot, perform (4 + 7) / 2. The result is 5. Therefore, the index is 5 and the pivot value is 18 - the value contained at index 5 of the entire list.


problem


Consider the following list:

{ 1, 6, 7, 4, 3, 2, 5, 8 }

At what partition size will the quick sort cease the "divide and conquer" approach?
1 element correct
2 elements
4 elements
8 elements

Explanation

A quick sort will always continue to partition a list until the partition size is 1 or 0, in which case no swapping will occur and a partition of size 1 or 0 is too small to further partition.


problem


Consider the following list:

{ 1, 6, 7, 4, 3, 2, 5, 8 }

If the list is undergoing quick sort with the value 4 as the pivot for the current pass, what will the list look like after the pass?
{ 1, 2, 3, 4, 5, 6, 7, 8 }
{ 1, 2, 3, 4, 7, 6, 5, 8 } correct
{ 8, 5, 2, 3, 4, 7, 6, 1 }
{ 1, 5, 2, 4, 3, 7, 6, 8 }

Explanation

A quick sort pass will swap elements on either side of the pivot that are on the wrong side. During this process, a right side index and left side index move toward the center and swap values after being compared. In this case, 6 and 2 will swap positions and 7 and 3 will swap positions.


problem


Consider the pseudocode for a quick sort pass, given a lo and hi index representing the inclusive bounds of the partition to be sorted.
void quickSort(pass-by-reference int [] list, int lo, int hi )
    if ( lo ≥ hi )
        return
    end if
    ...

What is the purpose of the if statement in this pseudocode?
The if statement detects a pivot value and returns it
The if statement detects new bounds of a partition and returns it
The if statement detects that the entire list has been sorted and ends execution
The if statement detects a section of the list that is too small to partition any further and ends execution correct

Explanation

A quick sort will not attempt to sort any partition that contains one or zero values. If lo is equal to hi then the current partition only contains one value and no sort will be performed. If lo is greater than hi, the current partition contains no values and no sort will be performed. Note that this method call is only applied to a partition. The pass may be performed on the entire list, but the if statement is only designed to detect the "base case" of the quick sort and does not determine if the entirety of the list is sorted.


problem


Which of the following statements describes a quick sort?
Insert the "next best" value into a portion of a list maintaining a sorted order
Divide and conquer a list, merging portions of the list in sorted order
Partition a list and swap values around a pivot point correct
Select the "next best" value of a list and swap it into a portion of the list that has been sorted.

Explanation

A quick sort partitions lists and swaps values on either side of a pivot value. Partitions and pivots are the key words associated with quick sort.


problem


Which of the following terms is not associated with a quick sort?
merge correct
swap
partition
pivot

Explanation

A quick sort partitions lists and swaps values on either side of a pivot value. No merging occurs during a quick sort.


Algorithm	      Best Case	    Average Case	     Worst Case
Linear Search 	O(1) 	        O(N) 	                 O(N)
Binary Search 	O(1) 	        O(log N) 	             O(log N)
Selection Sort 	O(N2) 	      O(N2) 	               O(N2)
Bubble Sort 	  O(N) 	        O(N2) 	               O(N2)
Insertion Sort 	O(N) 	        O(N2) 	               O(N2)
Merge Sort 	    O(N log N) 	  O(N log N) 	           O(N log N)
Quick Sort  	  O(N log N) 	  O(N log N) 	           O(N2)



Big O Case Practice
problem


Consider two data structures, where one is an Array and the other is a Linked List. Which of the following operations will complete with lower order of complexity for the Array?
Search for a value
Sum all values
Retrieve the nth element of the data structure correct
Sort all values

Explanation

All operations complete with the same theoretical order of complexity except for retrieval by index. Retrieval by index for an Array is always considered to be O(1), but will be O(n) for a Linked List.


problem


Consider the following pseudocode for a sort:
void sort(pass-by-reference int [] list, int lo, int hi )
    int mid ← (lo + hi) / 2
    if ( lo ≠ hi )
        sort( list, lo, mid )
        sort( list, mid + 1, hi)
    end if
    merge( list, lo, mid, mid + 1, hi)
end void

Which is the average case Order of Complexity for this sort?
O(1)
O(N)
O(N log N) correct
O(N2)

Explanation

The presence of the merge call and the division of the list indicates that this is a merge sort. The average case complexity for a merge sort is O(N log N).


problem


In order to reduce best case Order of Complexity, a sort is implemented to immediately detect whether or not a list is sorted, and ends execution if that is the case. What is the Order of Complexity if this sort is called on a completely sorted list?
O(1)
O(N) correct
O(N log N)
O(N2)

Explanation

Detection of a sorted list of N elements still requires a single traversal of all N elements to determine if the list is already in sorted order. Therefore, the best case will never be O(1) complexity. If the algorithm traverses all N elements and then ends execution because it detects a completed sorted list, its best case Order of Complexity is O(N).


problem


Which of the following processes is not associated with an O(N log N) average case sort?
Selecting the best value for a position in the array correct
Partitioning an array using a pivot value
Combining two sorted lists into one sorted list
Selecting a pivot value

Explanation

Selecting the best value is a process associated with a selection sort, which is an O(N2) average case sort. Partioning and pivoting are associated with quick sort, and merging an array is associated with a merge sort. These operations are O(N log N) average case sorts.


problem


For the insertion sort, selection sort, bubble sort and quick sort, what is the running time efficiency for the worst case Order of Complexity?
O(1)
O(N)
O(N log N)
O(N2) correct

Explanation

Insertion, selection and bubble sorts are considered O(N2) class sorts for their worst and average case scenarios, with insertion and bubble having O(N) as a best case runtime. Although the quick sort is generally considered an O(N log N) sort, there are certain cases which will cause it to perform with O(N2) execution time. Typically these are cases where the partitions are very unbalanced throughout the process, usually caused by pivot values that are extreme (the highest or lowest value), with little diversity of values (only a few values appear many times).


problem


Which of the following is not considered an O(N2) class sort for average cases?
Merge Sort correct
Selection Sort
Insertion Sort
Bubble Sort

Explanation

Due to the "divide and conquer" nature of the merge sort, it is considered an O(N log N) class sort for all cases, average, worst, and best.

All Sort Practice
problem


Consider a list:

{ 5, 2, 4, 3, 1 }

After one process step of a sort, the new value order of the list is:

{ 2, 4, 3, 1, 5 }

Which sort was most likely to have been applied to this list?
bubble sort correct
selection sort
merge sort
quick sort, with a pivot value of 4

Explanation

In the pass of this sort, notice that the value 5 has moved to the end of the list, which is its final position. Because the greatest value has moved to the end of the list, this is indicative of a bubble sort. If a selection sort had been applied, only one additional value that was "out of order" would have moved to a different index. For example, 5 and 1 would have simply swapped places if a selection sort had been applied. If a merge sort had been applied and we assume the concept of a "pass" (which doesn't really apply to merge sorts) was analagous to a merging procedure of the smallest divisions of the list, only values adjacent to each other would have exchanged places. In the case of a quick sort "pass", more values would appear to have moved. For example, 3 and 4 would have exchanged places.


problem


Consider a list:

{ 5, 2, 4, 3, 1 }

After one process step of a sort, the new value order of the list is:

{ 1, 2, 4, 3, 5 }

Which sort could have been applied to this list?
bubble sort
selection sort correct
merge sort
quick sort, with a pivot value of 4

Explanation

In the pass of this sort, notice that 1 and 5 are the values that have swapped places. If a bubble sort had been applied, the most that the value 1 would have moved would have been down by one index. If a merge sort prcess had been applied where the smallest divisions of the list are merged, only values adjacent to each other would have exchanged places. In the case of a quick sort "pass", more values would appear to have moved. For example, 3 and 4 would have exchanged places.


problem


Consider the following pseudocode for a sort:
void sort(pass-by-reference int [] list, int lo, int hi )
    if ( lo ≠ hi )
        sort( list, lo, (lo + hi) / 2 )
        sort( list, (lo + hi) / 2 + 1, hi)
    end if
    merge( list, lo, (lo + hi) / 2, (lo + hi) / 2 + 1, hi)
end void

Which sort is this code most likely to represent?
insertion sort
selection sort
merge sort correct
quick sort

Explanation

Although the if statement comprising the first section of the sort pseudocode appears to be similar to a quick sort, notice that it does not perform any swapping around a pivot. Also, notice the call to merge.


problem


Consider the following pseudocode for a sort:
void sort(pass-by-reference int [] list, int lo, int hi )
    int pivot = list[ ( lo + hi ) / 2 ]
    ...

Which sort is this code most likely to represent?
insertion sort
selection sort
merge sort
quick sort correct

Explanation

Pivot value selection is a process associated with quick sort.


problem


Which of the following groups of words are not commonly associated with sorting algorithms?
comparison, swap, pass
partition, pivot
divide, merge
inherit, instantiate correct

Explanation

inherit and instantiate are terminology commonly associated with object oriented programming.


problem


A sort algorithm finds the best place in an already sorted portion of the list for the next unsorted item. Which sort algorithm best fits this description?
selection sort
insertion sort correct
merge sort
quick sort

Explanation

Although selection sort also appears to be a close fit, recall that selection sort exchanges values that are out of place rather than shifting the value into a portion of a list maintaining sorted order.


Domain 1 of the standards covers one-third of the current certification test (version 141), which means you will see thirty or more questions dealing with the competencies listed in this domain.  For the most part, these are technology application standards, the topics of which for the most part are beyond the realm of pure computer science, although loosely related.

In the units of Week 6, the given standards will be listed, with extra information provided as we feel it is necessary. Most of these ideas are second nature, and any questions that deal with these concepts can be worked through with common sense and a basic knowledge of teaching pedagogy.

The summative assessment will attempt to give you taste of what you might see on the test, so that you at least have an idea of what you need to be prepared for. We strongly urge you to examine the first six questions of the practice test in the prep manual for computer science to get a better idea of the type of questions you might expect to see, as well as the practice test in the prep manual for technology applications.





Networking
To recap, here are some of the essentials we think you will need to know for the certification exam:

    Various Networking and Internet concepts and ideas, such as OSI, TCP/IP, and RIP
    Networking terminology, such as LAN and WAN
    Various Networking and Internet Protocols, such as HTTP, SMTP, and POP
    Networking Topologies (ring, star, bus, tree)
    Networking Hardware, such as the router, hub, switch, host, node
    A basic understanding of top-level domains on the Internet

Networking Systems and Devices
Network Systems

    Internet: The ultimate WAN, originally developed by the US Department of Defense to ensure robust and reliable communication in the event of nuclear war, eventually became public
    Ethernet: a high speed communication system for LANs and MANs – created in the 1980s and is the current technology used worldwide – uses Cat 5, Cat 5E, Cat 6, fiber optic cable, and wireless technology

Network Terminology

    MAC Address: A unique identifier assigned to network interface that connects a network to piece of hardware.  It is usually assigned by the computer manufacturer.  A typical MAC address might look like 4c:33:76:92:0e:25 when it is represented as ascii characters.

Network Devices

    Router: king of the WAN – connects LANs
    Switch: king of the LAN – connects nodes within a LAN (servers, computers, printers, etc)
    Hub: also creates a LAN, not as good as a switch, dilutes bandwidth

IP Addresses

The IPv4 Full Address Range work like this:

    32 bits per address in 4 groups of 8; addressed using dotted decimal notation
    Each group of 8 has 256 possible values, 0 - 255
    Total number of addresses is 232, or 2564 or 4,294,967,296 (over 4 billion)

For example, the first and last IP addresses are: 0.0.0.0 – 255.255.255.255

Here are some other exemplar addresses: 0.0.0.0, 0.0.0.1, 0.0.0.2 … 127.255.255.255, 128.0.0.0, 128.0.0.1, 128.0.0.2, … 255.255.255.254 … 255.255.255.255

Private IPv4 Address Ranges are:

    Class A: 10.0.0.0 -- 10.255.255.255
    Class B: 172.16.0.0 -- 172.31.255.255
    Class C: 192.168.0.0 – 192.168.255.255

Remember that IPv6 is the current protocol, created as the old IPv4 system began to run out of addresses, though IPv4 is still in use.
Internet Protocols

Here's a quick recap of several of the protocols that we mentioned in the video.
Protocols and Models that Help the Internet Work

    OSI – Open Systems Interconnection – 7-layer theoretical network model on which Internet is based (Physical, Data Link, Network, Transport, Session, Presentation, Application)
    TCP/IP – Transmission Control Protocol/Internet Protocol – 4-layer network model on which the Internet actually works – aligns with the OSI model
    RIP – Routing Information Protocol – Router software for connecting and managing LANs and WANs

Protocols that Help us work on the Internet

    HTTP – Hyper Text Transfer Protocol – web page protocol
    SMTP – Email protocol – for sending and receiving emails
    POP – Email post office protocol – for storing emails
    FTP – File Transfer Protocol – uploading and downloading files

Network Topologies

Network topologies are different ways that you can arrange a network. Over the years, topologies have evolved to help networks become more robust. Here are several that you need to be familiar with.
Topology	Description	Diagram
Ring 	A network topology is set up in a circular fashion in such a way that they make a closed loop. This way data travels around the ring in one direction and each device on the ring acts as a repeater to keep the signal strong as it travels. Every node is critical and there is no server present. 	Ring Network Topology
Bus 	A network topology in which nodes are connected to a central, backbone known as the bus. While this topology has low implementation costs, it is not robust. The entire network shuts down if there is a break in the main cable. It is also difficult to troubleshoot, and responds slower when more devices are added. 	Bus Network Diagram
Star 	This network topology consists of a central node, to which all other nodes are connected. The star is the most commonly used network topology today. The central hub can be a router, switch, or another computer. 	Star network topology
Tree 	This topology is a combination of Bus and Star, also commonly used in today’s networks. The Internet is one big tree-like structure. 	Tree network topology

Top Level Domains

    .com – commercial
    .org – mainly non-profit
    .net – smaller website systems
    .edu – primarily education institutions
    .gov – government agencies and entities
    .mil – US military use
    Various country domains, such as:
        .us for United States,
        .au for Australia,
        .ca for Canada, and
        .uk for the United Kingdom




HARDWARE AND SOFTWARE ISSUES

As a teacher, you are expected to be able to deal with hardware and software issues that may arise in your classroom. Here are some of the competencies that highlight these concerns.

    Hardware and Software Use -   Be able to use input, output, processing, primary and secondary storage, operating systems, software applications, networking components.
    Select and connect devices - Be able to properly select and connect any hardware device for the typical computer system, i.e. main system, monitor, keyboard, scanner, printer, camera, etc.

 These two standards almost go without saying.  Clearly you as a teacher must be able to manage the hardware and software components of your lab and your teacher workstation, being able to install new devices as well as new software.

    Select, evaluate and acquire appropriate software - Make decisions (professional or personal) on software regarding quality, effectiveness, appropriateness, cost, proper and ethical acquisition.

The software selection process is a crucial aspect of being a responsible computer educator, regardless of the specific field.  Generally speaking, it could be said that common sense should rule for the most part.



USE OF ELECTRONIC RESOURCES

You are also expected to be able to competently and successfully deal with the various issues and tasks surrounding electronic resources. Here are some of the competencies concerning these resources:

    File processes - Be able to do basic file management functions for various applications, such as loading, modifying, saving, copying, storing and organizing in file systems on drives, etc.

These actions are performed on a daily basis by all educators these days, but quite likely were not when these standards were originally written.  Suffice it to say, you are probably are good to go with this one.

    Electronic Resource Use - Find and acquire information from electronic resources, such as online encyclopedias, databases, libraries, reference software, Internet
    Search strategies - Be able to do “Google” style searches using keywords, string patterns, Boolean expressions, etc.

Internet searching is also commonplace for all computer users, and particularly for programmers, and should be a part of your daily research as you prepare for your classes, regardless of the subjects. Remember, even professional programmers will search the web for information when they run int a problem. You need to be able to do this and you need to be able to help steer your students to resources to help them solve problems.

For more significant research, the modern and up-to-date school library is now the center for searching for critical information on the internet, and should be utilized by all teachers and students.

    Information validity - Be able to determine the validity of information found from “Google” style searches
    Resolve Information Conflicts - Be able to research multiple sources to find and verify information or rule out/resolve invalid or conflicting information

Just because it is written on a website on the Internet doesn’t mean it is true! This idea needs to be strongly impressed upon your students, who often mistakenly assume that everything they read in print or on the screen is true. Teach them to think carefully and find corroborating sources for anything they find. Partnering with your school librarian can be a great idea here.




PROPER USE OF INTERNET RESOURCES

As you know, as great as the Internet is, and as much as it has expanded our access to knowledge, that freedom is not without drawbacks. Here are some of the competencies surrounding proper use of Internet resources:

    Ethics -  Know about:
        Citing sources using accepted forms
        Acceptable vs unacceptable use of information
        Issues related to privacy, hacking, piracy, vandalism, virus proliferation, laws and regulations
     Copyright, intellectual property - Know about intellectual property rights and related issues (e.g., copyright laws, fair use, patents, trademarks) when using, manipulating and editing electronic data.
     Online Help - Know how to use online help resources and support documentation
     Technical Writing - Be able to produce tech writing products such as instruction guides and manuals
     Societal Impact of Technology - Know the importance of technology for careers, lifelong learning, daily living

Be prepared to discuss these issues meaningfully with your students throughout your courses (not just in an isolated unit or module) and connect them to your students daily lives.




Computer Security

Protection against bad things and bad people on the Internet is extremely important.  It is absolutely crucial that individuals and organization take steps to install robust protection software that prevents computers and systems from being damaged by these elements.  Here is the competency that deals with this issue:

Protection - Investigate and implement protection measures against “bad stuff” from the Internet, such as viruses, malware, hacking, piracy, etc., in order to prevent tampering, unauthorized use, system damage, and data loss.

And below are some terms and concepts that you will need to familiarize yourself with.
Terms to Know

Antivirus software
    An application that is designed to check computers for viruses and remove them if found. They often also scan all incoming and outgoing data for suspicious code.
Adware
    Although not categorized as malicious, adware is an application that automatically displays or downloads advertisements to a computer. The ads generate income for the attacker, and usually come packaged with malware.
Back Door
    A means of access to a computer or program that bypasses normal security mechanisms.
Bomb
    A virus carrying a built-in time delay so that the virus becomes active after a specific “incubation” time.
Bots
    Derived from the word “robot”, bots (also called zombies) automate tasks and provide information or services that would otherwise be conducted by a human being.  Bots can include the ability to gather keystrokes passwords, or other information.  Malicious bots are self-propagating and connect back to a command and control (C&C) server, creating a “botnet”.  Using a botnet, attackers can launch broad-based attacks remotely.
Firewall
    A network security device (hardware, software, or both) that grants or rejects network access to traffic flows between an untrusted zone and a trusted zone based on a set of rules.
Host
    A computer in which a virus or other malware resides.
Malware
    A general term for malicious software or code (called malcode) specifically designed to damage, disrupt, steal or inflict illegitimate action on data, hosts, or networks.
Phishing
    Attackers use fake emails or websites, appearing to come from a known and trustworthy source, in an attempt to gather personal or financial information from the recipients.
Rootkit
    A program (or set of programs) used to give unfettered administrative access to a machine.  These programs attempt to hide the fact that a system’s security has been compromised and usually provide a backdoor.
Scareware
    A type of malware designed to trick victims into purchasing and downloading useless and potentially dangerous software.  By using legitimate-looking notifications showing a large number of viruses or infected files, users are scared into purchasing software to fix the problems.
Social Engineering
    A non-technical method of intrusion that relies on human interaction and often involves tricking people into breaking normal security procedures.
Spyware
    Software that enables a user to obtain covert information about another's computer activities by secretly transmitting data from their hard drive.
Trojans
    Disguised as legitimate software, Trojans are a harmful piece of software that tricks users into loading and executing it on their systems.  Unlike viruses and worms they do not reproduce by infecting files, nor do they self-replicate.
Virus
    A type of malware that propagates by inserting a copy of itself into another program.  Almost all viruses are attached to an executable file, which means they will not be active or be able to spread until a user runs or opens the host file or program.  Viruses spread when the software or document they are attached to is transferred from one computer to another.
Virus definitions file
    A data file used to update an antivirus program so it can recognize new viruses as they are discovered and documented.
Worm
    Worms are similar to viruses in that they replicate functional copies of themselves, but are standalone software that do not require a host program to propagate. To spread, worms exploit a vulnerability on the target system or use social engineering to trick users into executing them.
Zombie
    In computer science, a zombie is a computer connected to the Internet that has been compromised by a hacker, computer virus or trojan horse and can be used to perform malicious tasks of one sort or another under remote direction. Botnets of zombie computers are often used to spread e-mail spam and launch denial-of-service attacks.







Use of Application Software

The concepts and skills listed in these competencies are quite likely second nature to most teachers, and can be responded to with common sense thinking. However, there are some items that require specific knowledge, and those will be indicated with that objective.

    Word Processing: Know how to plan, create and edit documents using word processing features (e.g., readable fonts, alignment, page setup, tabs, ruler settings) to solve problems and communicate results.
    Spreadsheets: Know how to plan, create and edit spreadsheet features (e.g., data types, formulas, functions, charts) to solve problems and communicate results.

For this competency, be able to build formulas using relative and absolute references. For example, to lock in a row or column in a formula, use the '$' before the row or column value. See the certification test prep guide for an example question covering this competency.

    Database: Know how to plan, create and edit database features (e.g., defining fields, entering data, creating horizontal and vertical layouts) to solve problems and communicate results.
    Integrating objects: Be able to integrate one or more objects (e.g., tables, charts, graphs, graphics) into a product.
    Productivity tools: Be able to use productivity tools to create products (e.g., slide shows, posters, multimedia presentations, spreadsheets) for defined audiences.
    Publishing applications: Be able to publish information in a variety of ways (e.g., printed copy, monitor displays, Internet documents, video).
    Telecommunication software: Be able to use telecommunications (e.g., Internet browsers, video conferencing, distance learning) for a variety of purposes.
    Virtual environments: Be able to use interactive virtual environments (e.g., virtual field trips, instructional simulations)
    Collaborative software: Be able to use collaborative software, such as Google Docs, etc.
    Online communication: Know how to share information through online communication.
    Etiquette rules for polite communication: Have knowledge of issues concerning proper etiquette when communicating using electronic tools, i.e, flaming, trolling, revenge action, etc.
    Design and implement procedures: Be able to design and implement procedures to track trends, set time lines, and review and evaluate products using technology tools such as database managers, daily/monthly planners, and project management tools.
    Evaluate products: Be able to evaluate projects for design, purpose, audience and content delivery using various criteria (e.g., technology specifications, established criteria, rubrics).
    Select products for electronic evaluation: Know how to select representative products to be collected and stored in an electronic evaluation tool and how to evaluate products for relevance to the assignment or task.
    Provide for diverse needs: Know how to plan and design communication products that are accessible to learners with diverse needs and abilities.




Instructional Issues

Similar to the Use of Applications set of competencies, the instructional issues competencies will rely on your knowledge as an educator to be able to solve a variety of problems in your CS classroom. Here are the standards involved:

    Lesson plans: Be able to plan computer science lessons using a range of instructional strategies for individuals or groups.
    Equitable use issues: Have knowledge of issues related to the equitable use of technology (e.g., gender, ethnicity, language, disabilities, access to technology).
    Use CS for problem solving: Plan and implement instruction that allows students to use computer science in problem-solving and decision-making situations.
    Team work and collaboration tasks: Develop and facilitate collaborative tasks and teamwork among group members.
    Administrative tasks: Be able to use technology for gradebook, attendance, email communication.
    Increase reading comprehension: Use computer science to increase reading comprehension.
    Process content: Be able to help students process (locate, retrieve, analyze, evaluate, communicate, and retain) content-related information.
    Assessment: Use formal and informal assessment methods in student project evaluation.
    Adjust instruction: Be able to adjust instruction after gauging student progress through assessment methods.
    Legal and ethical issues: Keep students current with legal and ethical issues related to use of technology resources.
    Electronic communities: Participate in electronic communities related to computer science education.
